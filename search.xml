<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HDU 2000-2099 入门笔记]]></title>
    <url>%2FHDU%202000-2099%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[都说HDU 2000-2099 是acm入门必刷题，为了备战蓝桥杯，巩固知识，我做了一些小笔记与总结。 HDU 1002 A+B Problem two(大数问题)大数问题，通用的方法是使用string进行ascii码的加减 两个数字的ascii码相加减去 0 就是对应数字的ascii码 如果相加的数大于10,相加的ascii码减去10就是个位数 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string sum(string &amp;s1, string &amp;s2)&#123; if (s1 == "" &amp;&amp; s2 == "") return "0"; if (s1 == "") return s2; if (s2 == "") return s1; string max, min; int lens1 = s1.length(); int lens2 = s2.length(); if (lens1 &lt; lens2) &#123; max = s2; min = s1; &#125; else &#123; max = s1; min = s2; &#125; int maxlen = max.length(); int minlen = min.length(); int i, j; for (i = maxlen - 1, j = minlen - 1; j &gt;= 0; j--, i--) &#123; max[i] = max[i] + min[i] - '0'; //相加的ascii码-0就是对应数组的ascii码 &#125; for (int i = maxlen - 1; i &gt; 0; i--) &#123; if (max[i] &gt; '9') &#123; max[i] = max[i] - 10; //相加的ascii码-10就是个位数 max[i - 1] += 1; &#125; &#125; if (max[0] &gt; '9') &#123; max[0] -= 10; max = "1" + max; &#125; return max;&#125;int main()&#123; int num; cin &gt;&gt; num; int i = 1; int count = num; while (num) &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; cout &lt;&lt; s1 &lt;&lt; " + " &lt;&lt; s2 &lt;&lt; " = " &lt;&lt; sum(s1, s2) &lt;&lt; endl; if (i &lt; count) cout &lt;&lt; endl; num--; i++; &#125; return 0;&#125; HDU 2018 母牛的故事(递推)相似：HDU 2044~2050,HDU2041 Description 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？Input 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt; n&lt; 55)，n的含义如题目中描述。 n=0表示输入数据的结束，不做处理。Output 对于每个测试实例，输出在第n年的时候母牛的数量。 每个输出占一行。 分析:​ 以n=6为例，fn=9头牛可以分解为6+3，其中6是上一年（第5年）的牛，3是新生的牛（因为第3年有3头牛，这3头在第6年各生一头牛）。 我们可以得出这样一个公式：fn=fn-1+fn-3 再理解一下，fn-1是前一年的牛，第n年仍然在，fn-3是前三年那一年的牛，但换句话说也就是第n年具有生育能力的牛，也就是第n年能生下的小牛数。 代码: 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int f(int n);int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; cout&lt;&lt;f(n)&lt;&lt;endl; &#125; return 0;&#125; int f(int n)&#123; if(n&lt;4) return n; //第1，2，3年，各为1，2，3头 else return f(n-1)+f(n-3); //第n年为前一年的和前3年的相加&#125; HDU 2031 进制转换(模拟):Problem Description 输入一个十进制数N，将它转换成R进制数输出。 Input 输入数据包含多个测试实例，每个测试实例包含两个整数N(32位整数)和R（2&lt;=R&lt;=16, R&lt;&gt;10）。 Output 为每个测试实例输出转换后的数，每个输出占一行。如果R大于10，则对应的数字规则参考16进制（比如，10用A表示，等等）。 分析: 进制转换,也就是取余,以7的二进制表示: 7%2=1…7/2=3 3%2=1…3/2=1 1%2=1…1/2=0 取余的数字拼接为111,直到商为0为止,即是7的二进制表示 代码: 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int main()&#123; int n,r,i,x,flag; int a[1000]; while (scanf("%d %d",&amp;n,&amp;r)!=EOF) &#123; flag=0; if (n&lt;0) &#123; n=-n; flag=1; &#125; x=0; while (n) &#123; a[x]=n%r; n/=r; x++; &#125; while (x--) &#123; if (flag) &#123; printf("-"); flag=0; &#125; if (a[x]&lt;10) printf("%d",a[x]); else printf("%c",55+a[x]); &#125; printf("\n"); &#125; return 0;&#125; HDU 2048 神、上帝以及老天爷(错排问题)相似：HDU 2049 Description HDU 2006’10 ACM contest的颁奖晚会隆重开始了！为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的： 首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；然后，待所有字条加入完毕，每人从箱中取一个字条；最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！” 大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！ 我的神、上帝以及老天爷呀，怎么会这样呢？ 不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？ 不会算？难道你也想以悲剧结尾？！ Input 输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数n(1 &lt; n &lt; =20),表示参加抽奖的人数。 Output 对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。 分析: 典型的错排问题,具体思路如下: 当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推. 把第n个元素放在一个位置，比如位置k，一共有n-1种方法； 放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法；综上得到 D(n) = (n-1) [D(n-2) + D(n-1)]特殊地，D(1) = 0, D(2) = 1. 代码： 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n; int i,j,num; long long D[22],F[22]; D[1]=0;D[2]=1; for(i=3;i&lt;21;i++) D[i]=(i-1)*(D[i-1]+D[i-2]); for(i=20;i&gt;0;i--)&#123; F[i]=i; for(j=i-1;j&gt;1;j--) F[i]*=j; &#125; scanf("%d",&amp;num); while(num--)&#123; scanf("%d",&amp;n); printf("%.2lf%%\n",D[n]*100.0/F[n]); &#125; return 0;&#125; HDU 2053 Switch Game(开灯问题,唯一分解定理)Problem Description There are many lamps in a line. All of them are off at first. A series of operations are carried out on these lamps. On the i-th operation, the lamps whose numbers are the multiple of i change the condition ( on to off and off to on ). Input Each test case contains only a number n ( 0&lt; n&lt;= 10^5) in a line. Output Output the condition of the n-th lamp after infinity operations ( 0 - off, 1 - on ). 分析： 36的约数是 (1,36), (2,18), (3,12), (4,9), (6)，任何一个数都是由两个不同的数相乘得到的，但是如果一个数为平方数，那么这两个数就可以相等，例如36由两个6相乘得到，所以要判断灯的状态，只需要判断这个数是不是平方数即可 代码： 1234567891011121314#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; double x=sqrt(n*1.0); cout&lt;&lt;(x==int(x))&lt;&lt;endl; &#125; return 0;&#125; HDU 2057 A + B Again (16进制数相加)Problem Description There must be many A + B problems in our HDOJ , now a new one is coming.Give you two hexadecimal integers , your task is to calculate the sum of them,and print it in hexadecimal too.Easy ? AC it ! Input The input contains several test cases, please process to the end of the file.Each case consists of two hexadecimal integers A and B in a line seperated by a blank.The length of A and B is less than 15. Output For each test case,print the sum of A and B in hexadecimal in one line. 分析： 涉及到16进制内的加法，可以用%I64x直接来处理，要注意到16进制中负数是用补码来表示的。一个比较困惑的事实是，这道题再输出时，%64X中‘X’必须是大写，小写是过不了的。 注意：__int64 %I64X ,输出用大写 123456789101112131415#include "cstdio"int main()&#123; __int64 a,b,c; while(~scanf("%I64X%I64X",&amp;a,&amp;b)) &#123; c=a+b; if(c&gt;=0) printf("%I64X\n",c); else printf("-%I64X\n",-c); &#125; return 0;&#125; HDU 2062 Subset sequence（子序列）Problem Description Consider the aggregate An= { 1, 2, …, n }. For example, A1={1}, A3={1,2,3}. A subset sequence is defined as a array of a non-empty subset. Sort all the subset sequece of An in lexicography order. Your task is to find the m-th one. Input The input contains several test cases. Each test case consists of two numbers n and m ( 0&lt; n&lt;= 20, 0&lt; m&lt;= the total number of the subset sequence of An ). Output For each test case, you should output the m-th subset sequence of An in one line. 分析： 当n=2的时候 子序列从小到大 {1}, {1, 2}, {2}, {2, 1} 当n=3的时候 子序列从小到大 {1} {1, 2} {1, 2, 3} {1, 3} {1, 3, 2} {2}{2, 1}{2, 1, 3}{2, 3}{2, 3, 1} {3}{3, 1}{3, 1, 2}{3, 2}{3, 2, 1} 不难发现，An可以按首数字分成n组，而每组里除了第一项，剩下的就是An-1的子集合了。 ∴f(n) = n[f(n-1) + 1] f(1) = 1 我们拿测试数据3 10来做个示范，解释一下怎么求解。 因为n=3，所以开始数组里1、2、3三个数。 我们知道，n=2时，有4种排列，所以上面n=3可以分成三组，每组5个(加上空集)。 //空集就是说去掉该组第一个数字后为空集 因此第10个在第二组里。所以第一个是2，把2输出。原来的数组里删除2，变成1、3两个数。然后10 - (2 - 1) * 5 =5，即它在第2组的第5个。 //请自行推导所在位置 减去首个空集合，5 - 1 = 4 ≠ 0，表示2后面还有数字。 因为A1 = 1是，所以再第2组里又可以分成两组，每组2个(加上空集)。 所以，4在第2组，剩下的数组中，第二个元素是3，所以输出3。再把数组里的3删除，剩下1一个数。 然后4 - (2 - 1) * 2 = 2，既它是第2组的第2个。 减去首个空集，2 - 1 = 1 ≠ 0，表示2后面还有数字。 按上面的方法继续下去，直到n = 0 或 后面为空集为止。 最后输出数组里的第1个元素，就得到2 3 1，就是解了。从上面的计算可以看出来，本题目的关键是先求的An中每一组的个数g(n) 不难得出:g(n) = f(n) / n ∵f(n) = n[f(n-1) + 1] ∴g(n) = n[f(n-1) + 1] / n = f(n-1) + 1 ∵f(n-1) = (n-1) * g(n-1) ∴g(n) = (n-1) * g(n-1) + 1 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;cstring&gt;int main()&#123; int a; __int64 b; __int64 g[30]; g[1]=1; g[2]=2; for(int i=3;i&lt;22;i++) &#123; g[i]=g[i-1]*(i-1)+1;//求出g； &#125; int num[30]; while(scanf("%d%I64d",&amp;a,&amp;b)!=EOF) //b的数可能很大，所以用I64d，，用int运行错了 &#123; memset(num,0,sizeof(num));//清零 for(int i=1;i&lt;=a;i++) num[i]=i; //将要输出的数字保存在数组里 int am=a; while(a--)//总共有a个数（1---a）最多可能输出a个 &#123; int n=b%g[a+1]? b/g[a+1]+1: b/g[a+1]; //我们用b取余对应的g，，得到要输出的数在第几组 if(num[n]==0) break; if(am-1==a) printf("%d",num[n]); / /输出对应的组代表的数字 else printf(" %d",num[n]); for(int i=n;i&lt;=a;i++) num[i]=num[i+1]; //将刚输出的数字删掉，，留下剩下的数字，，没用的数字都变成0了 b=(b-g[a+1]*(n-1)-1); //把问题缩小到下一组，，， 求出在下一组的位置；循环；直到要输出的num为0，说明所有的数都输完了； &#125; printf("\n"); &#125; return 0;&#125; HDU 2064 汉诺塔Ⅲ（递归）Problem Description 约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？ Input 包含多组数据，每次输入一个N值(1&lt;=N=35)。 Output 对于每组数据，输出移动最小的次数。 分析： 建议阅读 如何理解汉诺塔的递归？ - 知乎 其实本题的复杂之处就是相当与比以往的汉诺塔多移动了一次柱子，原来，现在a4=a3+a3+a3+2(移动最大的圆盘要两次)，理解了便能很快求解 待补充： HDU 2059 Seraph2012 (DP)HDU 2037 今年暑假不AC（贪心）推荐：贪心算法 Problem Description“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）Input输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。Output对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。 分析：最简单的贪心算法，因为一个节目对应一个开始时间和一个结束时间，所以，将这两个时间放到一个结构体中，然后对结束时间按照从小到大的顺序进行排序，如果结束的时间相同的话，就将开始的时间按照从大到小的顺序排序，然后开始比较，如果开始的时间比前一个结束的时间迟，就k++，最终k的值即为所求！ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std; struct Program&#123; int start,end;&#125;pro[10001]; int main()&#123; int n,sum,final; int i,j; Program temp; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; for(i=0;i&lt;n;++i) &#123; scanf("%d%d",&amp;pro[i].start,&amp;pro[i].end); &#125; for(i=0;i&lt;n-1;++i) for(j=i+1;j&lt;n;++j) if(pro[i].end&gt;pro[j].end) &#123; temp=pro[i]; pro[i]=pro[j]; pro[j]=temp; &#125; sum=1; final=pro[0].end; for(i=1;i&lt;n;++i) &#123; if(final&lt;=pro[i].start) &#123; ++sum; final=pro[i].end; &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125; HDU 2063 过山车 （二分图的最大匹配、完美匹配和匈牙利算法）https://www.renfei.org/blog/bipartite-matching.html 小技巧：输出控制：c++中用cout输出，要求保留两位小数，比如，输出100，则为100.00 1cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;456.777&lt;&lt;endl 标准开头：1while (scanf("%d %d",&amp;n,&amp;r)!=EOF) 16进制数相加：1scanf("%I64X%I64X",&amp;a,&amp;b)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>tests</tag>
      </tags>
  </entry>
</search>
