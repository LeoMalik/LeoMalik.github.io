<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git如何回滚错误的提交</title>
      <link href="/Git%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E6%8F%90%E4%BA%A4.html"/>
      <url>/Git%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E6%8F%90%E4%BA%A4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git如何回滚一次错误的合并"><a href="#Git如何回滚一次错误的合并" class="headerlink" title="Git如何回滚一次错误的合并"></a>Git如何回滚一次错误的合并</h1><blockquote><p>原文发表在知乎专栏 <a href="https://link.juejin.im/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F40220954" rel="external nofollow noopener noreferrer" target="_blank">前端杂货铺</a>, 欢迎关注我的专栏，转载请注明出处</p></blockquote><p>今天不说前端，来聊聊git吧。 发现现在的小孩，玩框架一套一套的，等到玩点实质的工程化的东西就不行了。 git 这么好的工具，培训班怎么可以忽视他的重要性呢？</p><h2 id="再来聊聊git的工作流程"><a href="#再来聊聊git的工作流程" class="headerlink" title="再来聊聊git的工作流程"></a>再来聊聊git的工作流程</h2><p>很多人对<a href="https://link.juejin.im/?target=https%3A%2F%2Fgit-scm.com%2Fbook%2Fzh%2Fv2%2F%25E8%25B5%25B7%25E6%25AD%25A5-Git-%25E5%259F%25BA%25E7%25A1%2580" rel="external nofollow noopener noreferrer" target="_blank">Git究竟是一个怎样的系统</a>，还是一知半解。 在这里强烈建议大家先理解git的核心思想和工作原理，有过<code>subversion</code>或者<code>perforce</code>使用经验的人更是需要摒弃之前所见所学，重新接受这样一个新思想。 我们不再这里赘述其几本原理，我们来介绍一下其简单工作流程。 Git以一个自有的思维框架管理着三个不同的盒子<code>Commit History</code>、<code>INDEX</code>、<code>Working Directory</code>。</p><ul><li><code>Commit History</code> 历史记录，存储着所有提交的版本快照，并由当前分支引用的指针HEAD指向该分支最新一条提交。</li><li><code>INDEX</code> 索引，也叫暂存区域。它是一个文件，保存着即将提交的文件列表快照。</li><li><code>Working Directory</code> 工作目录，是从git仓库压缩数据当前版本中解包出来的文件列表。所以你在本地磁盘看到的你项目源码的文件列表，其实就是git开放给你的一个沙盒。在你将文件的修改天道到暂存区域并将快照记录到历史之前，你可以随意更改。</li></ul><p>理解了这三者的含义后，我们试着来理解一下git的工作流程。 一切的开始，混沌之间，我们要干一件大事，在terminal里面敲打了几下键盘</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">init</span> </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>混沌初开，幻化三界：<code>HEAD</code>、<code>INDEX</code>、<code>Working Directory</code>。这就是世界最开始的样子git仓库仿佛就是掌管三界之神。而<code>Working Directory</code>就是他分配给你生产和工作的地方，你可以在这里肆意的创造。而为了安全和管理的有序我们需要把我们的添加与修改的文件交给git仓库。Git首先会将修改的文件标记起来放入暂存区、然后git找到暂存区域的文件内容将其永久性的存储为快照到git仓库，此时<code>HEAD</code>的指针指向这个最新的快照。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/27/164da5f0836dcb23?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>如图，总结下三个步骤</p><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。<code>git add</code></li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 <code>git commit</code></li></ol><p>git 的基本工作流程就是在不断的重复这三个步骤,最终git仓库目录形成了一个快照堆栈，每产生一次新的版本，HEAD就会指向这个版本。</p><p>这里我们创建了下面这些文件：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── v1.js</span><br><span class="line">├── v2.js</span><br><span class="line">└── v3.js</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>形成了下图的提交历史</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>aa5dfb v3  (&lt;- HEAD)</span><br><span class="line">        <span class="string">|</span></span><br><span class="line"><span class="number">5</span>aab391 v2</span><br><span class="line">        <span class="string">|</span></span><br><span class="line">ff7b88e v1</span><br><span class="line">        <span class="string">|</span></span><br><span class="line"><span class="number">95</span>d7816 init commit</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>下面我们来看看怎么利用checkout、reset、revert 来操作这个仓库目录</p><h2 id="checkout-、reset-还是-revert-？"><a href="#checkout-、reset-还是-revert-？" class="headerlink" title="checkout 、reset 还是 revert ？"></a>checkout 、reset 还是 revert ？</h2><h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><p>版本控制系统背后的思想就是「安全」地储存项目的拷贝，这样你永远不用担心什么时候不可复原地破坏了你的代码库。当你建立了项目历史之后，git checkout 是一种便捷的方式，来将保存的快照「解包」到你的工作目录上去。 <code>git checkout</code> 可以检出提交、也可以检出单个文件甚至还可以检出分支(此处省略)。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="number">5</span>aab391</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>检出v2,当前工作目录和<code>5aab391</code>完全一致，你可以查看这个版本的文件编辑、运行、测试都不会被保存到git仓库里面。你可以<code>git checkout master</code> 或者 <code>git checkout -</code>回到原来的工作状态上来。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="number">5</span>aab391 <span class="built_in">v1</span>.<span class="keyword">js</span></span><br><span class="line"><span class="keyword">复制代码</span></span><br></pre></td></tr></table></figure><p>以检出v2版本对于v1.js的改动，只针对v1.js这个文件检出到<code>5aab391</code>版本。所以 它会影响你当前的工作状态，它会把当前状态的v1.js文件内容覆盖为<code>5aab391</code>版本。所以除非你清楚你在做什么，最好不要轻易的做这个操作。但这个操作对于舍弃我当前的所有改动很有用：比如当前我在v1.js上面做了一些改动，但我又不想要这些改动了，而我又不想一个个去还原，那么我可以<code>git checkout HEAD v1.js</code> 或者 <code>git checkout -- v1.js</code></p><h3 id="reset-重置"><a href="#reset-重置" class="headerlink" title="reset 重置"></a>reset 重置</h3><p>和 <code>git checkout</code> 一样, <code>git reset</code> 有很多用法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> &lt;<span class="keyword">file</span>&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>从暂存区移除特定文件，但不改变工作目录。它会取消这个文件的缓存，而不覆盖任何更改。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">reset</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>重置暂存区，匹配最近的一次提交，但工作目录不变。它会取消所有文件的暂存，而不会覆盖任何修改，给你了一个重设暂存快照的机会。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>加上<code>--hard</code>标记后会告诉git要重置缓存区和工作目录的更改，就是说：先将你的暂存区清除掉，然后将你所有未暂存的更改都清除掉，所以在使用前确定你想扔掉所有的本地工作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> &lt;<span class="keyword">commit</span>&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>将当前分支的指针HEAD移到 ，将缓存区重设到这个提交，但不改变工作目录。所有 之后的更改会保留在工作目录中，这允许你用更干净、原子性的快照重新提交项目历史。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard &lt;commit&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>将当前分支的指针HEAD移到 ，将缓存区和工作目录都重设到这个提交。它不仅清除了未提交的更改，同时还清除了 之后的所有提交。</p><p>可以看出，<code>git reset</code> 通过取消缓存或者取消一系列提交的操作会摒弃一些你当前工作目录上的更改，这样的操作带有一定的危险性。下面我们开始介绍一种相对稳妥的方式 <code>revert</code></p><h3 id="revert-撤销"><a href="#revert-撤销" class="headerlink" title="revert 撤销"></a>revert 撤销</h3><p><code>git revert</code>被用来撤销一个已经提交的快照。但实现上和reset是完全不同的。通过搞清楚如何撤销这个提交引入的更改，然后在最后加上一个撤销了更改的 新 提交，而不是从项目历史中移除这个提交。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">revert </span>&lt;commit&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>生成一个撤消了 引入的修改的新提交，然后应用到当前分支。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/27/164da5f083cd9c5b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><p>例如：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">81</span>f734d commit <span class="built_in">after</span> bug</span><br><span class="line">        |<span class="type"></span></span><br><span class="line"><span class="type">3a395af</span> bug</span><br><span class="line">        |<span class="type"></span></span><br><span class="line"><span class="type">3aa5dfb</span> v3  (&lt;- HEAD)</span><br><span class="line">        |<span class="type"></span></span><br><span class="line"><span class="type">5aab391</span> v2</span><br><span class="line">        |<span class="type"></span></span><br><span class="line"><span class="type">ff7b88e</span> v1</span><br><span class="line">        |<span class="type"></span></span><br><span class="line"><span class="type">95d7816</span> init commit</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>我们在<code>3a395af</code> 引入了一个bug，我们明确是由于<code>3a395af</code>造成的bug的时候，以其我们通过新的提交来fix这个bug，不如<code>git revert</code>, 让他来帮你剔除这个bug。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">revert </span><span class="number">3</span>a395af</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cfb71fc Revert <span class="string">"bug"</span></span><br><span class="line">        |<span class="type"></span></span><br><span class="line"><span class="type">81f734d</span> commit <span class="built_in">after</span> bug</span><br><span class="line">        |<span class="type"></span></span><br><span class="line"><span class="type">3a395af</span> bug</span><br><span class="line">        |<span class="type"></span></span><br><span class="line"><span class="type">3aa5dfb</span> v3  (&lt;- HEAD)</span><br><span class="line">        |<span class="type"></span></span><br><span class="line"><span class="type">5aab391</span> v2</span><br><span class="line">        |<span class="type"></span></span><br><span class="line"><span class="type">ff7b88e</span> v1</span><br><span class="line">        |<span class="type"></span></span><br><span class="line"><span class="type">95d7816</span> init commit</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个时候bug的改动被撤销了，产生了一个新的commit，但是<code>commit after bug</code>没有被清初。</p><p>所以相较于<code>reset</code> ，<code>revert</code>不会改变项目历史，对那些已经发布到共享仓库的提交来说这是一个安全的操作。其次<code>git revert</code>可以将提交历史中的任何一个提交撤销、而<code>reset</code>会把历史上某个提交及之后所有的提交都移除掉，这太野蛮了。</p><p>另外<code>revert</code>的设计，还有一个考量，那就是撤销一个公共仓库的提交。至于为什么不能用<code>reset</code>，你们可以自己思考一下。 下面我们就用一个麻烦事（回滚一个错误的合并），来讲解这个操作。</p><h2 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h2><p>相对于常规的<code>commit</code>，当使用<code>git merge &lt;branch&gt;</code>合并两个分支的时候，你会得到一个新的<code>merge commit</code>. 当我们<code>git show &lt;commit&gt;</code>的时候会出现类似信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">commit 6dd0e2b9398ca8cd12bfd1faa1531d86dc41021a</span><br><span class="line">Merge: d24d3b4 11a7112</span><br><span class="line">Author: 前端杂货铺 </span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span>.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>Merge: d24d3b4 11a7112</code> 这行表明了两个分支在合并时，所处的parent的版本线索。</p><p>比如在上述项目中我们开出了一个dev分支并做了一些操作，现在分支的样子变成了这样：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span> -&gt;</span> <span class="function"><span class="title">v1</span> -&gt;</span> <span class="function"><span class="title">v2</span> -&gt;</span> v3  (master)</span><br><span class="line">           \      </span><br><span class="line">            <span class="function"><span class="title">d1</span> -&gt;</span> d2  (dev)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当我们在dev开发的差不多了</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#git:(dev)</span></span><br><span class="line">git checkout <span class="keyword">master</span> <span class="title"></span></span><br><span class="line"><span class="title">#git</span>:(<span class="literal">master</span>)</span><br><span class="line">git merge dev</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个时候形成了一个Merge Commit <code>faulty merge</code></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span> -&gt;</span> <span class="function"><span class="title">v1</span> -&gt;</span> <span class="function"><span class="title">v2</span> -&gt;</span> v3 -- faulty merge  (master)</span><br><span class="line">           \            /</span><br><span class="line">            <span class="function"><span class="title">d1</span>  --&gt;</span>  d2  (dev)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此时<code>faulty merge</code>有两个parent 分别是v3 和 d2。</p><h2 id="回滚错误的合并"><a href="#回滚错误的合并" class="headerlink" title="回滚错误的合并"></a>回滚错误的合并</h2><p>这个merge之后还继续在dev开发，另一波人也在从别的分支往master合并代码。变成这样：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span> -&gt;</span> <span class="function"><span class="title">v1</span> -&gt;</span> <span class="function"><span class="title">v2</span> -&gt;</span> <span class="function"><span class="title">v3</span> -- faulty merge -&gt;</span> <span class="function"><span class="title">v4</span> -&gt;</span> vc3 (master)</span><br><span class="line">        \  \            /                     /</span><br><span class="line">         \  <span class="function"><span class="title">d1</span>  --&gt;</span>  <span class="function"><span class="title">d2</span>  --&gt;</span> <span class="function"><span class="title">d3</span> --&gt;</span> d4  (dev)/</span><br><span class="line">          \                                 / </span><br><span class="line">           <span class="function"><span class="title">c1</span>  --&gt;</span>  c2 -------------------c3 (other)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这个时候你发现， 妈也上次那个merge 好像给共享分支master引入了一个bug。这个bug导致团队其他同学跑不通测试，或者这是一个线上的bug，如果不及时修复老板要骂街了。</p><p>这个时候第一想到的肯定是回滚代码，但怎么回滚呢。用<code>reset</code>?不现实，因为太流氓不说，还会把别人的代码也干掉，所以只能用<code>revert</code>。而<code>revert</code>它最初被设计出来就是干这个活的。</p><p>怎么操作呢？首先想到的是上面所说的 <code>git revert &lt;commit&gt;</code> ,但是貌似不太行。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git revert faulty merge</span><br><span class="line"><span class="keyword">error: </span>Commit faulty merge is a merge but no -m option was given.</span><br><span class="line">fatal: revert failed</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>这是因为试图撤销两个分支的合并的时候Git不知道要保留哪一个分支上的修改。所以我们需要告诉git我们保留那个分支<code>m</code> 或者<code>mainline</code>.</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">revert </span>-m <span class="number">1</span> faulty merge</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><code>-m</code>后面带的参数值 可以是1或者2，对应着parent的顺序.上面列子：1代表<code>v3</code>，2代表<code>d2</code> 所以该操作会保留master分支的修改，而撤销dev分支合并过来的修改。</p><p>提交历史变为</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span> -&gt;</span> <span class="function"><span class="title">v1</span> -&gt;</span> <span class="function"><span class="title">v2</span> -&gt;</span> <span class="function"><span class="title">v3</span> -- faulty merge -&gt;</span> <span class="function"><span class="title">v4</span> -&gt;</span> <span class="function"><span class="title">vc3</span> -&gt;</span> rev3 (master)</span><br><span class="line">          \            /                     </span><br><span class="line">           <span class="function"><span class="title">d1</span>  --&gt;</span>  <span class="function"><span class="title">d2</span>  --&gt;</span> <span class="function"><span class="title">d3</span> --&gt;</span> d4  (dev)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此处<code>rev3</code>是一个常规commit，其内容包含了之前在<code>faulty merge</code>撤销掉的dev合并过来的commit的【反操作】的合集。</p><p>到这个时候还没完，我们要记住，因为我们抛弃过之前dev合并过来的commit，下次dev再往master合并，之前抛弃过的其实是不包含在里面的。那怎么办呢？</p><h2 id="恢复之前的回滚"><a href="#恢复之前的回滚" class="headerlink" title="恢复之前的回滚"></a>恢复之前的回滚</h2><p>很简单我们把之前master那个带有【反操作】的commit给撤销掉不就好了？</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="literal">master</span></span><br><span class="line">git revert rev3</span><br><span class="line">git merge dev</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>此时提交历史变成了</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span> -&gt;</span> <span class="function"><span class="title">v1</span> -&gt;</span> <span class="function"><span class="title">v2</span> -&gt;</span> <span class="function"><span class="title">v3</span> -- faulty merge -&gt;</span> <span class="function"><span class="title">v4</span> -&gt;</span> <span class="function"><span class="title">vc3</span> -&gt;</span> <span class="function"><span class="title">rev3</span> -&gt;</span> <span class="function"><span class="title">rev3</span>` -&gt;</span> final merge (master)</span><br><span class="line">          \            /                                               /</span><br><span class="line">           <span class="function"><span class="title">d1</span>  --&gt;</span>  <span class="function"><span class="title">d2</span>  --&gt;</span> <span class="function"><span class="title">d3</span> --&gt;</span> d4  --------------------------------(dev)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我想要讲的关于git回滚代码的一些操作，有不对的地方还望指正。另Git 是一门艺术，是一种非常精妙的设计，当你使用上手后，你会发现越来越多好玩的东西，并为设计git的人默默点个赞。也希望在前端领域不论是初学还是深凿者，在追逐流行框架的时候，都不要忘了学习这些基础的工具。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《pro git》</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgit-scm.com%2Fbook%2Fzh%2Fv2%2FGit-%25E5%25B7%25A5%25E5%2585%25B7-%25E9%2587%258D%25E7%25BD%25AE%25E6%258F%25AD%25E5%25AF%2586" rel="external nofollow noopener noreferrer" target="_blank">重置揭秘</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fgeeeeeeeeek%2Fgit-recipes" rel="external nofollow noopener noreferrer" target="_blank">git-recipes</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 【Git,版本控制] </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01背包、完全背包、多重背包</title>
      <link href="/01%E8%83%8C%E5%8C%85%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html"/>
      <url>/01%E8%83%8C%E5%8C%85%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天花了一下午加一晚上的时间，在HDUOJ才ac了一道简单的多重背包题目2069，其实也是一道动态规划题目，看来要加紧动态规划的练习了，之前没做过多重背包的题目，导致我做题时复杂化了，虽然是假期但是也不能这么浪费时间，果断总结一下，这里参考了dd_engi大牛的《背包问题九讲》，原文链接：<a href="https://www.kancloud.cn/kancloud/pack/70125" rel="external nofollow noopener noreferrer" target="_blank">https://www.kancloud.cn/kancloud/pack/70125</a></p><a id="more"></a><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>有N件物品和一个容量为V的背包。第i建物品的费用是c[i],价值是w[i]。求解将哪些物品装入背包可使价值总和最大</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这是最基础的背包问题，特点是：每种物品只有一件，可以选择放或者不放</p><p>用子问题定义状态：即dp[i][j]表示前i件物品放入一个容量为j的背包可以获得的最大价值。则其状态转移方程为：</p><p>dp[i][j] = max{dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]}</p><p>这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来。这里详细解释一下：</p><p>将前i件物品放入容量为j的背包中这个子问题，若只考虑第i件物品的策略（放或者不放），那么就可以转换为一个只牵扯前i-1件物品的问题。<br>如果不放第i件物品，那么问题就转换为前i-1件物品放入容量为j的背包中的最大价值，价值为dp[i - 1][j]<br>如果放入第i件物品，那么问题就转换为前i-1件物品放入容量为j-c[i]的背包中，此时能获得的最大价值是dp[i-1][j-c[i]],再加上放入第i件物品获得的价值w[i]</p><h4 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h4><p>先考虑一下上面的状态转移方程如何实现，肯定有一个主循环i = 1…N,每次算出来二维数组dp[i][0..V]的所有值。那么如果只用一个数组f[0…V],能不能保证第i次循环结束后f[v]就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V…0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下：</p><p>for i  in 0 … N<br>    for  v = V … 0<br>        f[v] = max{f[v], f[v-c[i]] + w[i]}</p><h4 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h4><p>题目：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2602" rel="external nofollow noopener noreferrer" target="_blank">http://acm.hdu.edu.cn/showproblem.php?pid=2602</a></p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1010</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> value[N], volume[N], dp[N];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 0-1背包，优化空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dpPackage</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = v; j &gt;= volume[i]; j --) &#123;</span><br><span class="line">dp[j] = dp[j] &gt; dp[j - volume[i]] + value[i] ? dp[j] : dp[j - volume[i]] + value[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[v]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, t, n, v;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (t --) &#123;</span><br><span class="line"><span class="comment">// 接收参数</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;v);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i ++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, value + i);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i ++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>, volume + i);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 0-1背包</span></span><br><span class="line">dpPackage(n, v);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价格是w[i].求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>这个问题类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已非取或不取两种，而且右取0件、取1件、取2件…等很多种。如果仍然按照01背包的思路，令dp[i][v]表示前i种物品恰好放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][v] = max&#123;dp[i<span class="number">-1</span>][v - k * c[i]] + k * w[i] | <span class="number">0</span> &lt;= k * c[i]&lt;= v&#125;</span><br></pre></td></tr></table></figure><h4 id="转化为01背包求解"><a href="#转化为01背包求解" class="headerlink" title="转化为01背包求解"></a>转化为01背包求解</h4><p>最简单的想法是：考虑到第i种物品最多选V/c[i]件，于是可以把第i种物品转换为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。但是这样完全没有改进时间复杂度，但这毕竟给了我们将完全背包转换为01背包问题的思路：将一种物品拆成多件物品</p><p>O(VN)的算法<br>这个算法使用一维数组，先看伪代码：</p><p>for i = 1 … N<br>    for v = 0 … V<br>        f[v] = max{f[v], f[v-cost] + weight}</p><p>你会发现，这个伪代码与01背包的伪代码只有v的循环次序不同而已。为什么这样一改就行呢？首先，想想为什么01背包问题中要按照v=V…0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰好是每种物品可选无限件，所以在考虑“加选一件dii种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][c-v[i]],所以就可以并且必须采用v=0…V的顺序循环</p><h4 id="练习题目-1"><a href="#练习题目-1" class="headerlink" title="练习题目"></a>练习题目</h4><p>题目链接：<a href="http://ac.jobdu.com/problem.php?pid=1454" rel="external nofollow noopener noreferrer" target="_blank">http://ac.jobdu.com/problem.php?pid=1454</a></p><h4 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完全背包问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 50000000</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">coin</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> price, weight;</span><br><span class="line">&#125; coin;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamicPackage</span><span class="params">(coin *coins, <span class="keyword">int</span> n, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (v &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This is impossible.\n"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i, j, *dp;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 动态分配内存</span></span><br><span class="line">dp = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (v + <span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= v; i ++)dp[i] = INF;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 完全背包问题</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = coins[i].weight; j &lt;= v; j ++) &#123;</span><br><span class="line">dp[j] = (dp[j] &lt; dp[j - coins[i].weight] + coins[i].price) ? dp[j] : dp[j - coins[i].weight] + coins[i].price;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (dp[v] &gt;= INF)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"This is impossible.\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The minimum amount of money in the piggy-bank is %d.\n"</span>, dp[v]);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 清理内存</span></span><br><span class="line"><span class="built_in">free</span>(dp);</span><br><span class="line">dp = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t, e, f, n, i;</span><br><span class="line">coin *coins;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (t --) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;e, &amp;f);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 接收货币</span></span><br><span class="line">coins = (coin *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(coin) * (n + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (coins == <span class="literal">NULL</span>)<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;coins[i].price, &amp;coins[i].weight);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 完全背包</span></span><br><span class="line">dynamicPackage(coins, n, f - e);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="built_in">free</span>(coins);</span><br><span class="line">coins = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大</p><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>多重背包问题的思路跟完全背包的思路非常类似，只是k的取值是有限制的，因为每件物品的数量是有限制的，状态转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpi = max&#123;dpi - <span class="number">1</span>] + w[i] | <span class="number">0</span> &lt;=k &lt;= n[i]&#125;</span><br></pre></td></tr></table></figure><h4 id="练习题目-2"><a href="#练习题目-2" class="headerlink" title="练习题目"></a>练习题目</h4><p>题目：<a href="http://ac.jobdu.com/problem.php?pid=1455" rel="external nofollow noopener noreferrer" target="_blank">http://ac.jobdu.com/problem.php?pid=1455</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rice</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> price, weight, num;</span><br><span class="line">&#125; rice;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamic</span><span class="params">(rice *rices, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, cur, k, **dp;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 动态申请二维数组</span></span><br><span class="line">    dp = (<span class="keyword">int</span> **)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *) * (m + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i ++)</span><br><span class="line">        dp[i] = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i ++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; j ++)</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= rices[i].num; k ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - k * rices[i].price &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    cur = dp[i - <span class="number">1</span>][j - k * rices[i].price] + k * rices[i].weight;</span><br><span class="line">                    dp[i][j] = dp[i][j] &gt; cur ? dp[i][j] : cur;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[m][n]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m; i ++)</span><br><span class="line">        <span class="built_in">free</span>(dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, c, n, m;</span><br><span class="line">     </span><br><span class="line">    rice rices[<span class="number">2010</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (c --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;rices[i].price, &amp;rices[i].weight, &amp;rices[i].num);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 多重背包问题</span></span><br><span class="line">        dynamic(rices, m, n);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>主要还是为了巩固01背包问题并且多做点题目，所以记录了一下学习《背包九讲》的过程，大家真想搞清楚背包问题，建议还是参考原文链接：<a href="https://www.kancloud.cn/kancloud/pack/70125" rel="external nofollow noopener noreferrer" target="_blank">https://www.kancloud.cn/kancloud/pack/70125</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coursera Algorithms week1 3Sum in quadratic time</title>
      <link href="/Coursera%20Algorithms%20week1%203Sum%20in%20quadratic%20time.html"/>
      <url>/Coursera%20Algorithms%20week1%203Sum%20in%20quadratic%20time.html</url>
      
        <content type="html"><![CDATA[<p>本题为《算法4》作者 Robert Sedgewick 和 Kevin Wayne 在 Cursera 上开设的公开课的习题解答，本题出自以下地址中的课后题。<br>题目链接：<a href="https://www.coursera.org/learn/algorithms-part1/quiz/lhs1X/interview-questions-analysis-of-algorithms-ungraded" rel="external nofollow noopener noreferrer" target="_blank">coursera</a></p><p>题目要求：</p><p>Design an algorithm for the 3-SUM problem that takes time proportional to n2 in the worst case. You may assume that you can sort the n integers in time proportional to n2 or better.</p><a id="more"></a><p><strong>分析：</strong></p><p>《算法4》这本书提供的TwoSumFast解法为NlogN，ThreeSumFast解法为N2logN，根据课后练习，要实现3Sum复杂度为N2，建议先把2Sum复杂度实现为N。同时教材提示用排好序的数组可以实现复杂度N。我想了很久，没有发现排好序的数组对复杂度降至N有太大帮助，于是在网上搜索了下大家的做法。网上的大部分都是建议用set或map来做，我决定采用map试试，果然用map很方便。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> <span class="number">2</span> <span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoSumLinear</span> </span>&#123;</span><br><span class="line"> <span class="number">5</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>&#123;</span><br><span class="line"> <span class="number">6</span>         <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"> <span class="number">7</span>         <span class="keyword">int</span> n = a.length;</span><br><span class="line"> <span class="number">8</span>         HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line"><span class="number">10</span>             <span class="keyword">if</span>(map.get(a[i]) == <span class="keyword">null</span>) map.put(a[i], i);</span><br><span class="line"><span class="number">11</span>             Integer negIndex = map.get(-a[i]);</span><br><span class="line"><span class="number">12</span>             <span class="keyword">if</span>(negIndex != <span class="keyword">null</span> &amp;&amp; negIndex != i)&#123;</span><br><span class="line"><span class="number">13</span>                 System.out.println(<span class="string">"a["</span>+negIndex+<span class="string">"]="</span>+(-a[i])+<span class="string">"和a["</span>+i+<span class="string">"]="</span>+a[i]);</span><br><span class="line"><span class="number">14</span>                 cnt++;</span><br><span class="line"><span class="number">15</span>             &#125;</span><br><span class="line"><span class="number">16</span>         &#125;</span><br><span class="line"><span class="number">17</span>         <span class="keyword">return</span> cnt;</span><br><span class="line"><span class="number">18</span>     &#125;</span><br><span class="line"><span class="number">19</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="number">20</span>         <span class="keyword">int</span>[] a = &#123; <span class="number">30</span>, -<span class="number">40</span>, -<span class="number">20</span>, -<span class="number">10</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="number">21</span>         System.out.println(Arrays.toString(a));</span><br><span class="line"><span class="number">22</span>         System.out.println(count(a));</span><br><span class="line"><span class="number">23</span>     &#125;</span><br><span class="line"><span class="number">24</span> &#125;</span><br></pre></td></tr></table></figure><p>3Sum的作业提示可以先将数组排序，基于这个思路，结合写过的2Sum线性实现方法，写出了复杂度为N2的3Sum，个人认为实现的方式已经很精简了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"> <span class="number">2</span> <span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSumQuadratic</span> </span>&#123;</span><br><span class="line"> <span class="number">5</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"> <span class="number">6</span>         Arrays.sort(a);<span class="comment">// 数组从小到大排序，后面要使用有序数组的性质简化运算</span></span><br><span class="line"> <span class="number">7</span>         System.out.println(Arrays.toString(a));</span><br><span class="line"> <span class="number">8</span>         System.out.println(<span class="string">"target="</span>+target);</span><br><span class="line"> <span class="number">9</span>         <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="number">10</span>         <span class="keyword">int</span> n = a.length;</span><br><span class="line"><span class="number">11</span>         HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="number">12</span>         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="number">13</span>             map.put(a[i], i); <span class="comment">//以数组value为key，index为map值</span></span><br><span class="line"><span class="number">14</span>         &#125;</span><br><span class="line"><span class="number">15</span>         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;<span class="comment">//i不会超过n-2</span></span><br><span class="line"><span class="number">16</span>             <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">//j从i+1开始统计，不会超过n-1</span></span><br><span class="line"><span class="number">17</span>                 <span class="keyword">int</span> smallValue = a[i] + a[j]; <span class="comment">//因为排好序了，所以最开始的a[i]+a[j]</span></span><br><span class="line"><span class="number">18</span>                 <span class="keyword">if</span> (smallValue &gt; target) <span class="comment">//当a[i]+a[j]&gt;target时没必要计算了，因为后续的查找就会重复</span></span><br><span class="line"><span class="number">19</span>                     <span class="keyword">break</span>;</span><br><span class="line"><span class="number">20</span>                 <span class="keyword">int</span> bigValue = target-smallValue; <span class="comment">//计算出对应的数值较大的value</span></span><br><span class="line"><span class="number">21</span>                 Integer bigIndex = map.get(bigValue); <span class="comment">//查找数值较大的value所在的位置</span></span><br><span class="line"><span class="number">22</span>                 <span class="keyword">if</span> (bigIndex != <span class="keyword">null</span> &amp;&amp; bigIndex &gt; i &amp;&amp; bigIndex &gt; j) &#123;</span><br><span class="line"><span class="number">23</span>                     System.out.println(</span><br><span class="line"><span class="number">24</span>                             <span class="string">"["</span> + i + <span class="string">"]="</span> + a[i] + <span class="string">",["</span> + j + <span class="string">"]"</span> + a[j] + <span class="string">",["</span> + bigIndex + <span class="string">"]"</span> + (bigValue));</span><br><span class="line"><span class="number">25</span>                     cnt++;</span><br><span class="line"><span class="number">26</span>                 &#125;</span><br><span class="line"><span class="number">27</span>             &#125;</span><br><span class="line"><span class="number">28</span>         &#125;</span><br><span class="line"><span class="number">29</span>         <span class="keyword">return</span> cnt;</span><br><span class="line"><span class="number">30</span>     &#125;</span><br><span class="line"><span class="number">31</span> </span><br><span class="line"><span class="number">32</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">33</span>         <span class="keyword">int</span>[] a = &#123; <span class="number">30</span>, -<span class="number">40</span>, -<span class="number">20</span>, -<span class="number">10</span>, <span class="number">40</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">5</span> &#125;;        </span><br><span class="line"><span class="number">34</span>         System.out.println(count(a,<span class="number">0</span>));</span><br><span class="line"><span class="number">35</span>     &#125;</span><br><span class="line"><span class="number">36</span> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡塔兰数</title>
      <link href="/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0.html"/>
      <url>/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<h3 id="卡塔兰数"><a href="#卡塔兰数" class="headerlink" title="卡塔兰数"></a>卡塔兰数</h3><p>卡塔兰数是一种常在技术问题中出现的数列，一般做到类似以下模型的时候套用公式即可：<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/57de4926a69e67cdcdf999030c5ec3c25d97b0c9" alt=""></p><a id="more"></a><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><a href="https://zh.wikipedia.org/wiki/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6" rel="external nofollow noopener noreferrer" target="_blank">组合数学</a>中有非常多的组合结构可以用卡塔兰数来计数。在Richard P. Stanley的Enumerative Combinatorics: Volume 2一书的习题中包括了66个相异的可由卡塔兰数表达的组合结构。以下用n=3和n=4举若干例：</p><ul><li><em>C**n</em>表示长度<em>2n</em>的dyck word的个数。Dyck word是一个有<em>n</em>个X和<em>n</em>个Y组成的字串，且所有的前缀字串皆满足X的个数大于等于Y的个数。以下为长度为6的dyck words:</li></ul><p>XXXYYY XYXXYY XYXYXY XXYYXY XXYXYY</p><ul><li>将上例的X换成左括号，Y换成右括号，<em>C**n</em>表示所有包含<em>n</em>组括号的合法运算式的个数：</li></ul><p>((())) ()(()) ()()() (())() (()())</p><ul><li><p><em>C**n</em>表示有<em>n</em>个节点组成不同构<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" rel="external nofollow noopener noreferrer" target="_blank">二叉树</a>的方案数。下图中，<em>n</em>等于<em>3</em>，圆形表示节点，月牙形表示什么都没有。</p></li><li><p><em>C**n</em>表示有<em>2n+1</em>个节点组成不同构满<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" rel="external nofollow noopener noreferrer" target="_blank">二叉树</a>（full binary tree）的方案数。下图中，<em>n</em>等于<em>3</em>，圆形表示内部节点，月牙形表示外部节点。本质同上。</p></li></ul><p><a href="https://zh.wikipedia.org/wiki/File:Catalan_number_binary_tree_example.png" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://upload.wikimedia.org/wikipedia/commons/0/01/Catalan_number_binary_tree_example.png" alt="Catalan number binary tree example.png"></a></p><p><em>证明：</em></p><p>令1表示进栈，0表示出栈，则可转化为求一个<em>2n</em>位、含<em>n</em>个1、<em>n</em>个0的二进制数，满足从左往右扫描到任意一位时，经过的0数不多于1数。显然含<em>n</em>个1、<em>n</em>个0的<em>2n</em>位二进制数共有{\displaystyle {2n \choose n}}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/368fc291485cdb1e3fa50b38ff3b6e565a3d7d31" alt="{2n \choose n}">个，下面考虑不满足要求的数目。</p><p>考虑一个含<em>n</em>个1、<em>n</em>个0的2n位二进制数，扫描到第<em>2m+1</em>位上时有<em>m+1</em>个0和<em>m</em>个1（容易证明一定存在这样的情况），则后面的0-1排列中必有<em>n-m</em>个1和<em>n-m-1</em>个0。将<em>2m+2</em>及其以后的部分0变成1、1变成0，则对应一个<em>n+1</em>个0和<em>n-1</em>个1的二进制数。反之亦然（相似的思路证明两者一一对应）。</p><p>从而{\displaystyle C_{n}={2n \choose n}-{2n \choose n+1}={\frac {1}{n+1}}{2n \choose n}}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b407b1e2725b1fc3e8ddf194f04e5d08a4ae7563" alt="C_n = {2n \choose n} - {2n \choose n + 1} = \frac{1}{n+1}{2n \choose n}">。证毕。</p><ul><li><em>C**n</em>表示所有在<em>n</em> × <em>n</em>格点中不越过对角线的<strong>单调路径</strong>的个数。一个单调路径从格点左下角出发，在格点右上角结束，每一步均为向上或向右。计算这种路径的个数等价于计算Dyck word的个数：X代表“向右”，Y代表“向上”。下图为<em>n</em> = 4的情况：</li></ul><p><a href="https://zh.wikipedia.org/wiki/File:Catalan_number_4x4_grid_example.svg" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Catalan_number_4x4_grid_example.svg/450px-Catalan_number_4x4_grid_example.svg.png" alt="Catalan number 4x4 grid example.svg"></a></p><ul><li><em>C**n</em>表示通过连结顶点而将<em>n</em> + 2边的<a href="https://zh.wikipedia.org/wiki/%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2" rel="external nofollow noopener noreferrer" target="_blank">凸多边形</a>分成<a href="https://zh.wikipedia.org/w/index.php?title=%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%88%E5%87%A0%E4%BD%95%EF%BC%89&amp;action=edit&amp;redlink=1" rel="external nofollow noopener noreferrer" target="_blank">三角形</a>的方法个数。下图中为<em>n</em> = 4的情况：</li></ul><p><a href="https://zh.wikipedia.org/wiki/File:Catalan-Hexagons-example.svg" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/Catalan-Hexagons-example.svg/400px-Catalan-Hexagons-example.svg.png" alt="Catalan-Hexagons-example.svg"></a></p><ul><li><p><em>C**n</em>表示对{1, …, <em>n</em>}依序进出<a href="https://zh.wikipedia.org/wiki/%E6%A0%88" rel="external nofollow noopener noreferrer" target="_blank">栈</a>的<a href="https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%8D%A2" rel="external nofollow noopener noreferrer" target="_blank">置换</a>个数。一个置换<em>w</em>是依序进出栈的当<em>S</em>(<em>w</em>) = (1, …, <em>n</em>),其中<em>S</em>（<em>w</em>）递归定义如下：令<em>w</em> = <em>unv</em>，其中<em>n</em>为<em>w</em>的最大元素，<em>u</em>和<em>v</em>为更短的数列；再令<em>S</em>(<em>w</em>) = <em>S</em>(<em>u</em>)<em>S</em>(<em>v</em>)<em>n</em>，其中<em>S</em>为所有含一个元素的数列的单位元。</p></li><li><p><em>C**n</em>表示集合{1, …, <em>n</em>}的<a href="https://zh.wikipedia.org/w/index.php?title=%E4%B8%8D%E4%BA%A4%E5%8F%89%E5%88%92%E5%88%86&amp;action=edit&amp;redlink=1" rel="external nofollow noopener noreferrer" target="_blank">不交叉划分</a>的个数.那么, <em>C**n</em>永远不大于第<em>n</em>项<a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%95%B0" rel="external nofollow noopener noreferrer" target="_blank">贝尔数</a>. <em>C**n</em>也表示集合{1, …, 2<em>n</em>}的<a href="https://zh.wikipedia.org/w/index.php?title=%E4%B8%8D%E4%BA%A4%E5%8F%89%E5%88%92%E5%88%86&amp;action=edit&amp;redlink=1" rel="external nofollow noopener noreferrer" target="_blank">不交叉划分</a>的个数，其中每个段落的长度为2。综合这两个结论，可以用<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95" rel="external nofollow noopener noreferrer" target="_blank">数学归纳法</a>证明：在 <a href="https://zh.wikipedia.org/w/index.php?title=%E9%AD%8F%E6%A0%BC%E7%BA%B3%E5%8D%8A%E5%9C%86%E5%88%86%E5%B8%83%E5%AE%9A%E5%BE%8B&amp;action=edit&amp;redlink=1" rel="external nofollow noopener noreferrer" target="_blank">魏格纳半圆分布定律</a> 中度数大于2的情形下，所有 <em>自由的</em> <a href="https://zh.wikipedia.org/wiki/%E7%B4%AF%E7%A7%AF%E9%87%8F" rel="external nofollow noopener noreferrer" target="_blank">累积量</a>s 为零。 该定律在 <a href="https://zh.wikipedia.org/w/index.php?title=%E8%87%AA%E7%94%B1%E6%A6%82%E7%8E%87%E8%AE%BA&amp;action=edit&amp;redlink=1" rel="external nofollow noopener noreferrer" target="_blank">自由概率论</a> 和 <a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E7%9F%A9%E9%98%B5" rel="external nofollow noopener noreferrer" target="_blank">随机矩阵</a> 理论中非常重要。</p></li><li><p><em>C**n</em>表示用<em>n</em>个长方形填充一个高度为<em>n</em>的阶梯状图形的方法个数。下图为<em>n</em> = 4的情况：</p></li></ul><p><a href="https://zh.wikipedia.org/wiki/File:Catalan_stairsteps_4.svg" rel="external nofollow noopener noreferrer" target="_blank"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/63/Catalan_stairsteps_4.svg/400px-Catalan_stairsteps_4.svg.png" alt="Catalan stairsteps 4.svg"></a></p><ul><li><p><em>C**n</em>表示表为2×<em>n</em>的矩阵的标准<a href="https://zh.wikipedia.org/wiki/%E6%9D%A8%E6%B0%8F%E7%9F%A9%E9%98%B5" rel="external nofollow noopener noreferrer" target="_blank">杨氏矩阵</a>的数量。 也就是说，它是数字 1, 2, …, 2<em>n</em> 被放置在一个2×<em>n</em>的矩形中并保证每行每列的数字升序排列的方案数。同样的，该式可由<a href="https://zh.wikipedia.org/wiki/%E6%9D%A8%E6%B0%8F%E7%9F%A9%E9%98%B5" rel="external nofollow noopener noreferrer" target="_blank">勾长公式</a>的一个特殊情形推导得出。</p></li><li><p><em>C**n</em>表示<em>n</em>个无标号物品的<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8D%8A%E5%BA%8F&amp;action=edit&amp;redlink=1" rel="external nofollow noopener noreferrer" target="_blank">半序</a>的个数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分图最大匹配与匈牙利算法</title>
      <link href="/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95.html"/>
      <url>/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<p>推荐阅读：<a href="https://www.renfei.org/blog/bipartite-matching.html" rel="external nofollow noopener noreferrer" target="_blank">二分图的最大匹配、完美匹配和匈牙利算法</a></p><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图<strong>最大匹配</strong>的算法。</p><a id="more"></a><p>——-等等，看得头大？那么请看下面的版本：</p><p>通过数代人的努力，你终于赶上了剩男剩女的大潮，假设你是一位光荣的新世纪媒人，在你的手上有N个剩男，M个剩女，每个人都可能对多名异性有好感（-_-||暂时不考虑特殊的性取向），如果一对男女互有好感，那么你就可以把这一对撮合在一起，现在让我们无视掉所有的单相思（好忧伤的感觉），你拥有的大概就是下面这样一张关系图，每一条连线都表示互有好感。</p><p><img src="https://img-blog.csdn.net/20130503155150538" alt=""></p><p>本着救人一命，胜造七级浮屠的原则，你想要尽可能地撮合更多的情侣，匈牙利算法的工作模式会教你这样做：</p><p>===============================================================================</p><p>一： 先试着给1号男生找妹子，发现第一个和他相连的1号女生还名花无主，got it，连上一条蓝线</p><p><img src="https://img-blog.csdn.net/20130503155256629" alt=""></p><p>===============================================================================</p><p>二：接着给2号男生找妹子，发现第一个和他相连的2号女生名花无主，got it</p><p><img src="https://img-blog.csdn.net/20130503155344972" alt=""></p><p>===============================================================================</p><p>三：接下来是3号男生，很遗憾1号女生已经有主了，怎么办呢？</p><p>我们试着给之前1号女生匹配的男生（也就是1号男生）另外分配一个妹子。</p><p>(黄色表示这条边被临时拆掉)</p><p><img src="https://img-blog.csdn.net/20130503155428908" alt=""></p><p>与1号男生相连的第二个女生是2号女生，但是2号女生也有主了，怎么办呢？我们再试着给2号女生的原配()重新找个妹子(注意这个步骤和上面是一样的，这是一个递归的过程)</p><p><img src="https://img-blog.csdn.net/20130503155441032" alt=""></p><p>此时发现2号男生还能找到3号女生，那么之前的问题迎刃而解了，回溯回去</p><p>2号男生可以找3号妹子~              1号男生可以找2号妹子了~        3号男生可以找1号妹子</p><p><img src="https://img-blog.csdn.net/20130503155453501" alt=""><img src="https://img-blog.csdn.net/20130503155626560" alt=""><img src="https://img-blog.csdn.net/20130503162147840" alt=""></p><p>所以第三步最后的结果就是：</p><p><img src="https://img-blog.csdn.net/20130503160156253" alt=""></p><p>===============================================================================</p><p>四： 接下来是4号男生，很遗憾，按照第三步的节奏我们没法给4号男生腾出来一个妹子，我们实在是无能为力了……香吉士同学走好。</p><p>===============================================================================</p><p>这就是匈牙利算法的流程，其中找妹子是个递归的过程，最最关键的字就是“腾”字<br>其原则大概是：有机会上，没机会创造机会也要上</p><p>【code】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=m;j++)&#123;    <span class="comment">//扫描每个妹子</span></span><br><span class="line"><span class="keyword">if</span> (line[x][j]==<span class="literal">true</span> &amp;&amp; used[j]==<span class="literal">false</span>)      </span><br><span class="line"><span class="comment">//如果有暧昧并且还没有标记过(这里标记的意思是这次查找曾试图改变过该妹子的归属问题，但是没有成功，所以就不用瞎费工夫了）</span></span><br><span class="line">&#123;</span><br><span class="line">used[j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (girl[j]==<span class="number">0</span> || find(girl[j])) &#123; </span><br><span class="line"><span class="comment">//名花无主或者能腾出个位置来，这里使用递归</span></span><br><span class="line">girl[j]=x;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主程序我们这样做：每一步相当于我们上面描述的一二三四中的一步</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(used,<span class="number">0</span>,<span class="keyword">sizeof</span>(used));    <span class="comment">//这个在每一步中清空</span></span><br><span class="line">if find(i) all+=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分图的最大匹配、完美匹配和匈牙利算法"><a href="#二分图的最大匹配、完美匹配和匈牙利算法" class="headerlink" title="二分图的最大匹配、完美匹配和匈牙利算法"></a>二分图的最大匹配、完美匹配和匈牙利算法</h3><p>这篇文章讲无权二分图（unweighted bipartite graph）的最大匹配（maximum matching）和完美匹配（perfect matching），以及用于求解匹配的匈牙利算法（Hungarian Algorithm）；不讲带权二分图的最佳匹配。</p><p><strong>二分图</strong>：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 $U$ 和$V$ ，使得每一条边都分别连接$U$、$V$中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。</p><p><strong>匹配</strong>：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。</p><p><img src="https://img.renfei.org/2013/08/1.png" alt="Bipartite Graph(1)">  <img src="https://img.renfei.org/2013/08/2.png" alt="Bipartite Graph(2)">  <img src="https://img.renfei.org/2013/08/3.png" alt="Matching">  <img src="https://img.renfei.org/2013/08/4.png" alt="Maximum Matching"></p><p>我们定义<strong>匹配点</strong>、<strong>匹配边</strong>、<strong>未匹配点</strong>、<strong>非匹配边</strong>，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。</p><p><strong>最大匹配</strong>：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。</p><p><strong>完美匹配</strong>：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。</p><p>举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是<strong>完美匹配</strong>问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是<strong>最大匹配</strong>问题。</p><p><img src="https://img.renfei.org/2013/08/0.png" alt="0"></p><p>基本概念讲完了。求解最大匹配问题的一个算法是<strong>匈牙利算法</strong>，下面讲的概念都为这个算法服务。</p><p><img src="https://img.renfei.org/2013/08/5.png" alt="5"></p><p><strong>交替路</strong>：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p><p><strong>增广路</strong>：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：</p><p><img src="https://img.renfei.org/2013/08/6.png" alt="6"></p><p>增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是<strong>改进匹配</strong>。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。</p><p>我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。</p><p><strong>匈牙利树</strong>一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树：</p><p><img src="https://img.renfei.org/2013/08/7.png" alt="7">   <img src="https://img.renfei.org/2013/08/8.png" alt="8">    <img src="https://img.renfei.org/2013/08/9.png" alt="9"></p><p>这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。</p><p>下面给出<strong>匈牙利算法</strong>的 DFS 和 BFS 版本的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点、边的编号均从 0 开始</span></span><br><span class="line"><span class="comment">// 邻接表储存</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    Edge(<span class="keyword">int</span> f, <span class="keyword">int</span> t, <span class="keyword">int</span> w):from(f), to(t), weight(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[__maxNodes]; <span class="comment">/* G[i] 存储顶点 i 出发的边的编号 */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator <span class="keyword">iterator_t</span>;</span><br><span class="line"><span class="keyword">int</span> num_nodes;</span><br><span class="line"><span class="keyword">int</span> num_left;</span><br><span class="line"><span class="keyword">int</span> num_right;</span><br><span class="line"><span class="keyword">int</span> num_edges;</span><br><span class="line"><span class="keyword">int</span> matching[__maxNodes]; <span class="comment">/* 存储求解结果 */</span></span><br><span class="line"><span class="keyword">int</span> check[__maxNodes];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">iterator_t</span> i = G[u].begin(); i != G[u].end(); ++i) &#123; <span class="comment">// 对 u 的每个邻接点</span></span><br><span class="line">        <span class="keyword">int</span> v = edges[*i].to;</span><br><span class="line">        <span class="keyword">if</span> (!check[v]) &#123;     <span class="comment">// 要求不在交替路中</span></span><br><span class="line">            check[v] = <span class="literal">true</span>; <span class="comment">// 放入交替路</span></span><br><span class="line">            <span class="keyword">if</span> (matching[v] == <span class="number">-1</span> || dfs(matching[v])) &#123;</span><br><span class="line">                <span class="comment">// 如果是未盖点，说明交替路为增广路，则交换路径，并返回成功</span></span><br><span class="line">                matching[v] = u;</span><br><span class="line">                matching[u] = v;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不存在增广路，返回失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(matching, <span class="number">-1</span>, <span class="keyword">sizeof</span>(matching));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u=<span class="number">0</span>; u &lt; num_left; ++u) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matching[u] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(check, <span class="number">0</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line">            <span class="keyword">if</span> (dfs(u))</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> prev[__maxNodes];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hungarian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(matching, <span class="number">-1</span>, <span class="keyword">sizeof</span>(matching));</span><br><span class="line">    <span class="built_in">memset</span>(check, <span class="number">-1</span>, <span class="keyword">sizeof</span>(check));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num_left; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matching[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Q.empty()) Q.pop();</span><br><span class="line">            Q.push(i);</span><br><span class="line">            prev[i] = <span class="number">-1</span>; <span class="comment">// 设 i 为路径起点</span></span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 尚未找到增广路</span></span><br><span class="line">            <span class="keyword">while</span> (!Q.empty() &amp;&amp; !flag) &#123;</span><br><span class="line">                <span class="keyword">int</span> u = Q.front();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">iterator_t</span> ix = G[u].begin(); ix != G[u].end() &amp;&amp; !flag; ++ix) &#123;</span><br><span class="line">                    <span class="keyword">int</span> v = edges[*ix].to;</span><br><span class="line">                    <span class="keyword">if</span> (check[v] != i) &#123;</span><br><span class="line">                        check[v] = i;</span><br><span class="line">                        Q.push(matching[v]);</span><br><span class="line">                        <span class="keyword">if</span> (matching[v] &gt;= <span class="number">0</span>) &#123; <span class="comment">// 此点为匹配点</span></span><br><span class="line">                            prev[matching[v]] = u;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到未匹配点，交替路变为增广路</span></span><br><span class="line">                            flag = <span class="literal">true</span>;</span><br><span class="line">                            <span class="keyword">int</span> d=u, e=v;</span><br><span class="line">                            <span class="keyword">while</span> (d != <span class="number">-1</span>) &#123;</span><br><span class="line">                                <span class="keyword">int</span> t = matching[d];</span><br><span class="line">                                matching[d] = e;</span><br><span class="line">                                matching[e] = d;</span><br><span class="line">                                d = prev[d];</span><br><span class="line">                                e = t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matching[i] != <span class="number">-1</span>) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>匈牙利算法的要点如下</strong></p><ol><li>从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。<ol><li>如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。</li><li>如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。</li></ol></li><li>由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 <code>prev</code> 数组。</li></ol><p><strong>性能比较</strong></p><p>两个版本的时间复杂度均为$O\big(V \cdot E\big)$。DFS 的优点是思路清晰、代码量少，但是性能不如 BFS。我测试了两种算法的性能。对于稀疏图，BFS 版本明显快于 DFS 版本；而对于稠密图两者则不相上下。在完全随机数据 9000 个顶点 4,0000 条边时前者领先后者大约 97.6%，9000 个顶点 100,0000 条边时前者领先后者 8.6%, 而达到 500,0000 条边时 BFS 仅领先 0.85%。</p><p>补充定义和定理：</p><p><strong>最大匹配数</strong>：最大匹配的匹配边的数目</p><p><strong>最小点覆盖数</strong>：选取最少的点，使任意一条边至少有一个端点被选择</p><p><strong>最大独立数</strong>：选取最多的点，使任意所选两点均不相连</p><p><strong>最小路径覆盖数</strong>：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。</p><p>定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理）</p><p>定理2：最大匹配数 = 最大独立数</p><p>定理3：最小路径覆盖数 = 顶点数 - 最大匹配数</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijkstra-最短路径算法</title>
      <link href="/Dijkstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html"/>
      <url>/Dijkstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<p>推荐阅读，转自:<a href="http://ahalei.blog.51cto.com/4767671/1387799" rel="external nofollow noopener noreferrer" target="_blank">【啊哈！算法】系列7：Dijkstra最短路算法</a></p><p>上周我们介绍了神奇的只有五行的Floyd最短路算法，它可以方便的求得任意两点的最短路径，这称为“多源最短路”。本周来来介绍指定一个点（源点）到其余各个顶点的最短路径，也叫做“单源最短路径”。例如求下图中的1号顶点到2、3、4、5、6号顶点的最短路径。</p><p><img src="http://bbs.ahalei.com/data/attachment/forum/201403/31/090644t797fce7n20of7j9.png" alt="090644t797fce7n20of7j9.png"></p><a id="more"></a><p>​       与Floyd-Warshall算法一样这里仍然使用二维数组e来存储顶点之间边的关系，初始值如下。</p><p><img src="http://bbs.ahalei.com/data/attachment/forum/201403/31/090651l6pt4666tptut66u.png" alt="090651l6pt4666tptut66u.png"></p><p>​       我们还需要用一个一维数组dis来存储1号顶点到其余各个顶点的初始路程，如下。</p><p><img src="http://bbs.ahalei.com/data/attachment/forum/201403/31/090657ofidcactthcig33i.png" alt="090657ofidcactthcig33i.png"></p><p>​       我们将此时dis数组中的值称为最短路的“估计值”。</p><p>​       既然是求1号顶点到其余各个顶点的最短路程，那就先找一个离1号顶点最近的顶点。通过数组dis可知当前离1号顶点最近是2号顶点。当选择了2号顶点后，dis[2]的值就已经从“估计值”变为了“确定值”，即1号顶点到2号顶点的最短路程就是当前dis[2]值。为什么呢？你想啊，目前离1号顶点最近的是2号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得1号顶点到2号顶点的路程进一步缩短了。因为1号顶点到其它顶点的路程肯定没有1号到2号顶点短，对吧O(∩_∩)O~</p><p>​       既然选了2号顶点，接下来再来看2号顶点有哪些出边呢。有2-&gt;3和2-&gt;4这两条边。先讨论通过2-&gt;3这条边能否让1号顶点到3号顶点的路程变短。也就是说现在来比较dis[3]和dis[2]+e[2] [3]的大小。其中dis[3]表示1号顶点到3号顶点的路程。dis[2]+e[2] [3]中dis[2]表示1号顶点到2号顶点的路程，e[2] [3]表示2-&gt;3这条边。所以dis[2]+e[2] [3]就表示从1号顶点先到2号顶点，再通过2-&gt;3这条边，到达3号顶点的路程。</p><p>​       我们发现dis[3]=12，dis[2]+e[2] [3]=1+9=10，dis[3]&gt;dis[2]+e[2] [3]，因此dis[3]要更新为10。这个过程有个专业术语叫做“松弛”。即1号顶点到3号顶点的路程即dis[3]，通过2-&gt;3这条边松弛成功。这便是Dijkstra算法的主要思想：通过“边”来松弛1号顶点到其余各个顶点的路程。</p><p>​       同理通过2-&gt;4（e[2] [4]），可以将dis[4]的值从∞松弛为4（dis[4]初始为∞，dis[2]+e[2] [4]=1+3=4，dis[4]&gt;dis[2]+e[2] [4]，因此dis[4]要更新为4）。</p><p>​       刚才我们对2号顶点所有的出边进行了松弛。松弛完毕之后dis数组为：</p><p><img src="http://bbs.ahalei.com/data/attachment/forum/201403/31/090706vmjy7l2ee2lyalia.png" alt="090706vmjy7l2ee2lyalia.png"></p><p>​       接下来，继续在剩下的3、4、5和6号顶点中，选出离1号顶点最近的顶点。通过上面更新过dis数组，当前离1号顶点最近是4号顶点。此时，dis[4]的值已经从“估计值”变为了“确定值”。下面继续对4号顶点的所有出边（4-&gt;3，4-&gt;5和4-&gt;6）用刚才的方法进行松弛。松弛完毕之后dis数组为：</p><p><img src="http://bbs.ahalei.com/data/attachment/forum/201403/31/090714f2p1wppynngj2pep.png" alt="090714f2p1wppynngj2pep.png"></p><p>​       继续在剩下的3、5和6号顶点中，选出离1号顶点最近的顶点，这次选择3号顶点。此时，dis[3]的值已经从“估计值”变为了“确定值”。对3号顶点的所有出边（3-&gt;5）进行松弛。松弛完毕之后dis数组为：</p><p><img src="http://bbs.ahalei.com/data/attachment/forum/201403/31/090722ywunackk35i8cni5.png" alt="090722ywunackk35i8cni5.png"></p><p>​       继续在剩下的5和6号顶点中，选出离1号顶点最近的顶点，这次选择5号顶点。此时，dis[5]的值已经从“估计值”变为了“确定值”。对5号顶点的所有出边（5-&gt;4）进行松弛。松弛完毕之后dis数组为：</p><p><img src="http://bbs.ahalei.com/data/attachment/forum/201403/31/090730eq6oqzyq7laqha9y.png" alt="090730eq6oqzyq7laqha9y.png"></p><p>​       最后对6号顶点所有点出边进行松弛。因为这个例子中6号顶点没有出边，因此不用处理。到此，dis数组中所有的值都已经从“估计值”变为了“确定值”。</p><p>​       最终dis数组如下，这便是1号顶点到其余各个顶点的最短路径。</p><p><img src="http://bbs.ahalei.com/data/attachment/forum/201403/31/090738azt5clcozl899ekt.png" alt="090738azt5clcozl899ekt.png"></p><p>​       OK，现在来总结一下刚才的算法。算法的基本思想是：每次找到离源点（上面例子的源点就是1号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下：</p><ul><li>将所有的顶点分为两部分：已知最短路程的顶点集合P和未知最短路径的顶点集合Q。最开始，已知最短路径的顶点集合P中只有源点一个顶点。我们这里用一个book[ i ]数组来记录哪些点在集合P中。例如对于某个顶点i，如果book[ i ]为1则表示这个顶点在集合P中，如果book[ i ]为0则表示这个顶点在集合Q中。</li><li>设置源点s到自己的最短路径为0即dis=0。若存在源点有能直接到达的顶点i，则把dis[ i ]设为e[s] [ i ]。同时把所有其它（源点不能直接到达的）顶点的最短路径为设为∞。</li><li>在集合Q的所有顶点中选择一个离源点s最近的顶点u（即dis[u]最小）加入到集合P。并考察所有以点u为起点的边，对每一条边进行松弛操作。例如存在一条从u到v的边，那么可以通过将边u-&gt;v添加到尾部来拓展一条从s到v的路径，这条路径的长度是dis[u]+e[u] [v]。如果这个值比目前已知的dis[v]的值要小，我们可以用新值来替代当前dis[v]中的值。</li><li>重复第3步，如果集合Q为空，算法结束。最终dis数组中的值就是源点到所有顶点的最短路径。</li></ul><p>​       完整的Dijkstra算法代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e[<span class="number">10</span>][<span class="number">10</span>],dis[<span class="number">10</span>],book[<span class="number">10</span>],i,j,n,m,t1,t2,t3,u,v,min;</span><br><span class="line">    <span class="keyword">int</span> inf=<span class="number">99999999</span>; <span class="comment">//用inf(infinity的缩写)存储一个我们认为的正无穷值</span></span><br><span class="line">    <span class="comment">//读入n和m，n表示顶点个数，m表示边的条数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">                                                                  </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(i==j) e[i][j]=<span class="number">0</span>;</span><br><span class="line">              <span class="keyword">else</span> e[i][j]=inf;</span><br><span class="line">                                                                            </span><br><span class="line">    <span class="comment">//读入边</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">        e[t1][t2]=t3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化dis数组，这里是1号顶点到其余各个顶点的初始路程</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        dis[i]=e[<span class="number">1</span>][i];</span><br><span class="line">    <span class="comment">//book数组初始化</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        book[i]=<span class="number">0</span>;</span><br><span class="line">    book[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                                                                  </span><br><span class="line">    <span class="comment">//Dijkstra算法核心语句</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//找到离1号顶点最近的顶点</span></span><br><span class="line">        min=inf;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(book[j]==<span class="number">0</span> &amp;&amp; dis[j]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                min=dis[j];</span><br><span class="line">                u=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        book[u]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(v=<span class="number">1</span>;v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[u][v]&lt;inf)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[v]&gt;dis[u]+e[u][v])</span><br><span class="line">                    dis[v]=dis[u]+e[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">                                                                  </span><br><span class="line">    <span class="comment">//输出最终的结果</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,dis[i]);</span><br><span class="line">                                                                      </span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       可以输入以下数据进行验证。第一行两个整数n  m。n表示顶点个数（顶点编号为1~n），m表示边的条数。接下来m行表示，每行有3个数x y z。表示顶点x到顶点y边的权值为z。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">12</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">9</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">13</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">15</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>​       运行结果是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">8</span> <span class="number">4</span> <span class="number">13</span> <span class="number">17</span></span><br></pre></td></tr></table></figure><p>   通过上面的代码我们可以看出，这个算法的时间复杂度是O(N2)。其中每次找到离1号顶点最近的顶点的时间复杂度是O(N)，这里我们可以用“堆”（以后再说）来优化，使得这一部分的时间复杂度降低到O(logN)。另外对于边数M少于N2的稀疏图来说（我们把M远小于N2的图称为稀疏图，而M相对较大的图称为稠密图），我们可以用邻接表（这是个神马东西？不要着急，下周再仔细讲解）来代替邻接矩阵，使得整个时间复杂度优化到O( (M+N)logN )。请注意！在最坏的情况下M就是N2，这样的话MlogN要比N2还要大。但是大多数情况下并不会有那么多边，因此(M+N)logN要比N2小很多。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html"/>
      <url>/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p><a id="more"></a><p>贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停。</p><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p><p><strong>一句话：不求最优，仅仅求可行解。</strong></p><h2 id="选择使用贪心算法"><a href="#选择使用贪心算法" class="headerlink" title="选择使用贪心算法"></a>选择使用贪心算法</h2><p>　我们能够依据贪心法的2个重要的性质去证明：<strong>贪心选择性质和最优子结构性质</strong>。</p><h3 id="1、贪心选择"><a href="#1、贪心选择" class="headerlink" title="1、贪心选择"></a>1、贪心选择</h3><p>　　什么叫贪心选择？从字义上就是贪心也就是目光短线。贪图眼前利益。在算法中就是仅仅依据当前已有的信息就做出选择，并且以后都不会改变这次选择。（这是和动态规划法的主要差别）　　</p><p>　　所以对于一个详细问题。要确定它是否具有贪心选择性质，必须证明每做一步贪心选择是否终于导致问题的总体最优解。</p><h3 id="2、最优子结构"><a href="#2、最优子结构" class="headerlink" title="2、最优子结构"></a>2、最优子结构</h3><p>　　当一个问题的最优解包括其子问题的最优解时，称此问题具有最优子结构性质。</p><p>​       运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。动态规划主要运用于二维或三维问题，而贪心一般是一维问题</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>贪心算法的基本思路是从问题的某一个初始解触发一步一步地进行，根据抹个优化测度，每一步都要确保能获得局部最优解，每一步值考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连载一起不再是可行解时，就不把改数据添加到部分解中，知道把所有数据枚举玩，或者不能在添加算法停止。</p><p><strong>过程</strong></p><ol><li>建立数学模型来描述问题；</li><li>把求解的问题分成若干个子问题；</li><li>对每一子问题求解，得到子问题的局部最优解；</li><li>把子问题的解局部最优解合成原来解问题的一个解。</li></ol><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><ol><li>随着算法的进行，将积累起其它两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象。</li><li>有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优。</li><li>还有一个函数检查是否一个候选对象的集合是可行的，也即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性。</li><li>选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解。</li><li>最后，目标函数给出解的值。</li><li>为了解决问题，需要寻找一个构成解的候选对象集合，它可以优化目标函数，贪婪算法一步一步的进行。起初，算法选出的候选对象的集合为空。接下来的每一步中，根据选择函数，算法从剩余候选对象中选出最有希望构成解的对象。如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑；否则就加到集合里。每一次都扩充集合，并检查该集合是否构成解。如果贪婪算法正确工作，那么找到的第一个解通常是最优的。</li></ol><h2 id="一般求解过程"><a href="#一般求解过程" class="headerlink" title="一般求解过程"></a>一般求解过程</h2><p>　　使用贪心法求解能够依据下面几个方面进行（终于也相应着每步代码的实现），以找零钱为例：</p><h3 id="1、候选集合-C"><a href="#1、候选集合-C" class="headerlink" title="　　1、候选集合(C)"></a>　　1、候选集合(C)</h3><p>　　　　通过一个候选集合C作为问题的可能解。（终于解均取自于候选集合C）</p><p>　　　　比如。在找零钱问题中，各种面值的货币构成候选集合。</p><h3 id="2、解集合-S"><a href="#2、解集合-S" class="headerlink" title="　　2、解集合(S)"></a>　　2、解集合(S)</h3><p>　　　　每完毕一次贪心选择，将一个解放入S。终于获得一个完整解S</p><h3 id="3、解决函数-solution"><a href="#3、解决函数-solution" class="headerlink" title="　　3、解决函数(solution)"></a>　　3、解决函数(solution)</h3><p>　　　　检查解集合S是否构成问题的完整解。</p><p>　　　　比如，在找零钱问题中。解决函数是已付出的货币金额恰好等于应付款。</p><h3 id="4、选择函数-select"><a href="#4、选择函数-select" class="headerlink" title="　　4、选择函数(select)"></a>　　4、选择函数(select)</h3><p>　　　　即贪心策略。这是贪心法的关键，选择出最有希望构成问题的解的对象。</p><p>（这个选择函数通常和目标函数有关）</p><p>　　 比如，在找零钱问题中，贪心策略就是在候选集合中选择面值最大的货币。</p><h3 id="5、可行函数-feasible"><a href="#5、可行函数-feasible" class="headerlink" title="　　5、可行函数(feasible)"></a>　　5、可行函数(feasible)</h3><p>　　　　检查解集合中增加一个候选对象是否可行。（增加下一个对象后是不是满足约束条件）</p><p>　　　　比如。在找零钱问题中，可行函数是每一步选择的货币和已付出的货币相加不超过应付款。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="1-活动选择问题"><a href="#1-活动选择问题" class="headerlink" title="1.活动选择问题"></a>1.活动选择问题</h3><p>有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi 。一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天。该问题就是要安排这些活动使得尽量多的活动能不冲突的举行。<img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;602&quot; height=&quot;159&quot;&gt;&lt;/svg" alt="img"></p><p>问题分析：<br>活动安排问题要求安排一系列争用某一公共资源的活动。用贪心算法可提供一个简单、漂亮的方法，使尽可能多的活动能兼容的使用公共资源。设有n个活动的集合｛0，1，2，…，n-1｝，其中每个活动都要求使用同一资源，如会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间starti和一个结束时间endi，且starti&lt;endi。如选择了活动i，则它在半开时间区间[starti,endi）内占用资源。若区间[starti,endi)与区间[startj,endj)不相交，称活动i与活动j是相容的。也就是说，当startj≥endi或starti≥endj时，活动i与活动j相容。活动安排问题就是在所给的活动集合中选出最多的不相容活动。<br>活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。该问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。</p><p>算法设计：<br>若被检查的活动i的开始时间starti小于最近选择的活动j的结束时间endj，则不选择活动i，否则选择活动i加入集合中。运用该算法解决活动安排问题的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;   </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;      </span><br><span class="line"><span class="keyword">int</span> N;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Act</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> start;  </span><br><span class="line">    <span class="keyword">int</span> end;  </span><br><span class="line">&#125;act[<span class="number">100010</span>];  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Act a,Act b)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">return</span> a.end&lt;b.end;    </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">greedy_activity_selector</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">1</span>,i=<span class="number">1</span>;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=N;j++)    </span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="keyword">if</span>(act[j].start&gt;=act[i].end)    </span><br><span class="line">        &#123;    </span><br><span class="line">            i=j;    </span><br><span class="line">            num++;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> num;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> t;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);  </span><br><span class="line">    <span class="keyword">while</span>(t--)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;act[i].start,&amp;act[i].end);  </span><br><span class="line">        &#125;  </span><br><span class="line">        act[<span class="number">0</span>].start=<span class="number">-1</span>;  </span><br><span class="line">        act[<span class="number">0</span>].end=<span class="number">-1</span>;  </span><br><span class="line">        sort(act+<span class="number">1</span>,act+N+<span class="number">1</span>,cmp);   </span><br><span class="line">        <span class="keyword">int</span> res=greedy_activity_selector();  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-钱币找零问题"><a href="#2-钱币找零问题" class="headerlink" title="2.钱币找零问题"></a>2.钱币找零问题</h3><p>这个问题在我们的日常生活中就更加普遍了。假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将Value按照从小到大的顺序排好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">7</span>; </span><br><span class="line"><span class="keyword">int</span> Count[N]=&#123;<span class="number">3</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Value[N]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> money)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=N<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> c=min(money/Value[i],Count[i]);</span><br><span class="line">money=money-c*Value[i];</span><br><span class="line">num+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(money&gt;<span class="number">0</span>) num=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> money;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;money;</span><br><span class="line"><span class="keyword">int</span> res=solve(money);</span><br><span class="line"><span class="keyword">if</span>(res!=<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-背包问题"><a href="#3-背包问题" class="headerlink" title="3.背包问题"></a>3.背包问题</h3><p>有一个背包，背包容量是M=150kg。有7个物品，物品不可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。<img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;459&quot; height=&quot;114&quot;&gt;&lt;/svg" alt="img"></p><p>问题分析<br>目标函数： ∑pi最大，使得装入背包中的所有物品pi的价值加起来最大。</p><p>约束条件：装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)</p><p>贪心策略：</p><p>⑴根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？</p><p>⑵每次挑选所占重量最小的物品装入是否能得到最优解？</p><p>⑶每次选取单位重量价值最大的物品，成为解本题的策略。</p><p><strong>⑴贪心策略：选取价值最大者。</strong></p><p>W=30</p><p>物品：A B C</p><p>重量：28 12 12</p><p>价值：30 20 20</p><p>根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。</p><p><strong>⑵贪心策略：选取重量最小。</strong>它的反例与第一种策略的反例差不多。</p><p><strong>⑶贪心策略：选取单位重量价值最大的物品。</strong></p><p>反例：</p><p>W=30</p><p>物品：A B C</p><p>重量：28 20 10</p><p>价值：28 20 10</p><p>根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。</p><p>【注意：如果物品可以分割为任意大小，那么策略3可得最优解】</p><p>对于选取单位重量价值最大的物品这个策略，可以再加一条优化的规则：对于单位重量价值一样的，则优先选择重量小的！这样，上面的反例就解决了。</p><p>但是，如果题目是如下所示，这个策略就也不行了。</p><p>W=40</p><p>物品：A B C</p><p>重量：25 20 15</p><p>价值：25 20 15</p><ul><li>算法设计：</li></ul><ol><li>计算出每个物品单位重量的价值</li><li>按单位价值从大到小将物品排序</li><li>根据背包当前所剩容量选取物品</li><li>如果背包的容量大于当前物品的重量，那么就将当前物品装进去。否则，那么就将当前物品舍去，然后跳出循环结束。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">double</span> avg;</span><br><span class="line">&#125;P;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(P a,P b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.avg&gt;b.avg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    P *p;</span><br><span class="line">    <span class="keyword">int</span> n,i,m;<span class="comment">//n 物品个数 m背包容量</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)&#123;</span><br><span class="line">        p=<span class="keyword">new</span> P[n];</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;p[i].w&gt;&gt;p[i].v;</span><br><span class="line">            p[i].avg=p[i].v/p[i].w*<span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(p,p+n,cmp);</span><br><span class="line">        <span class="keyword">int</span> maxvalue=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i].w&lt;=m)&#123;</span><br><span class="line">                m-=p[i].w;</span><br><span class="line">                maxvalue+=p[i].v;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;maxvalue&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2000-2099 入门笔记</title>
      <link href="/HDU%202000-2099%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.html"/>
      <url>/HDU%202000-2099%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<p>都说HDU 2000-2099 是acm入门必刷题，为了备战蓝桥杯，巩固知识，我做了一些小笔记与总结。<br><!-- ![](https://i1.hoopchina.com.cn/hupuapp/bbs/180153855732716/thread_180153855732716_20181109165433_s_24245_w_456_h_256_98723.jpg?x-oss-process=image/resize,w_800/format,webp) --><br><a id="more"></a></p><h3 id="HDU-1002-A-B-Problem-two-大数问题"><a href="#HDU-1002-A-B-Problem-two-大数问题" class="headerlink" title="HDU 1002 A+B Problem two(大数问题)"></a>HDU 1002 A+B Problem two(大数问题)</h3><p>大数问题，通用的方法是使用string进行ascii码的加减</p><ul><li>两个数字的ascii码相加减去 <code>0</code> 就是对应数字的ascii码</li><li>如果相加的数大于10,相加的ascii码减去<code>10</code>就是个位数</li></ul><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">sum</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="string">""</span> &amp;&amp; s2 == <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    <span class="keyword">if</span> (s2 == <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> max, min;</span><br><span class="line">    <span class="keyword">int</span> lens1 = s1.length();</span><br><span class="line">    <span class="keyword">int</span> lens2 = s2.length();</span><br><span class="line">    <span class="keyword">if</span> (lens1 &lt; lens2)</span><br><span class="line">    &#123;</span><br><span class="line">        max = s2;</span><br><span class="line">        min = s1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        max = s1;</span><br><span class="line">        min = s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxlen = max.length();</span><br><span class="line">    <span class="keyword">int</span> minlen = min.length();</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = maxlen - <span class="number">1</span>, j = minlen - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--, i--)</span><br><span class="line">    &#123;</span><br><span class="line">        max[i] = max[i] + min[i] - <span class="string">'0'</span>; <span class="comment">//相加的ascii码-0就是对应数组的ascii码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxlen - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max[i] &gt; <span class="string">'9'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            max[i] = max[i] - <span class="number">10</span>; <span class="comment">//相加的ascii码-10就是个位数</span></span><br><span class="line">            max[i - <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (max[<span class="number">0</span>] &gt; <span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        max[<span class="number">0</span>] -= <span class="number">10</span>;</span><br><span class="line">        max = <span class="string">"1"</span> + max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s1, s2;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span> &lt;&lt; i &lt;&lt; <span class="string">":"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="string">" + "</span> &lt;&lt; s2 &lt;&lt; <span class="string">" = "</span> &lt;&lt; sum(s1, s2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; count)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        num--;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-2018-母牛的故事-递推"><a href="#HDU-2018-母牛的故事-递推" class="headerlink" title="HDU 2018 母牛的故事(递推)"></a>HDU 2018 母牛的故事(递推)</h3><p>相似：<strong>HDU 2044~2050,HDU2041</strong></p><p><strong>Description</strong><br>　　有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？<br><strong>Input</strong><br>　　输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt; n&lt; 55)，n的含义如题目中描述。<br>　　n=0表示输入数据的结束，不做处理。<br><strong>Output</strong><br>　　对于每个测试实例，输出在第n年的时候母牛的数量。<br>　　每个输出占一行。</p><p><strong>分析</strong>:<br>​    以n=6为例，fn=9头牛可以分解为6+3，其中6是上一年（第5年）的牛，3是新生的牛（因为第3年有3头牛，这3头在第6年各生一头牛）。<br>　　我们可以得出这样一个公式：fn=fn-1+fn-3<br>　　再理解一下，fn-1是前一年的牛，第n年仍然在，fn-3是前三年那一年的牛，但换句话说也就是第n年具有生育能力的牛，也就是第n年能生下的小牛数。</p><p><strong>代码:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;f(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> n; <span class="comment">//第1，2，3年，各为1，2，3头</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> f(n<span class="number">-1</span>)+f(n<span class="number">-3</span>);  <span class="comment">//第n年为前一年的和前3年的相加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-2031-进制转换-模拟"><a href="#HDU-2031-进制转换-模拟" class="headerlink" title="HDU 2031 进制转换(模拟):"></a>HDU 2031 进制转换(模拟):</h3><p><strong>Problem Description</strong></p><p>输入一个十进制数N，将它转换成R进制数输出。</p><p><strong>Input</strong></p><p>输入数据包含多个测试实例，每个测试实例包含两个整数N(32位整数)和R（2&lt;=R&lt;=16, R&lt;&gt;10）。 </p><p><strong>Output</strong></p><p>为每个测试实例输出转换后的数，每个输出占一行。如果R大于10，则对应的数字规则参考16进制（比如，10用A表示，等等）。</p><p><strong>分析:</strong></p><p> 进制转换,也就是取余,以7的二进制表示:</p><ol><li>7%2=1…7/2=3</li><li>3%2=1…3/2=1</li><li>1%2=1…1/2=0</li></ol><p>取余的数字拼接为111,直到商为0为止,即是7的二进制表示</p><p><strong>代码:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,r,i,x,flag;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;r)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n=-n;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n)</span><br><span class="line">        &#123;</span><br><span class="line">            a[x]=n%r;</span><br><span class="line">            n/=r;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (x--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[x]&lt;<span class="number">10</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[x]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%c"</span>,<span class="number">55</span>+a[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-2048-神、上帝以及老天爷-错排问题"><a href="#HDU-2048-神、上帝以及老天爷-错排问题" class="headerlink" title="HDU 2048 神、上帝以及老天爷(错排问题)"></a>HDU 2048 神、上帝以及老天爷(错排问题)</h3><p>相似：<strong>HDU 2049</strong></p><p><strong>Description</strong></p><p>HDU 2006’10 ACM contest的颁奖晚会隆重开始了！<br>为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的：</p><p>首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；<br>然后，待所有字条加入完毕，每人从箱中取一个字条；<br>最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”</p><p>大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！</p><p>我的神、上帝以及老天爷呀，怎么会这样呢？</p><p>不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？</p><p>不会算？难道你也想以悲剧结尾？！</p><p><strong>Input</strong></p><p>输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数n(1 &lt; n &lt; =20),表示参加抽奖的人数。</p><p><strong>Output</strong></p><p>对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。</p><p><strong>分析:</strong></p><p>典型的错排问题,具体思路如下:</p><p>当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推. </p><ol><li>把第n个元素放在一个位置，比如位置k，一共有n-1种方法； </li><li>放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法；<br> 综上得到 D(n) = (n-1) [D(n-2) + D(n-1)]<br> 特殊地，D(1) = 0, D(2) = 1.</li></ol><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> i,j,num;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> D[<span class="number">22</span>],F[<span class="number">22</span>];</span><br><span class="line">    D[<span class="number">1</span>]=<span class="number">0</span>;D[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;<span class="number">21</span>;i++)</span><br><span class="line">        D[i]=(i<span class="number">-1</span>)*(D[i<span class="number">-1</span>]+D[i<span class="number">-2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">20</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">        F[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;<span class="number">1</span>;j--)</span><br><span class="line">            F[i]*=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">    <span class="keyword">while</span>(num--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.2lf%%\n"</span>,D[n]*<span class="number">100.0</span>/F[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-2053-Switch-Game-开灯问题-唯一分解定理"><a href="#HDU-2053-Switch-Game-开灯问题-唯一分解定理" class="headerlink" title="HDU 2053 Switch Game(开灯问题,唯一分解定理)"></a>HDU 2053 Switch Game(开灯问题,唯一分解定理)</h3><p><strong>Problem Description</strong></p><p>There are many lamps in a line. All of them are off at first. A series of operations are carried out on these lamps. On the i-th operation, the lamps whose numbers are the multiple of i change the condition ( on to off and off to on ).</p><p><strong>Input</strong></p><p>Each test case contains only a number n ( 0&lt; n&lt;= 10^5) in a line.</p><p><strong>Output</strong></p><p>Output the condition of the n-th lamp after infinity operations ( 0 - off, 1 - on ).</p><p><strong>分析：</strong></p><p>36的约数是 (1,36), (2,18), (3,12), (4,9), (6)，任何一个数都是由两个不同的数相乘得到的，但是如果一个数为平方数，那么这两个数就可以相等，例如36由两个6相乘得到，所以要判断灯的状态，只需要判断这个数是不是平方数即可</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x=<span class="built_in">sqrt</span>(n*<span class="number">1.0</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(x==<span class="keyword">int</span>(x))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-2057-A-B-Again-16进制数相加"><a href="#HDU-2057-A-B-Again-16进制数相加" class="headerlink" title="HDU 2057 A + B Again (16进制数相加)"></a>HDU 2057 A + B Again (16进制数相加)</h3><p><strong>Problem Description</strong></p><p>There must be many A + B problems in our HDOJ , now a new one is coming.<br>Give you two hexadecimal integers , your task is to calculate the sum of them,and print it in hexadecimal too.<br>Easy ? AC it !</p><p><strong>Input</strong></p><p>The input contains several test cases, please process to the end of the file.<br>Each case consists of two hexadecimal integers A and B in a line seperated by a blank.<br>The length of A and B is less than 15.</p><p><strong>Output</strong></p><p>For each test case,print the sum of A and B in hexadecimal in one line.</p><p><strong>分析：</strong></p><p>涉及到16进制内的加法，可以用%I64x直接来处理，要<strong>注意到16进制中负数是用补码来表示的</strong>。一个比较困惑的事实是，这道题再输出时，%64X中‘X’必须是大写，小写是过不了的。</p><p><strong>注意</strong>：__int64 %I64X ,输出用大写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cstdio"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int64 a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%I64X%I64X"</span>,&amp;a,&amp;b))</span><br><span class="line">    &#123;</span><br><span class="line">        c=a+b;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%I64X\n"</span>,c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-%I64X\n"</span>,-c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-2062-Subset-sequence（子序列）"><a href="#HDU-2062-Subset-sequence（子序列）" class="headerlink" title="HDU 2062 Subset sequence（子序列）"></a>HDU 2062 Subset sequence（子序列）</h3><p><strong>Problem Description</strong></p><p>Consider the aggregate An= { 1, 2, …, n }. For example, A1={1}, A3={1,2,3}. A subset sequence is defined as a array of a non-empty subset. Sort all the subset sequece of An in lexicography order. Your task is to find the m-th one.</p><p><strong>Input</strong></p><p>The input contains several test cases. Each test case consists of two numbers n and m ( 0&lt; n&lt;= 20, 0&lt; m&lt;= the total number of the subset sequence of An ).</p><p><strong>Output</strong></p><p>For each test case, you should output the m-th subset sequence of An in one line.</p><p><strong>分析：</strong></p><p>当n=2的时候</p><p>子序列从小到大</p><p>{1},</p><p>{1, 2},</p><p>{2},</p><p>{2, 1}</p><p>当n=3的时候</p><p>子序列从小到大</p><p>{1}</p><p>{1, 2}</p><p>{1, 2, 3}</p><p>{1, 3}</p><p>{1, 3, 2}</p><p>{2}<br>{2, 1}<br>{2, 1, 3}<br>{2, 3}<br>{2, 3, 1}</p><p>{3}<br>{3, 1}<br>{3, 1, 2}<br>{3, 2}<br>{3, 2, 1}</p><p>不难发现，An可以按首数字分成n组，而每组里除了第一项，剩下的就是An-1的子集合了。</p><p>∴f(n) = n[f(n-1) + 1]</p><p>f(1) = 1</p><p>我们拿测试数据3 10来做个示范，解释一下怎么求解。</p><p>因为n=3，所以开始数组里1、2、3三个数。</p><p>我们知道，n=2时，有4种排列，所以上面n=3可以分成三组，每组5个(加上空集)。</p><p>//空集就是说去掉该组第一个数字后为空集</p><p>因此第10个在第二组里。所以第一个是2，把2输出。原来的数组里删除2，变成1、3两个数。然后10 - (2 - 1) * 5 =5，即它在第2组的第5个。</p><p>//请自行推导所在位置</p><p>减去首个空集合，5 - 1 = 4 ≠ 0，表示2后面还有数字。</p><p>因为A1 = 1是，所以再第2组里又可以分成两组，每组2个(加上空集)。</p><p>所以，4在第2组，剩下的数组中，第二个元素是3，所以输出3。再把数组里的3删除，剩下1一个数。</p><p>然后4 - (2 - 1) * 2 = 2，既它是第2组的第2个。</p><p>减去首个空集，2 - 1 = 1 ≠ 0，表示2后面还有数字。</p><p>按上面的方法继续下去，直到n = 0 或 后面为空集为止。</p><p>最后输出数组里的第1个元素，就得到2 3 1，就是解了。从上面的计算可以看出来，本题目的关键是先求的An中每一组的个数g(n)</p><p>不难得出:g(n) = f(n) / n</p><p>∵f(n) = n[f(n-1) + 1]</p><p>∴g(n) = n[f(n-1) + 1] / n = f(n-1) + 1</p><p>∵f(n-1) = (n-1) * g(n-1)</p><p>∴g(n) = (n-1) * g(n-1) + 1</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    __int64 b;</span><br><span class="line">    __int64 g[<span class="number">30</span>];</span><br><span class="line">    g[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    g[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;<span class="number">22</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i]=g[i<span class="number">-1</span>]*(i<span class="number">-1</span>)+<span class="number">1</span>;<span class="comment">//求出g；</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">30</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%I64d"</span>,&amp;a,&amp;b)!=EOF)  <span class="comment">//b的数可能很大，所以用I64d，，用int运行错了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));<span class="comment">//清零</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a;i++)</span><br><span class="line">            num[i]=i;        <span class="comment">//将要输出的数字保存在数组里</span></span><br><span class="line">        <span class="keyword">int</span> am=a;</span><br><span class="line">        <span class="keyword">while</span>(a--)<span class="comment">//总共有a个数（1---a）最多可能输出a个</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n=b%g[a+<span class="number">1</span>]? b/g[a+<span class="number">1</span>]+<span class="number">1</span>: b/g[a+<span class="number">1</span>];       <span class="comment">//我们用b取余对应的g，，得到要输出的数在第几组</span></span><br><span class="line">            <span class="keyword">if</span>(num[n]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(am<span class="number">-1</span>==a)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,num[n]);       /  /输出对应的组代表的数字</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>,num[n]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;=a;i++)</span><br><span class="line">                num[i]=num[i+<span class="number">1</span>];            <span class="comment">//将刚输出的数字删掉，，留下剩下的数字，，没用的数字都变成0了</span></span><br><span class="line">            b=(b-g[a+<span class="number">1</span>]*(n<span class="number">-1</span>)<span class="number">-1</span>);   <span class="comment">//把问题缩小到下一组，，， 求出在下一组的位置；循环；直到要输出的num为0，说明所有的数都输完了；</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-2064-汉诺塔Ⅲ（递归）"><a href="#HDU-2064-汉诺塔Ⅲ（递归）" class="headerlink" title="HDU 2064 汉诺塔Ⅲ（递归）"></a>HDU 2064 汉诺塔Ⅲ（递归）</h3><p><strong>Problem Description</strong></p><p>约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。<br>现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。<br>Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？</p><p><strong>Input</strong></p><p>包含多组数据，每次输入一个N值(1&lt;=N=35)。</p><p><strong>Output</strong></p><p>对于每组数据，输出移动最小的次数。</p><p><strong>分析：</strong></p><p>建议阅读 <a href="https://www.zhihu.com/question/24385418" rel="external nofollow noopener noreferrer" target="_blank">如何理解汉诺塔的递归？ - 知乎</a></p><p>其实本题的复杂之处就是相当与比以往的汉诺塔多移动了一次柱子，原来<img src="https://www.zhihu.com/equation?tex=a_4%3Da_3%2B1%2Ba_3" alt="a_4=a_3+1+a_3">，现在a4=a3+a3+a3+2(移动最大的圆盘要两次)，理解了便能很快求解</p><h3 id="…HDU-2059-Seraph2012-DP"><a href="#…HDU-2059-Seraph2012-DP" class="headerlink" title="…HDU 2059  Seraph2012 (DP)"></a>…HDU 2059  Seraph2012 (DP)</h3><h3 id="HDU-2037-今年暑假不AC（贪心）"><a href="#HDU-2037-今年暑假不AC（贪心）" class="headerlink" title="HDU 2037 今年暑假不AC（贪心）"></a>HDU 2037 今年暑假不AC（贪心）</h3><p>推荐：<a href="https://juejin.im/post/5aea722e6fb9a07ac652dbc8" rel="external nofollow noopener noreferrer" target="_blank">贪心算法</a></p><p><strong>Problem Description</strong><br>“今年暑假不AC？”<br>“是的。”<br>“那你干什么呢？”<br>“看世界杯呀，笨蛋！”<br>“@#$%^&amp;*%…”</p><p>确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。<br>作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）<br><strong>Input</strong><br>输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。<br><strong>Output</strong><br>对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。</p><p><strong>分析：</strong>最简单的贪心算法，因为一个节目对应一个开始时间和一个结束时间，所以，将这两个时间放到一个结构体中，然后对结束时间按照从小到大的顺序进行排序，如果结束的时间相同的话，就将开始的时间按照从大到小的顺序排序，然后开始比较，如果开始的时间比前一个结束的时间迟，就k++，最终k的值即为所求！</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Program</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start,end;</span><br><span class="line">&#125;pro[<span class="number">10001</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,sum,final;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    Program temp;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) &amp;&amp; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;pro[i].start,&amp;pro[i].end);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)</span><br><span class="line">            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;n;++j)</span><br><span class="line">                <span class="keyword">if</span>(pro[i].end&gt;pro[j].end)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp=pro[i];</span><br><span class="line">                    pro[i]=pro[j];</span><br><span class="line">                    pro[j]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">        sum=<span class="number">1</span>;</span><br><span class="line">        final=pro[<span class="number">0</span>].end;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(final&lt;=pro[i].start)</span><br><span class="line">            &#123;</span><br><span class="line">                ++sum;</span><br><span class="line">                final=pro[i].end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-2063-过山车-（二分图的最大匹配、完美匹配和匈牙利算法）"><a href="#HDU-2063-过山车-（二分图的最大匹配、完美匹配和匈牙利算法）" class="headerlink" title="HDU 2063 过山车 （二分图的最大匹配、完美匹配和匈牙利算法）"></a>HDU 2063 过山车 （二分图的最大匹配、完美匹配和匈牙利算法）</h3><p><strong>Problem Description</strong></p><p>RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p><p><strong>Input</strong></p><p>输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=1000<br>1&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。</p><p><strong>Output</strong></p><p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p><p><strong>分析：</strong></p><p><a href="https://www.renfei.org/blog/bipartite-matching.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.renfei.org/blog/bipartite-matching.html</a></p><p><a href="https://blog.csdn.net/dark_scope/article/details/8880547" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/dark_scope/article/details/8880547</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> ok[maxn];</span><br><span class="line"><span class="comment">//ok[x]=y;//第x个男生和第y个女生做partner</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//男生</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[x][i]&amp;&amp;!vis[i])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i]=<span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//该男生没有被组合||该女生可以找其他人组合</span></span><br><span class="line">            <span class="keyword">if</span>(!ok[i]||Find(ok[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                ok[i]=x;<span class="comment">//第i个男生和第x个女生做partner</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;k,k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="literal">false</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(ok,<span class="number">0</span>,<span class="keyword">sizeof</span>(ok));</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">while</span>(k--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            a[x][y]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) <span class="comment">//女生</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span>(Find(i))</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-2066-一个人的旅行（最短路，多起点多终点，Dijkstra算法-spfa算法）"><a href="#HDU-2066-一个人的旅行（最短路，多起点多终点，Dijkstra算法-spfa算法）" class="headerlink" title="HDU 2066 一个人的旅行（最短路，多起点多终点，Dijkstra算法+spfa算法）"></a>HDU 2066 一个人的旅行（最短路，多起点多终点，Dijkstra算法+spfa算法）</h3><p><strong>Problem Description</strong><br>虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。</p><p><strong>Input</strong><br>输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；<br>接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路)<br>接着的第T+1行有S个数，表示和草儿家相连的城市；<br>接着的第T+2行有D个数，表示草儿想去地方。</p><p><strong>Output</strong></p><p>输出草儿能去某个喜欢的城市的最短时间。</p><p><strong>分析：</strong></p><p><a href="http://blog.51cto.com/ahalei/1387799" rel="external nofollow noopener noreferrer" target="_blank">http://blog.51cto.com/ahalei/1387799</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dij</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i]=a[<span class="number">0</span>][i];</span><br><span class="line">        vis[i]=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minn=INF;</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;dis[j]&lt;minn)</span><br><span class="line">            &#123;</span><br><span class="line">                minn=dis[p=j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[p]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(minn==INF) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;dis[j]&gt;dis[p]+a[p][j])</span><br><span class="line">                dis[j]=dis[p]+a[p][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,s,d;</span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;t,&amp;s,&amp;d)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        n=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(a,INF,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="keyword">while</span>(t--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            <span class="keyword">if</span>(z&lt;a[x][y])</span><br><span class="line">                a[x][y]=a[y][x]=z;</span><br><span class="line">            n=max(n,max(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            a[<span class="number">0</span>][x]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Dij();</span><br><span class="line">        <span class="keyword">int</span> minn=INF;</span><br><span class="line">        <span class="keyword">while</span>(d--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            minn=min(minn,dis[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,minn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU-2067-小兔的棋盘（卡塔兰数）"><a href="#HDU-2067-小兔的棋盘（卡塔兰数）" class="headerlink" title="HDU 2067 小兔的棋盘（卡塔兰数）"></a>HDU 2067 小兔的棋盘（卡塔兰数）</h3><p><strong>Problem Description</strong></p><p>小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。不过没过几天发现了棋盘的好玩之处。从起点(0，0)走到终点(n,n)的最短路径数是C(2n,n),现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧!</p><p><strong>Input</strong></p><p>每次输入一个数n(1&lt;=n&lt;=35)，当n等于－1时结束输入。</p><p><strong>Output</strong></p><p>对于每个输入数据输出路径数，具体格式看Sample。</p><p><strong>分析：</strong></p><p><a href="https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0" rel="external nofollow noopener noreferrer" target="_blank">https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0</a></p><p>遇到类似题型带公式即可</p><p>卡特兰数又称卡塔兰数，英文名Catalan number，是<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=305948" rel="external nofollow noopener noreferrer" target="_blank">组合数学</a>中一个常出现在各种计数问题中出现的<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=411910" rel="external nofollow noopener noreferrer" target="_blank">数列</a>。由以<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=43034" rel="external nofollow noopener noreferrer" target="_blank">比利时</a>的数学家欧仁·查理·卡塔兰 (1814–1894)命名，其前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, …</p><p>令h(0)=1,h(1)=1，catalan数满足<a href="http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=10854267&amp;ss_c=ssc.citiao.link" rel="external nofollow noopener noreferrer" target="_blank">递推式</a><a href="http://baike.sogou.com/v9693847.htm#quote1" rel="external nofollow noopener noreferrer" target="_blank">[1]</a>：</p><p>h(n)= h(0)<em>h(n-1)+h(1)</em>h(n-2) + … + h(n-1)h(0) (n&gt;=2)</p><p>例如：h(2)=h(0)<em>h(1)+h(1)</em>h(0)=1<em>1+1</em>1=2</p><p>h(3)=h(0)<em>h(2)+h(1)</em>h(1)+h(2)<em>h(0)=1</em>2+1<em>1+2</em>1=5</p><p>另类递推式<a href="http://baike.sogou.com/v9693847.htm#quote2" rel="external nofollow noopener noreferrer" target="_blank">[2]</a>：</p><p>h(n)=h(n-1)<em>(4</em>n-2)/(n+1);</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   __int64 a[<span class="number">36</span>];</span><br><span class="line">   a[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">35</span>;i++)</span><br><span class="line">   a[i]=a[i<span class="number">-1</span>]*<span class="number">1.0</span>/(i+<span class="number">1</span>)*(<span class="number">4</span>*i<span class="number">-2</span>);</span><br><span class="line"><span class="comment">//先除再乘，防止溢出。注意要乘1.0.。。。</span></span><br><span class="line">   <span class="keyword">int</span> n,flag=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)&amp;&amp;n&gt;<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d %d %I64d\n"</span>,++flag,n,<span class="number">2</span>*a[n]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HDU2069-Coin-Change-DP-背包"><a href="#HDU2069-Coin-Change-DP-背包" class="headerlink" title="HDU2069 Coin Change(DP 背包)"></a>HDU2069 Coin Change(DP 背包)</h3><p><strong>Problem Description</strong></p><p>Suppose there are 5 types of coins: 50-cent, 25-cent, 10-cent, 5-cent, and 1-cent. We want to make changes with these coins for a given amount of money.</p><p>For example, if we have 11 cents, then we can make changes with one 10-cent coin and one 1-cent coin, or two 5-cent coins and one 1-cent coin, or one 5-cent coin and six 1-cent coins, or eleven 1-cent coins. So there are four ways of making changes for 11 cents with the above coins. Note that we count that there is one way of making change for zero cent.</p><p>Write a program to find the total number of different ways of making changes for any amount of money in cents. Your program should be able to handle up to 100 coins.</p><p><strong>Input</strong></p><p>The input file contains any number of lines, each one consisting of a number ( ≤250 ) for the amount of money in cents.</p><p><strong>Output</strong></p><p>For each input line, output a line containing the number of different ways of making changes with the above 5 types of coins.</p><p><strong>分析：</strong></p><p>动态规划问题，同时也是01背包问题，需要写出状态转换方程然后求解</p><p><a href="https://blog.csdn.net/wzy_1988/article/details/12260343" rel="external nofollow noopener noreferrer" target="_blank">https://blog.csdn.net/wzy_1988/article/details/12260343</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>,<span class="number">50</span>&#125;;</span><br><span class="line">LL dp[<span class="number">255</span>][<span class="number">101</span>];<span class="comment">//dp[j][k]:用k个硬币组成j值的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;res[n]&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">100</span>;k++)&#123;<span class="comment">//k个硬币</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=a[i];j&lt;=n;j++)&#123;</span><br><span class="line">                    dp[j][k]+=dp[j-a[i]][k<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            res+=dp[n][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小技巧："><a href="#小技巧：" class="headerlink" title="小技巧："></a>小技巧：</h3><h5 id="输出控制："><a href="#输出控制：" class="headerlink" title="输出控制："></a>输出控制：</h5><p>c++中用cout输出，要求保留两位小数，比如，输出100，则为100.00</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(<span class="number">2</span>)&lt;&lt;<span class="number">456.777</span>&lt;&lt;<span class="built_in">endl</span></span><br></pre></td></tr></table></figure><h5 id="标准开头："><a href="#标准开头：" class="headerlink" title="标准开头："></a>标准开头：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;r)!=EOF)</span><br></pre></td></tr></table></figure><h5 id="16进制数相加："><a href="#16进制数相加：" class="headerlink" title="16进制数相加："></a>16进制数相加：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%I64X%I64X"</span>,&amp;a,&amp;b)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" rel="external nofollow noopener noreferrer" target="_blank">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" rel="external nofollow noopener noreferrer" target="_blank">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" rel="external nofollow noopener noreferrer" target="_blank">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" rel="external nofollow noopener noreferrer" target="_blank">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" rel="external nofollow noopener noreferrer" target="_blank">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" rel="external nofollow noopener noreferrer" target="_blank">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> tests </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
