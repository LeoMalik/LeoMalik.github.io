<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[贪心算法贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 一句话：不求最优，仅仅求可行解。 选择使用贪心算法 我们能够依据贪心法的2个重要的性质去证明：贪心选择性质和最优子结构性质。 1、贪心选择 什么叫贪心选择？从字义上就是贪心也就是目光短线。贪图眼前利益。在算法中就是仅仅依据当前已有的信息就做出选择，并且以后都不会改变这次选择。（这是和动态规划法的主要差别） 所以对于一个详细问题。要确定它是否具有贪心选择性质，必须证明每做一步贪心选择是否终于导致问题的总体最优解。 2、最优子结构 当一个问题的最优解包括其子问题的最优解时，称此问题具有最优子结构性质。 ​ 运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。动态规划主要运用于二维或三维问题，而贪心一般是一维问题 基本思路贪心算法的基本思路是从问题的某一个初始解触发一步一步地进行，根据抹个优化测度，每一步都要确保能获得局部最优解，每一步值考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连载一起不再是可行解时，就不把改数据添加到部分解中，知道把所有数据枚举玩，或者不能在添加算法停止。 过程 建立数学模型来描述问题； 把求解的问题分成若干个子问题； 对每一子问题求解，得到子问题的局部最优解； 把子问题的解局部最优解合成原来解问题的一个解。 算法特性 随着算法的进行，将积累起其它两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象。 有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优。 还有一个函数检查是否一个候选对象的集合是可行的，也即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性。 选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解。 最后，目标函数给出解的值。 为了解决问题，需要寻找一个构成解的候选对象集合，它可以优化目标函数，贪婪算法一步一步的进行。起初，算法选出的候选对象的集合为空。接下来的每一步中，根据选择函数，算法从剩余候选对象中选出最有希望构成解的对象。如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑；否则就加到集合里。每一次都扩充集合，并检查该集合是否构成解。如果贪婪算法正确工作，那么找到的第一个解通常是最优的。 一般求解过程 使用贪心法求解能够依据下面几个方面进行（终于也相应着每步代码的实现），以找零钱为例： 1、候选集合(C) 通过一个候选集合C作为问题的可能解。（终于解均取自于候选集合C） 比如。在找零钱问题中，各种面值的货币构成候选集合。 2、解集合(S) 每完毕一次贪心选择，将一个解放入S。终于获得一个完整解S 3、解决函数(solution) 检查解集合S是否构成问题的完整解。 比如，在找零钱问题中。解决函数是已付出的货币金额恰好等于应付款。 4、选择函数(select) 即贪心策略。这是贪心法的关键，选择出最有希望构成问题的解的对象。 （这个选择函数通常和目标函数有关） 比如，在找零钱问题中，贪心策略就是在候选集合中选择面值最大的货币。 5、可行函数(feasible) 检查解集合中增加一个候选对象是否可行。（增加下一个对象后是不是满足约束条件） 比如。在找零钱问题中，可行函数是每一步选择的货币和已付出的货币相加不超过应付款。 例子1.活动选择问题有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi 。一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天。该问题就是要安排这些活动使得尽量多的活动能不冲突的举行。 问题分析：活动安排问题要求安排一系列争用某一公共资源的活动。用贪心算法可提供一个简单、漂亮的方法，使尽可能多的活动能兼容的使用公共资源。设有n个活动的集合｛0，1，2，…，n-1｝，其中每个活动都要求使用同一资源，如会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间starti和一个结束时间endi，且starti&lt;endi。如选择了活动i，则它在半开时间区间[starti,endi）内占用资源。若区间[starti,endi)与区间[startj,endj)不相交，称活动i与活动j是相容的。也就是说，当startj≥endi或starti≥endj时，活动i与活动j相容。活动安排问题就是在所给的活动集合中选出最多的不相容活动。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。该问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。 算法设计：若被检查的活动i的开始时间starti小于最近选择的活动j的结束时间endj，则不选择活动i，否则选择活动i加入集合中。运用该算法解决活动安排问题的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int N; struct Act &#123; int start; int end; &#125;act[100010]; bool cmp(Act a,Act b) &#123; return a.end&lt;b.end; &#125; int greedy_activity_selector() &#123; int num=1,i=1; for(int j=2;j&lt;=N;j++) &#123; if(act[j].start&gt;=act[i].end) &#123; i=j; num++; &#125; &#125; return num; &#125; int main() &#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf("%lld %lld",&amp;act[i].start,&amp;act[i].end); &#125; act[0].start=-1; act[0].end=-1; sort(act+1,act+N+1,cmp); int res=greedy_activity_selector(); cout&lt;&lt;res&lt;&lt;endl; &#125; &#125; 2.钱币找零问题这个问题在我们的日常生活中就更加普遍了。假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将Value按照从小到大的顺序排好。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=7; int Count[N]=&#123;3,0,2,1,0,3,5&#125;;int Value[N]=&#123;1,2,5,10,20,50,100&#125;; int solve(int money) &#123; int num=0; for(int i=N-1;i&gt;=0;i--) &#123; int c=min(money/Value[i],Count[i]); money=money-c*Value[i]; num+=c; &#125; if(money&gt;0) num=-1; return num;&#125; int main() &#123; int money; cin&gt;&gt;money; int res=solve(money); if(res!=-1) cout&lt;&lt;res&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl;&#125; 3.背包问题有一个背包，背包容量是M=150kg。有7个物品，物品不可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。 问题分析目标函数： ∑pi最大，使得装入背包中的所有物品pi的价值加起来最大。 约束条件：装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150) 贪心策略： ⑴根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？ ⑵每次挑选所占重量最小的物品装入是否能得到最优解？ ⑶每次选取单位重量价值最大的物品，成为解本题的策略。 ⑴贪心策略：选取价值最大者。 W=30 物品：A B C 重量：28 12 12 价值：30 20 20 根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。 ⑵贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。 ⑶贪心策略：选取单位重量价值最大的物品。 反例： W=30 物品：A B C 重量：28 20 10 价值：28 20 10 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。 【注意：如果物品可以分割为任意大小，那么策略3可得最优解】 对于选取单位重量价值最大的物品这个策略，可以再加一条优化的规则：对于单位重量价值一样的，则优先选择重量小的！这样，上面的反例就解决了。 但是，如果题目是如下所示，这个策略就也不行了。 W=40 物品：A B C 重量：25 20 15 价值：25 20 15 算法设计： 计算出每个物品单位重量的价值 按单位价值从大到小将物品排序 根据背包当前所剩容量选取物品 如果背包的容量大于当前物品的重量，那么就将当前物品装进去。否则，那么就将当前物品舍去，然后跳出循环结束。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef struct&#123; int w; int v; double avg;&#125;P;bool cmp(P a,P b)&#123; return a.avg&gt;b.avg;&#125;int main()&#123; P *p; int n,i,m;//n 物品个数 m背包容量 while(cin&gt;&gt;n&gt;&gt;m)&#123; p=new P[n]; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;p[i].w&gt;&gt;p[i].v; p[i].avg=p[i].v/p[i].w*1.0; &#125; sort(p,p+n,cmp); int maxvalue=0; for(i=0;i&lt;n;i++)&#123; if(p[i].w&lt;=m)&#123; m-=p[i].w; maxvalue+=p[i].v; &#125;else&#123; break; &#125; &#125; cout&lt;&lt;maxvalue&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2000-2099 入门笔记]]></title>
    <url>%2FHDU%202000-2099%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[都说HDU 2000-2099 是acm入门必刷题，为了备战蓝桥杯，巩固知识，我做了一些小笔记与总结。 HDU 1002 A+B Problem two(大数问题)大数问题，通用的方法是使用string进行ascii码的加减 两个数字的ascii码相加减去 0 就是对应数字的ascii码 如果相加的数大于10,相加的ascii码减去10就是个位数 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string sum(string &amp;s1, string &amp;s2)&#123; if (s1 == "" &amp;&amp; s2 == "") return "0"; if (s1 == "") return s2; if (s2 == "") return s1; string max, min; int lens1 = s1.length(); int lens2 = s2.length(); if (lens1 &lt; lens2) &#123; max = s2; min = s1; &#125; else &#123; max = s1; min = s2; &#125; int maxlen = max.length(); int minlen = min.length(); int i, j; for (i = maxlen - 1, j = minlen - 1; j &gt;= 0; j--, i--) &#123; max[i] = max[i] + min[i] - '0'; //相加的ascii码-0就是对应数组的ascii码 &#125; for (int i = maxlen - 1; i &gt; 0; i--) &#123; if (max[i] &gt; '9') &#123; max[i] = max[i] - 10; //相加的ascii码-10就是个位数 max[i - 1] += 1; &#125; &#125; if (max[0] &gt; '9') &#123; max[0] -= 10; max = "1" + max; &#125; return max;&#125;int main()&#123; int num; cin &gt;&gt; num; int i = 1; int count = num; while (num) &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; cout &lt;&lt; s1 &lt;&lt; " + " &lt;&lt; s2 &lt;&lt; " = " &lt;&lt; sum(s1, s2) &lt;&lt; endl; if (i &lt; count) cout &lt;&lt; endl; num--; i++; &#125; return 0;&#125; HDU 2018 母牛的故事(递推)相似：HDU 2044~2050,HDU2041 Description 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？Input 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt; n&lt; 55)，n的含义如题目中描述。 n=0表示输入数据的结束，不做处理。Output 对于每个测试实例，输出在第n年的时候母牛的数量。 每个输出占一行。 分析:​ 以n=6为例，fn=9头牛可以分解为6+3，其中6是上一年（第5年）的牛，3是新生的牛（因为第3年有3头牛，这3头在第6年各生一头牛）。 我们可以得出这样一个公式：fn=fn-1+fn-3 再理解一下，fn-1是前一年的牛，第n年仍然在，fn-3是前三年那一年的牛，但换句话说也就是第n年具有生育能力的牛，也就是第n年能生下的小牛数。 代码: 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int f(int n);int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; cout&lt;&lt;f(n)&lt;&lt;endl; &#125; return 0;&#125; int f(int n)&#123; if(n&lt;4) return n; //第1，2，3年，各为1，2，3头 else return f(n-1)+f(n-3); //第n年为前一年的和前3年的相加&#125; HDU 2031 进制转换(模拟):Problem Description 输入一个十进制数N，将它转换成R进制数输出。 Input 输入数据包含多个测试实例，每个测试实例包含两个整数N(32位整数)和R（2&lt;=R&lt;=16, R&lt;&gt;10）。 Output 为每个测试实例输出转换后的数，每个输出占一行。如果R大于10，则对应的数字规则参考16进制（比如，10用A表示，等等）。 分析: 进制转换,也就是取余,以7的二进制表示: 7%2=1…7/2=3 3%2=1…3/2=1 1%2=1…1/2=0 取余的数字拼接为111,直到商为0为止,即是7的二进制表示 代码: 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int main()&#123; int n,r,i,x,flag; int a[1000]; while (scanf("%d %d",&amp;n,&amp;r)!=EOF) &#123; flag=0; if (n&lt;0) &#123; n=-n; flag=1; &#125; x=0; while (n) &#123; a[x]=n%r; n/=r; x++; &#125; while (x--) &#123; if (flag) &#123; printf("-"); flag=0; &#125; if (a[x]&lt;10) printf("%d",a[x]); else printf("%c",55+a[x]); &#125; printf("\n"); &#125; return 0;&#125; HDU 2048 神、上帝以及老天爷(错排问题)相似：HDU 2049 Description HDU 2006’10 ACM contest的颁奖晚会隆重开始了！为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的： 首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；然后，待所有字条加入完毕，每人从箱中取一个字条；最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！” 大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！ 我的神、上帝以及老天爷呀，怎么会这样呢？ 不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？ 不会算？难道你也想以悲剧结尾？！ Input 输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数n(1 &lt; n &lt; =20),表示参加抽奖的人数。 Output 对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。 分析: 典型的错排问题,具体思路如下: 当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推. 把第n个元素放在一个位置，比如位置k，一共有n-1种方法； 放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法；综上得到 D(n) = (n-1) [D(n-2) + D(n-1)]特殊地，D(1) = 0, D(2) = 1. 代码： 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n; int i,j,num; long long D[22],F[22]; D[1]=0;D[2]=1; for(i=3;i&lt;21;i++) D[i]=(i-1)*(D[i-1]+D[i-2]); for(i=20;i&gt;0;i--)&#123; F[i]=i; for(j=i-1;j&gt;1;j--) F[i]*=j; &#125; scanf("%d",&amp;num); while(num--)&#123; scanf("%d",&amp;n); printf("%.2lf%%\n",D[n]*100.0/F[n]); &#125; return 0;&#125; HDU 2053 Switch Game(开灯问题,唯一分解定理)Problem Description There are many lamps in a line. All of them are off at first. A series of operations are carried out on these lamps. On the i-th operation, the lamps whose numbers are the multiple of i change the condition ( on to off and off to on ). Input Each test case contains only a number n ( 0&lt; n&lt;= 10^5) in a line. Output Output the condition of the n-th lamp after infinity operations ( 0 - off, 1 - on ). 分析： 36的约数是 (1,36), (2,18), (3,12), (4,9), (6)，任何一个数都是由两个不同的数相乘得到的，但是如果一个数为平方数，那么这两个数就可以相等，例如36由两个6相乘得到，所以要判断灯的状态，只需要判断这个数是不是平方数即可 代码： 1234567891011121314#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; double x=sqrt(n*1.0); cout&lt;&lt;(x==int(x))&lt;&lt;endl; &#125; return 0;&#125; HDU 2057 A + B Again (16进制数相加)Problem Description There must be many A + B problems in our HDOJ , now a new one is coming.Give you two hexadecimal integers , your task is to calculate the sum of them,and print it in hexadecimal too.Easy ? AC it ! Input The input contains several test cases, please process to the end of the file.Each case consists of two hexadecimal integers A and B in a line seperated by a blank.The length of A and B is less than 15. Output For each test case,print the sum of A and B in hexadecimal in one line. 分析： 涉及到16进制内的加法，可以用%I64x直接来处理，要注意到16进制中负数是用补码来表示的。一个比较困惑的事实是，这道题再输出时，%64X中‘X’必须是大写，小写是过不了的。 注意：__int64 %I64X ,输出用大写 123456789101112131415#include "cstdio"int main()&#123; __int64 a,b,c; while(~scanf("%I64X%I64X",&amp;a,&amp;b)) &#123; c=a+b; if(c&gt;=0) printf("%I64X\n",c); else printf("-%I64X\n",-c); &#125; return 0;&#125; HDU 2062 Subset sequence（子序列）Problem Description Consider the aggregate An= { 1, 2, …, n }. For example, A1={1}, A3={1,2,3}. A subset sequence is defined as a array of a non-empty subset. Sort all the subset sequece of An in lexicography order. Your task is to find the m-th one. Input The input contains several test cases. Each test case consists of two numbers n and m ( 0&lt; n&lt;= 20, 0&lt; m&lt;= the total number of the subset sequence of An ). Output For each test case, you should output the m-th subset sequence of An in one line. 分析： 当n=2的时候 子序列从小到大 {1}, {1, 2}, {2}, {2, 1} 当n=3的时候 子序列从小到大 {1} {1, 2} {1, 2, 3} {1, 3} {1, 3, 2} {2}{2, 1}{2, 1, 3}{2, 3}{2, 3, 1} {3}{3, 1}{3, 1, 2}{3, 2}{3, 2, 1} 不难发现，An可以按首数字分成n组，而每组里除了第一项，剩下的就是An-1的子集合了。 ∴f(n) = n[f(n-1) + 1] f(1) = 1 我们拿测试数据3 10来做个示范，解释一下怎么求解。 因为n=3，所以开始数组里1、2、3三个数。 我们知道，n=2时，有4种排列，所以上面n=3可以分成三组，每组5个(加上空集)。 //空集就是说去掉该组第一个数字后为空集 因此第10个在第二组里。所以第一个是2，把2输出。原来的数组里删除2，变成1、3两个数。然后10 - (2 - 1) * 5 =5，即它在第2组的第5个。 //请自行推导所在位置 减去首个空集合，5 - 1 = 4 ≠ 0，表示2后面还有数字。 因为A1 = 1是，所以再第2组里又可以分成两组，每组2个(加上空集)。 所以，4在第2组，剩下的数组中，第二个元素是3，所以输出3。再把数组里的3删除，剩下1一个数。 然后4 - (2 - 1) * 2 = 2，既它是第2组的第2个。 减去首个空集，2 - 1 = 1 ≠ 0，表示2后面还有数字。 按上面的方法继续下去，直到n = 0 或 后面为空集为止。 最后输出数组里的第1个元素，就得到2 3 1，就是解了。从上面的计算可以看出来，本题目的关键是先求的An中每一组的个数g(n) 不难得出:g(n) = f(n) / n ∵f(n) = n[f(n-1) + 1] ∴g(n) = n[f(n-1) + 1] / n = f(n-1) + 1 ∵f(n-1) = (n-1) * g(n-1) ∴g(n) = (n-1) * g(n-1) + 1 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;cstring&gt;int main()&#123; int a; __int64 b; __int64 g[30]; g[1]=1; g[2]=2; for(int i=3;i&lt;22;i++) &#123; g[i]=g[i-1]*(i-1)+1;//求出g； &#125; int num[30]; while(scanf("%d%I64d",&amp;a,&amp;b)!=EOF) //b的数可能很大，所以用I64d，，用int运行错了 &#123; memset(num,0,sizeof(num));//清零 for(int i=1;i&lt;=a;i++) num[i]=i; //将要输出的数字保存在数组里 int am=a; while(a--)//总共有a个数（1---a）最多可能输出a个 &#123; int n=b%g[a+1]? b/g[a+1]+1: b/g[a+1]; //我们用b取余对应的g，，得到要输出的数在第几组 if(num[n]==0) break; if(am-1==a) printf("%d",num[n]); / /输出对应的组代表的数字 else printf(" %d",num[n]); for(int i=n;i&lt;=a;i++) num[i]=num[i+1]; //将刚输出的数字删掉，，留下剩下的数字，，没用的数字都变成0了 b=(b-g[a+1]*(n-1)-1); //把问题缩小到下一组，，， 求出在下一组的位置；循环；直到要输出的num为0，说明所有的数都输完了； &#125; printf("\n"); &#125; return 0;&#125; HDU 2064 汉诺塔Ⅲ（递归）Problem Description 约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？ Input 包含多组数据，每次输入一个N值(1&lt;=N=35)。 Output 对于每组数据，输出移动最小的次数。 分析： 建议阅读 如何理解汉诺塔的递归？ - 知乎 其实本题的复杂之处就是相当与比以往的汉诺塔多移动了一次柱子，原来，现在a4=a3+a3+a3+2(移动最大的圆盘要两次)，理解了便能很快求解 待补充： HDU 2059 Seraph2012 (DP)HDU 2037 今年暑假不AC（贪心）推荐：贪心算法 Problem Description“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）Input输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。Output对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。 分析：最简单的贪心算法，因为一个节目对应一个开始时间和一个结束时间，所以，将这两个时间放到一个结构体中，然后对结束时间按照从小到大的顺序进行排序，如果结束的时间相同的话，就将开始的时间按照从大到小的顺序排序，然后开始比较，如果开始的时间比前一个结束的时间迟，就k++，最终k的值即为所求！ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std; struct Program&#123; int start,end;&#125;pro[10001]; int main()&#123; int n,sum,final; int i,j; Program temp; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; for(i=0;i&lt;n;++i) &#123; scanf("%d%d",&amp;pro[i].start,&amp;pro[i].end); &#125; for(i=0;i&lt;n-1;++i) for(j=i+1;j&lt;n;++j) if(pro[i].end&gt;pro[j].end) &#123; temp=pro[i]; pro[i]=pro[j]; pro[j]=temp; &#125; sum=1; final=pro[0].end; for(i=1;i&lt;n;++i) &#123; if(final&lt;=pro[i].start) &#123; ++sum; final=pro[i].end; &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125; HDU 2063 过山车 （二分图的最大匹配、完美匹配和匈牙利算法）https://www.renfei.org/blog/bipartite-matching.html 小技巧：输出控制：c++中用cout输出，要求保留两位小数，比如，输出100，则为100.00 1cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;456.777&lt;&lt;endl 标准开头：1while (scanf("%d %d",&amp;n,&amp;r)!=EOF) 16进制数相加：1scanf("%I64X%I64X",&amp;a,&amp;b)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>tests</tag>
      </tags>
  </entry>
</search>
