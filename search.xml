<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二分法之可能是总结的最好的一篇文章]]></title>
    <url>%2F%E4%BA%8C%E5%88%86%E6%B3%95%E4%B9%8B%E5%8F%AF%E8%83%BD%E6%98%AF%E6%80%BB%E7%BB%93%E7%9A%84%E6%9C%80%E5%A5%BD%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.html</url>
    <content type="text"><![CDATA[前言二分查找有很多种变体，使用时需要注意查找条件，判断条件和左右边界的更新方式，三者配合不好就很容易出现死循环或者遗漏区域，本篇中我们将介绍常见的几种查找方式的模板代码，包括： 标准的二分查找 二分查找左边界 二分查找右边界 二分查找左右边界 二分查找极值点 本文的内容来自于笔者个人的总结，事实上二分查找有很多种等价的写法，本文只是列出了笔者认为的最容易理解和记忆的方法。 二分查找作为程序员的一项基本技能，是面试官最常使用来考察程序员基本素质的算法之一，也是解决很多查找类题目的常用方法，它可以达到O(log n)的时间复杂度。 一般而言，当一个题目出现以下特性时，你就应该立即联想到它可能需要使用二分查找： 待查找的数组有序或者部分有序 要求时间复杂度低于O(n)，或者直接要求时间复杂度为O(log n) 二分查找、二分边界查找算法的模板代码总结 算法 算法-数据结构 模板 总结 二分查找 标准二分查找首先给出标准二分查找的模板： 12345678910111213141516class BinarySearch &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt;= right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] == target) return mid; else if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1; &#125;&#125; 循环条件： left &lt;= right 中间位置计算： mid = left + ((right -left) &gt;&gt; 1) 左边界更新：left = mid + 1 右边界更新： right = mid - 1 返回值： mid / -1 这里有几点需要注意： 我们的循环条件中包含了 left == right的情况，则我们必须在每次循环中改变 left 和 right的指向，以防止进入死循环 循环终止的条件包括： 找到了目标值 left &gt; right （这种情况发生于当left, mid, right指向同一个数时，这个数还不是目标值，则整个查找结束。） left + ((right -left) &gt;&gt; 1) 其实和 (left + right) / 2是等价的，这样写的目的一个是为了防止 (left + right)出现溢出，一个是用右移操作替代除法提升性能。 left + ((right -left) &gt;&gt; 1) 对于目标区域长度为奇数而言，是处于正中间的，对于长度为偶数而言，是中间偏左的。因此左右边界相遇时，只会是以下两种情况： left/mid , right (left, mid 指向同一个数，right指向它的下一个数) left/mid/right （left, mid, right 指向同一个数） 即因为mid对于长度为偶数的区间总是偏左的，所以当区间长度小于等于2时，mid 总是和 left在同一侧。 实战1：Guess Number Higher or Lower leetcode 原题： https://leetcode.com/problems… 难度等级： Easy We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I’ll tell you whether the number is higher or lower. You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0): -1 : My number is lower1 : My number is higher0 : Congrats! You got it!Example : Input: n = 10, pick = 6Output: 6 这题基本是可以直接照搬二分查找的，出题者没有做任何包装，我们直接使用标准二分查找： 1234567891011121314151617public class Solution extends GuessGame &#123; public int guessNumber(int n) &#123; int left = 1; int right = n; while (left &lt;= right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (guess(mid) == 0) &#123; return mid; &#125; else if (guess(mid) == -1) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1; &#125;&#125; 实战2：Sqrt(x) leetcode 原题： https://leetcode.com/problems… 难度等级： Easy Implement int sqrt(int x).Compute and return the square root of x, where x is guaranteed to be a non-negative integer.Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. 这一题其实是二分查找的应用，乍一看好像和二分查找没有关系，但是我们可以用二分查找的思想快速定位到目标值的平方根，属于二分查找的一个简单运用： 12345678910111213141516171819class Solution &#123; public int mySqrt(int x) &#123; if (x &lt;= 1) return x; int left = 1; int right = x - 1; while (left &lt;= right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (mid &gt; x / mid) &#123; right = mid - 1; &#125; else if (mid &lt; x / mid) &#123; if (mid + 1 &gt; x / (mid + 1)) return mid; left = mid + 1; &#125; else &#123; return mid; &#125; &#125; return -1; // only for return a value &#125;&#125; 虽然是简单的题目，但是还是要注意对溢出的处理，例如我们使用 mid &gt; x / mid 而不是 mid * mide &gt; x 作为判断条件，因为后者可能会导致溢出，这与我们使用 left + ((right - left) &gt;&gt; 1) 而不是 (left + right) / 2 作为mid的值是一个道理，这是因为 left + right 也可能溢出。 二分查找左边界利用二分法寻找左边界是二分查找的一个变体，应用它的题目常常有以下几种特性之一： 数组有序，但包含重复元素 数组部分有序，且不包含重复元素 数组部分有序，且包含重复元素 左边界查找类型1类型1包括了上面说的第一种，第二种情况。 既然要寻找左边界，搜索范围就需要从右边开始，不断往左边收缩，也就是说即使我们找到了nums[mid] == target, 这个mid的位置也不一定就是最左侧的那个边界，我们还是要向左侧查找，所以我们在nums[mid]偏大或者nums[mid]就等于目标值的时候，继续收缩右边界，算法模板如下： 123456789101112131415class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return nums[left] == target ? left : -1; &#125;&#125; 循环条件： left &lt; right 中间位置计算： mid = left + ((right -left) &gt;&gt; 1) 左边界更新：left = mid + 1 右边界更新： right = mid 返回值： nums[left] == target ? left : -1 与标准的二分查找不同： 首先，这里的右边界的更新是right = mid，因为我们需要在找到目标值后，继续向左寻找左边界。 其次，这里的循环条件是left &lt; right。因为在最后left与right相邻的时候，mid和left处于相同的位置(前面说过，mid偏左)，则下一步，无论怎样，left, mid, right都将指向同一个位置，如果此时循环的条件是left &lt;= right，则我们需要再进入一遍循环，此时，如果nums[mid] &lt; target还好说，循环正常终止；否则，我们会令right = mid，这样并没有改变left,mid,right的位置，将进入死循环。 事实上，我们只需要遍历到left和right相邻的情况就行了，因为这一轮循环后，无论怎样，left,mid,right都会指向同一个位置，而如果这个位置的值等于目标值，则它就一定是最左侧的目标值；如果不等于目标值，则说明没有找到目标值，这也就是为什么返回值是nums[left] == target ? left : -1。 左边界查找类型2左边界查找的第二种类型用于数组部分有序且包含重复元素的情况，这种条件下在我们向左收缩的时候，不能简单的令 right = mid，因为有重复元素的存在，这会导致我们有可能遗漏掉一部分区域，此时向左收缩只能采用比较保守的方式，代码模板如下： 1234567891011121314151617class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if (nums[mid] &gt; target) &#123; right = mid; &#125; else &#123; right--; &#125; &#125; return nums[left] == target ? left : -1; &#125;&#125; 它与类型1的唯一区别就在于对右侧值的收缩更加保守。这种收缩方式可以有效地防止我们一下子跳过了目标边界从而导致了搜索区域的遗漏。 关于这种类型的例子，可以看下面的实战5。 实战3：First Bad Version leetcode 原题： https://leetcode.com/problems… 难度等级： Easy 这道题的题目比较长，原题就不贴了，大意就是说：有这么一个数组： 1[false, false, false, ..., fasle, true, true, ..., true] 求最左侧的那个true的位置。 这就是一个典型的查找左边界的问题：数组中包含重复元素，我们需要找到最左侧边界的位置。直接使用二分查找左边界的模板就行了： 123456789101112131415public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int left = 0; int right = n - 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (!isBadVersion(mid + 1)) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return isBadVersion(left + 1) ? left + 1 : -1; &#125;&#125; 与之类似的例子还有：LeetCode 744 等，都是Easy级别的题目，简单的使用二分查找左边界的模板就行了，大家可以自行练习。 当然，除了这种显而易见的题目，对于一些变体，我们也应该要有能力去分辨，比如说这一题：LeetCode 658 。 实战4：Find Minimum in Rotated Sorted Array leetcode 原题： https://leetcode.com/problems… 难度等级： Medium Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. 这一题看上去没有重复元素，但是它也是查找左边界的一种形式，即可以看做是查找旋转到右侧的部分的左边界，有了这个思想，直接用二分查找左边界的模板就行了： 12345678910111213141516class Solution &#123; public int findMin(int[] nums) &#123; if (nums.length == 1) return nums[0]; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] &gt; nums[nums.length - 1]) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return nums[left]; &#125;&#125; 实战5：Find Minimum in Rotated Sorted Array II leetcode 原题： https://leetcode.com/problems… 难度等级： Hard 这道题目和上面的实战2类似，只是多了一个条件——数组中可能包含重复元素，这就是我们之前说的二分查找左边界的第二种类型，在这种情况下，我们只能采用保守收缩的方式，以规避重复元素带来的对于单调性的破坏： 12345678910111213141516171819class Solution &#123; public int findMin(int[] nums) &#123; if (nums.length == 1) return nums[0]; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] &gt; nums[right]) &#123; // mid 位于旋转点左侧 left = mid + 1; &#125; else if (nums[mid] &lt; nums[right]) &#123; // mid 位于旋转点右侧 right = mid; &#125; else &#123; // 注意相等的时候的特殊处理，因为要向左查找左边界，所以直接收缩右边界 right--; &#125; &#125; return nums[left]; &#125;&#125; 二分查找右边界有了寻找左边界的分析之后，再来看寻找右边界就容易很多了，毕竟左右两种情况是对称的嘛，关于使用场景这里就不再赘述了，大家对称着理解就好。我们直接给出模板代码： 123456789101112131415class Solution &#123; public int search(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1) + 1; if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid; &#125; &#125; return nums[right] == target ? right : -1; &#125;&#125; 循环条件： left &lt; right 中间位置计算： mid = left + ((right -left) &gt;&gt; 1) + 1 左边界更新：left = mid 右边界更新： right = mid - 1 返回值： nums[right] == target ? right : -1 这里大部分和寻找左边界是对称着来写的，唯独有一点需要尤其注意——中间位置的计算变了，我们在末尾多加了1。这样，无论对于奇数还是偶数，这个中间的位置都是偏右的。 对于这个操作的理解，从对称的角度看，寻找左边界的时候，中间位置是偏左的，那寻找右边界的时候，中间位置就应该偏右呗，但是这显然不是根本原因。根本原因是，在最后left和right相邻时，如果mid偏左，则left, mid指向同一个位置，right指向它们的下一个位置，在nums[left]已经等于目标值的情况下，这三个位置的值都不会更新，从而进入了死循环。所以我们应该让mid偏右，这样left就能向右移动。这也就是为什么我们之前一直强调查找条件，判断条件和左右边界的更新方式三者之间需要配合使用。 右边界的查找一般来说不会单独使用，如有需要，一般是需要同时查找左右边界。 二分查找左右边界前面我们介绍了左边界和右边界的查找，那么查找左右边界就容易很多了——只要分别查找左边界和右边界就行了。 实战6: Find First and Last Position of Element in Sorted Array leetcode 原题： https://leetcode.com/problems… 难度等级： Medium Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1]. 这是一道特别标准的查找左右边界的题目，我们只需要分别查找左边界和右边界就行了： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int[] res = new int[]&#123;-1, -1&#125;; if(nums == null || nums.length == 0) return res; // find the left-end int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; res[0] = nums[left] == target ? left : -1; // find right-end if (res[0] != -1) &#123; if (left == nums.length - 1 || nums[left + 1] != target) &#123; res[1] = left; &#125; else &#123; right = nums.length - 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1) + 1; if (nums[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid; &#125; &#125; res[1] = right; &#125; &#125; return res; &#125;&#125; 二分查找极值二分查找还有一种有趣的变体是二分查找极值点，之前我们使用nums[mid]去比较的时候，常常是和给定的目标值target比，或者和左右边界比较，在二分查找极值点的应用中，我们是和相邻元素去比，以完成某种单调性的检测。关于这一点，我们直接来看一个例子就明白了。 实战7：Find Peak Element leetcode 原题：https://leetcode.com/problems… 难度等级： Medium A peak element is an element that is greater than its neighbors.Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.You may imagine that nums[-1] = nums[n] = -∞. 这一题的有趣之处在于他要求求一个局部极大值点，并且整个数组不包含重复元素。所以整个数组甚至可以是无序的——你可能很难想象我们可以在一个无序的数组中直接使用二分查找，但是没错！我们确实可以这么干！谁要人家只要一个局部极大值即可呢。 123456789101112131415class Solution &#123; public int findPeakElement(int[] nums) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); if (nums[mid] &lt; nums[mid + 1]) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left; &#125;&#125; 这里尤其注意我们的判断条件nums[mid] &lt; nums[mid + 1]，这实际上是在判断处于mid处的相邻元素的单调性。 总结除了本文所介绍的二分查找的应用方式，二分查找其实还有很多其他的变体和应用，但它们基本上是循环条件，判断条件，边界更新方法的不同组合，例如，有的二分查找的循环条件可以是 while(left + 1 &lt; right)，有的边界的更新的条件需要依赖 nums[left], nums[mid], nums[mid+1], nums[right]四个值的相互关系。 但是无论如何，代码模板只是给大家一个理解问题的角度，生搬硬套总是不好的。实际应用中，我们只要记住循环条件，判断条件与边界更新方法三者之间的配套使用就行了，基于这一点原则，你就可以使用你自己习惯的方式来实现二分搜索。 但是，如果你真的只是想应付面试，我想下面这个表的总结应该就差不多足够用了： 查找方式 循环条件 左侧更新 右侧更新 中间点位置 返回值 标准二分查找 left &lt;= right left = mid - 1 right = mid + 1 (left + right) / 2 -1 / mid 二分找左边界 left &lt; right left = mid - 1 right = mid (left + right) / 2 -1 / left 二分找右边界 left &lt; right left = mid right = mid - 1 (left + right) / 2 + 1 -1 / right 最后，希望大家在理解二分查找的思想后都能够写出适合自己的搭配方式，共勉！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java高并发秒杀平台实战记录]]></title>
    <url>%2Fjava%E9%AB%98%E5%B9%B6%E5%8F%91%E7%A7%92%E6%9D%80%E5%B9%B3%E5%8F%B0%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"></content>
      <categories>
        <category>项目学习</category>
      </categories>
      <tags>
        <tag>高并发</tag>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer难题总结]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%E9%9A%BE%E9%A2%98%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[暑假到了，最近两个月在家专心准备求职的事情，也同时在牛客网上刷了不少题，概念题基本还行，但是算法题还是有些薄弱。 不得不说，程序员就像运动员一样，一天不练习，技巧便会生疏积分，于是把难题记录下来，希望总结过后有所收获 1.二维数组的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 分析： 两个思路 暴力遍历法 可以遍历行，获取target所在的行，然后由于数组是基本有序的，可以使用二分法，查找数据所在的位置，这样时间复杂度是O(nlgn) 12345678910111213141516171819202122232425262728public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int n = array.length; int m = array[0].length-1; int left = 0; int right = m; if(n==0||m==0)&#123; return false; &#125; for(int i=0;i&lt;n;i++)&#123; if(array[i][0]&lt;=target)&#123; while(left&lt;=right)&#123; int mid = left+(right-left)/2; if(array[i][mid] == target)&#123; return true; &#125; else if(array[i][mid]&gt;target)&#123; right = mid-1; &#125; else&#123; left = mid+1; &#125; &#125; &#125; &#125; return false; &#125;&#125; 指针法 由于数组不论是在行，还是在列，都是基本有序的，我们可以从第一行的最后一个数开始比较，如果比这个数大，则说明在下一行，如果比这个数小，则说明在这一行的前一个位置，如此反复，找到target所在的位置，这样的时间复杂度为O(m+n)，明显更优 代码如下: 12345678910111213141516171819public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int x = array.length; int y = array[0].length; int i = 0; int j = y - 1; while (i &lt; x &amp;&amp; ｊ&gt;= 0)&#123; if (array[i][j] &gt; target)&#123; j = j-1; &#125;else if(array[i][j] &lt; target)&#123; i = i + 1; &#125;else&#123; return true; &#125; &#125; return false; &#125;&#125; 2.重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 分析： 由于前序遍历和中序遍历都会有一个公共的根节点，我们可以递归的获取这个根节点的左子树和右子树来重建整个二叉树 首先我们知道前序遍历的第一个节点1是二叉树的根节点，并且由于中序遍历的顺序是左-中-右，所以我们可以在中序遍历中找到根节点1的位置，1前面的数字即是左子树的数字（柚子树同理）。我们假设1在中序遍历中排第n位 这样的话我们就可以在前序遍历中位置（1-n）位左子树，(n-end)为右子树，返回根节点root。 这样不断递归，不断获取左、右子树的根节点，我们就可以重建二叉树了（记得要考虑叶子节点的边界情况），树的边界情况一般就是叶子节点和只有一个节点的情况 代码： 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre.length!=in.length || pre==null || in ==null)&#123; return null; &#125; return Construct(pre,0,pre.length-1,in,0,in.length-1); &#125; public static TreeNode Construct(int [] preorder,int ps,int pe,int[] inorder,int is,int ie)&#123; //叶子节点时，ps+1，而pe不变 if(ps&gt;pe || is&gt;ie)&#123; return null; &#125; int value = preorder[ps]; int index = is; while(inorder[index]!=value &amp;&amp; index&lt;ie)&#123; index++; &#125; if(index&gt;ie)&#123; return null; &#125; TreeNode node = new TreeNode(value); node.left = Construct(preorder,ps+1,ps+index-is,inorder,is,index-1); node.right = Construct(preorder,ps+index-is+1,pe,inorder,index+1,pe); return node; &#125;&#125; 3.旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 分析： 建议看看这篇二分法的文章，这里数组是部分有序的，所以我们可以用二分法，这里是二分法变形中的求最左值的问题 代码： 1234567891011121314151617181920import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; int len = array.length; if(len == 0) return 0; int low = 0, high = len - 1; while(low &lt; high)&#123; int mid = low + (high - low) / 2; if(array[mid] &gt; array[high])&#123; low = mid + 1; &#125;else if(array[mid] == array[high])&#123; high = high - 1; &#125;else&#123; high = mid; &#125; &#125; return array[low]; &#125;&#125; 4.跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 分析： 由于递归会重复调用很多语句，时间复杂度是指数级别的，所以我们一般用覆盖法。 1234567891011121314151617181920public class Solution &#123; public int JumpFloor(int target) &#123; int one = 1; int two = 2; int result = 0; if(target==1)&#123; return 1; &#125; if(target == 2)&#123; return 2; &#125; for(int i=3;i&lt;=target;i++)&#123; result = one + two; one = two; two = result; &#125; return result; &#125;&#125; 5.二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 分析； 求二进制中表示一的个数，就想到我们可以用位运算的与运算，把二进制数与1按位与，不为0的即为1, 这里我们要知道，数字在计算机中都是以补码存储的，而题目要求负数以补码形式表示，且恰好正数的补码和原码是相同的，所以我们可以直接按位与然后移位即可。 易错的是，由于负数的补码第一位为1，如果我们把要比较的值按位右移，while (n != 0)永远成立不了，会进入死循环。 所以我们有两种思路： 1.不带符号位的右移 使用&gt;&gt;&gt;即可 12345678910111213public class Solution &#123; public int NumberOf1(int n) &#123; int flag = 1; int count = 0; while(n!=0)&#123; if((1 &amp; n) == 1)&#123; count++; &#125; n=n&gt;&gt;&gt;1; &#125; return count; &#125;&#125; 2.使用 n = n &amp; (n - 1); 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 12345678910public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; while(n!= 0)&#123; count++; n = n &amp; (n - 1); &#125; return count; &#125;&#125; 6.数值的整数次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 分析： 这题如果使用暴力的方法会超时，所以明显我们使用的是快速幂方法，其实也是获取二进制中1的个数，快速幂代码如下 123456789101112int pow3(int a,int b)&#123; int ans = 1,base = a; while(b!=0) &#123; if(b&amp;1) ans *= base; base *= base; b&gt;&gt;=1; &#125; return ans;&#125; 这里还要分情况讨论幂为负数的情况，总体代码如下： 12345678910111213141516171819202122232425public class Solution &#123; public double Power(double base, int exponent) &#123; //考虑指数为负 int flag = 0; if(exponent&lt;0)&#123; exponent=-exponent; flag=1; &#125; //快速幂 int res = 1; while(exponent!=0)&#123; if((exponent&amp;1)!=0)&#123; res*=base; base*=base; &#125; exponent=exponent&gt;&gt;1; &#125; //返回结果 if(flag==1)&#123; return 1.0/res; &#125;else&#123; return res; &#125; &#125;&#125; 7.栈的压入，弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 分析： 定义一个新的栈，如果栈顶元素和应出栈的元素相同，则pop出来，否则将应该入栈的值入栈，最后判断栈是否为空 总之就是找到第一个出栈的元素4，判断之后的出栈序列是否是按入栈序列的顺序 代码： 1234567891011121314151617181920import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA==null || popA==null)&#123; return false; &#125; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int n = pushA.length; int index = 0; for(int i=0;i&lt;n;i++)&#123; s.push(pushA[i]); while(!s.empty()&amp;&amp;s.peek()==popA[index])&#123; s.pop(); index++; &#125; &#125; return s.isEmpty(); &#125;&#125; 8.二叉树层次遍历按二叉树的层次遍历输出二叉树 分析： 使用队列，每次取队列的顶部元素，将顶部元素的左子树，右子树依次入列，知道队列为空为止 代码： 123456789101112131415161718192021public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; res = new ArrayList(); ArrayList&lt;TreeNode&gt; queue = new ArrayList(); if(root==null)&#123; return res; &#125; queue.add(root); while(!queue.isEmpty())&#123; TreeNode node = queue.remove(0); if(node.left!=null)&#123; queue.add(node.left); &#125; if(node.right!=null)&#123; queue.add(node.right); &#125; res.add(node.val); &#125; return res; &#125;&#125; 9.快速排序https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485191&amp;idx=1&amp;sn=45a43bd77495566db53b419ae82136f5&amp;source=41#wechat_redirect 分析：首先将中心节点设为数组的起始节点，然后使用双指针，从数组的两边开始，左边遇到比数组大的元素，右边遇到比数组小的元素，则两者交换位置，双指针循环完毕后，将中心节点与右指针所在位置的节点互换，构成新的中心节点，然后递归调用quicksort方法即可 代码： 123456789101112131415161718192021222324252627static void quick_sort(int[] a) &#123; if(a.length&gt;0) quick_sort(a, 0 , a.length-1);&#125;static void quick_sort(int[] a, int low, int high) &#123; if(low &gt; high) return; int i = low; int j = high; int key = a[low]; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; a[j] &gt; key) j--; while(i &lt; j &amp;&amp; a[i] &lt;= key) i++; if(i &lt; j) &#123; int p = a[i]; a[i] = a[j]; a[j] = p; &#125; &#125; int p = a[i]; a[i] = a[low]; a[low] = p; quick_sort(a,low,i - 1 ); quick_sort(a,i + 1,high); &#125; 10.顺时针打印矩阵分析： 从外部向内部逐层遍历打印矩阵，最外面一圈打印完，里面仍然是一个矩阵统计矩阵的层数，每一层最多会占据两行或者两列，最少会占据一行或者一列元素，只有一层或者一列，也算一层，分层如下图： 123int m = matrix.length;int n = matrix[0].length;int count = (Math.min(m, n)+1)/2; 开始打印第 i 层的矩阵元素 如上图所示，再打印第i层的矩阵时，要经历4个循环： 12345678910111213141516171819202122232425262728public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(matrix == null || matrix.length == 0) return list; int m = matrix.length; int n = matrix[0].length; int i = 0; //统计矩阵从外向内的层数，如果矩阵非空，那么它的层数至少为1层 int count = (Math.min(m, n)+1)/2; //从外部向内部遍历，逐层打印数据 while(i &lt; count) &#123; for (int j = i; j &lt;= n-i-1; j++) &#123; list.add(matrix[i][j]); &#125; for (int j = i+1; j &lt;= m-i-1; j++) &#123; list.add(matrix[j][(n-1)-i]); &#125; for (int j = (n-1)-(i+1); j &gt;= i &amp;&amp; (m-1-i != i); j--) &#123; list.add(matrix[(m-1)-i][j]); &#125; for (int j = (m-1)-(i+1); j &gt;= i+1 &amp;&amp; (n-1-i) != i; j--) &#123; list.add(matrix[j][i]); &#125; i++; &#125; return list;&#125; 11.二叉树中和尾某一值的路径输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 分析： 回溯法的经典例题，首先定义递归，递归的三个条件 终止条件 ：target=0且为叶子节点 问题逻辑：每次更新list，如果target=0，则将list插入结果中，否则回溯 子问题：FindPath(root.left, target); FindPath(root.right, target); 是否回溯：是 然后每次操作之后回溯操作，也就是本题中的list.remove(list.size()-1) 代码： 123456789101112131415public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root == null) return listAll; list.add(root.val); target -= root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) listAll.add(new ArrayList&lt;Integer&gt;(list)); FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size()-1); return listAll; &#125;&#125; 12.合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则 分析： 子问题： 如果list1小于list2的值，list1.next 为Merge（list1.next，list2)，返回list1 如果list1大于list2的值，list2.next为Merge（list1，list2.next），返回list2 问题逻辑：list1.next = Merge(list1.next, list2); 终止条件：一方链表到达结尾，返回未到达结尾的那个节点 是否回溯：否 代码： 12345678910111213141516171819public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null)&#123; return list2; &#125; if(list2 == null)&#123; return list1; &#125; if(list1.val &lt;= list2.val)&#123; list1.next = Merge(list1.next, list2); return list1; &#125;else&#123; list2.next = Merge(list1, list2.next); return list2; &#125; &#125;&#125; 13.二叉搜索树的后续遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 分析： 子问题 ：由于是后续遍历，因此最后一个节点肯定是根节点，我们从后往前，寻找到第一个小于根节点的节点，以此节点为界，将树分为左子树和右子树。 问题逻辑：我们已经把同级的左子树划分出去了，接下来只要知道同级的右子树所有节点都比界节点i大即可，右子树最大的节点为倒数第二个节点。 终止条件：当树只剩下两个节点的时候，不管最后有没有比根节点大的节点，start&gt;=end都会成立，所以结束条件为start&gt;=end 是否回溯：否 代码： 12345678910111213141516171819202122232425262728public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence.length == 0)&#123; return false; &#125; if(sequence.length == 1)&#123; return true; &#125; return judge(sequence,0,sequence.length-1); &#125; public boolean judge(int[] a,int start,int end)&#123; if(start &gt;= end)&#123; return true; &#125; int i = start; while(a[i] &lt; a[end])&#123; ++i; &#125; for(int j=i;j&lt;end;j++)&#123; if(a[j] &lt; a[end])&#123; return false; &#125; &#125; return judge(a,start,i-1) &amp;&amp; judge(a,i,end-1); &#125;&#125; 14.树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 分析： 子问题：首先找到第一个相等的节点，然后判断两树是否有子结构关系，若无，则继续寻找下一个相等的节点，若有，则返回true 问题逻辑：首先将树不断分为左右两树，如果有一树根节点和B匹配上，则判断B是否事此树的子结构 终止条件：从A，B子树根节点相等的时候开始比较，如果B遍历完，A没遍历完，则返回True，A，B同时遍历完，也返回True，否则返回false 是否回溯：否 12345678910111213141516171819202122232425public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean result = false; if(root1 != null &amp;&amp; root2 != null)&#123; if(root1.val == root2.val)&#123; result = isAMother(root1,root2); &#125; if(!result)&#123;result = HasSubtree(root1.left, root2)||HasSubtree(root1.right, root2);&#125; &#125; return result; &#125; public boolean isAMother(TreeNode root1,TreeNode root2)&#123; if(root1==null &amp;&amp; root2!=null)&#123; return false; &#125; if(root2==null)&#123; return true; &#125; if(root1.val!=root2.val) return false; return isAMother(root1.left,root2.left) &amp;&amp; isAMother(root1.right,root2.right); &#125; &#125; 15.二叉搜索树和双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 分析： 子问题：将二叉树分为左右两个树，中序遍历 问题逻辑：首先肯定会获取到最左边的节点，然后我们定义两个指针，首先两个指针都指向最左边的节点，然后依次往上传递 终止条件：遍历完整个树 是否回溯：否 代码： 1234567891011121314151617181920212223//直接用中序遍历public class Solution &#123; TreeNode head = null; TreeNode realHead = null; public TreeNode Convert(TreeNode pRootOfTree) &#123; ConvertSub(pRootOfTree); return realHead; &#125; private void ConvertSub(TreeNode pRootOfTree) &#123; if(pRootOfTree==null) return; ConvertSub(pRootOfTree.left); if (head == null) &#123; head = pRootOfTree; realHead = pRootOfTree; &#125; else &#123; head.right = pRootOfTree; pRootOfTree.left = head; head = pRootOfTree; &#125; ConvertSub(pRootOfTree.right); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer难题总结]]></title>
    <url>%2F%E5%89%91%E6%8C%87offer%E9%9A%BE%E9%A2%98%E6%80%BB%E7%BB%93_new.html</url>
    <content type="text"><![CDATA[暑假到了，最近两个月在家专心准备求职的事情，也同时在牛客网上刷了不少题，概念题基本还行，但是算法题还是有些薄弱。 不得不说，程序员就像运动员一样，一天不练习，技巧便会生疏积分，于是把难题记录下来，希望总结过后有所收获 1.二维数组的查找在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 分析： 两个思路 暴力遍历法 可以遍历行，获取target所在的行，然后由于数组是基本有序的，可以使用二分法，查找数据所在的位置，这样时间复杂度是O(nlgn) 12345678910111213141516171819202122232425262728public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int n = array.length; int m = array[0].length-1; int left = 0; int right = m; if(n==0||m==0)&#123; return false; &#125; for(int i=0;i&lt;n;i++)&#123; if(array[i][0]&lt;=target)&#123; while(left&lt;=right)&#123; int mid = left+(right-left)/2; if(array[i][mid] == target)&#123; return true; &#125; else if(array[i][mid]&gt;target)&#123; right = mid-1; &#125; else&#123; left = mid+1; &#125; &#125; &#125; &#125; return false; &#125;&#125; 指针法 由于数组不论是在行，还是在列，都是基本有序的，我们可以从第一行的最后一个数开始比较，如果比这个数大，则说明在下一行，如果比这个数小，则说明在这一行的前一个位置，如此反复，找到target所在的位置，这样的时间复杂度为O(m+n)，明显更优 代码如下: 12345678910111213141516171819public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int x = array.length; int y = array[0].length; int i = 0; int j = y - 1; while (i &lt; x &amp;&amp; ｊ&gt;= 0)&#123; if (array[i][j] &gt; target)&#123; j = j-1; &#125;else if(array[i][j] &lt; target)&#123; i = i + 1; &#125;else&#123; return true; &#125; &#125; return false; &#125;&#125; 2.重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 分析： 由于前序遍历和中序遍历都会有一个公共的根节点，我们可以递归的获取这个根节点的左子树和右子树来重建整个二叉树 首先我们知道前序遍历的第一个节点1是二叉树的根节点，并且由于中序遍历的顺序是左-中-右，所以我们可以在中序遍历中找到根节点1的位置，1前面的数字即是左子树的数字（柚子树同理）。我们假设1在中序遍历中排第n位 这样的话我们就可以在前序遍历中位置（1-n）位左子树，(n-end)为右子树，返回根节点root。 这样不断递归，不断获取左、右子树的根节点，我们就可以重建二叉树了（记得要考虑叶子节点的边界情况），树的边界情况一般就是叶子节点和只有一个节点的情况 代码： 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre.length!=in.length || pre==null || in ==null)&#123; return null; &#125; return Construct(pre,0,pre.length-1,in,0,in.length-1); &#125; public static TreeNode Construct(int [] preorder,int ps,int pe,int[] inorder,int is,int ie)&#123; //叶子节点时，ps+1，而pe不变 if(ps&gt;pe || is&gt;ie)&#123; return null; &#125; int value = preorder[ps]; int index = is; while(inorder[index]!=value &amp;&amp; index&lt;ie)&#123; index++; &#125; if(index&gt;ie)&#123; return null; &#125; TreeNode node = new TreeNode(value); node.left = Construct(preorder,ps+1,ps+index-is,inorder,is,index-1); node.right = Construct(preorder,ps+index-is+1,pe,inorder,index+1,pe); return node; &#125;&#125; 3.旋转数组的最小数字把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 分析： 建议看看这篇二分法的文章，这里数组是部分有序的，所以我们可以用二分法，这里是二分法变形中的求最左值的问题 代码： 1234567891011121314151617181920import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; int len = array.length; if(len == 0) return 0; int low = 0, high = len - 1; while(low &lt; high)&#123; int mid = low + (high - low) / 2; if(array[mid] &gt; array[high])&#123; low = mid + 1; &#125;else if(array[mid] == array[high])&#123; high = high - 1; &#125;else&#123; high = mid; &#125; &#125; return array[low]; &#125;&#125; 4.跳台阶一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 分析： 由于递归会重复调用很多语句，时间复杂度是指数级别的，所以我们一般用覆盖法。 1234567891011121314151617181920public class Solution &#123; public int JumpFloor(int target) &#123; int one = 1; int two = 2; int result = 0; if(target==1)&#123; return 1; &#125; if(target == 2)&#123; return 2; &#125; for(int i=3;i&lt;=target;i++)&#123; result = one + two; one = two; two = result; &#125; return result; &#125;&#125; 5.二进制中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 分析； 求二进制中表示一的个数，就想到我们可以用位运算的与运算，把二进制数与1按位与，不为0的即为1, 这里我们要知道，数字在计算机中都是以补码存储的，而题目要求负数以补码形式表示，且恰好正数的补码和原码是相同的，所以我们可以直接按位与然后移位即可。 易错的是，由于负数的补码第一位为1，如果我们把要比较的值按位右移，while (n != 0)永远成立不了，会进入死循环。 所以我们有两种思路： 1.不带符号位的右移 使用&gt;&gt;&gt;即可 12345678910111213public class Solution &#123; public int NumberOf1(int n) &#123; int flag = 1; int count = 0; while(n!=0)&#123; if((1 &amp; n) == 1)&#123; count++; &#125; n=n&gt;&gt;&gt;1; &#125; return count; &#125;&#125; 2.使用 n = n &amp; (n - 1); 举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。 12345678910public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; while(n!= 0)&#123; count++; n = n &amp; (n - 1); &#125; return count; &#125;&#125; 6.数值的整数次方给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 分析： 这题如果使用暴力的方法会超时，所以明显我们使用的是快速幂方法，其实也是获取二进制中1的个数，快速幂代码如下 123456789101112int pow3(int a,int b)&#123; int ans = 1,base = a; while(b!=0) &#123; if(b&amp;1) ans *= base; base *= base; b&gt;&gt;=1; &#125; return ans;&#125; 这里还要分情况讨论幂为负数的情况，总体代码如下： 12345678910111213141516171819202122232425public class Solution &#123; public double Power(double base, int exponent) &#123; //考虑指数为负 int flag = 0; if(exponent&lt;0)&#123; exponent=-exponent; flag=1; &#125; //快速幂 int res = 1; while(exponent!=0)&#123; if((exponent&amp;1)!=0)&#123; res*=base; base*=base; &#125; exponent=exponent&gt;&gt;1; &#125; //返回结果 if(flag==1)&#123; return 1.0/res; &#125;else&#123; return res; &#125; &#125;&#125; 7.栈的压入，弹出序列输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 分析： 定义一个新的栈，如果栈顶元素和应出栈的元素相同，则pop出来，否则将应该入栈的值入栈，最后判断栈是否为空 总之就是找到第一个出栈的元素4，判断之后的出栈序列是否是按入栈序列的顺序 代码： 1234567891011121314151617181920import java.util.ArrayList;import java.util.Stack;public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA==null || popA==null)&#123; return false; &#125; Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); int n = pushA.length; int index = 0; for(int i=0;i&lt;n;i++)&#123; s.push(pushA[i]); while(!s.empty()&amp;&amp;s.peek()==popA[index])&#123; s.pop(); index++; &#125; &#125; return s.isEmpty(); &#125;&#125; 8.二叉树层次遍历按二叉树的层次遍历输出二叉树 分析： 使用队列，每次取队列的顶部元素，将顶部元素的左子树，右子树依次入列，知道队列为空为止 代码： 123456789101112131415161718192021public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; res = new ArrayList(); ArrayList&lt;TreeNode&gt; queue = new ArrayList(); if(root==null)&#123; return res; &#125; queue.add(root); while(!queue.isEmpty())&#123; TreeNode node = queue.remove(0); if(node.left!=null)&#123; queue.add(node.left); &#125; if(node.right!=null)&#123; queue.add(node.right); &#125; res.add(node.val); &#125; return res; &#125;&#125; 9.快速排序https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485191&amp;idx=1&amp;sn=45a43bd77495566db53b419ae82136f5&amp;source=41#wechat_redirect 分析：首先将中心节点设为数组的起始节点，然后使用双指针，从数组的两边开始，左边遇到比数组大的元素，右边遇到比数组小的元素，则两者交换位置，双指针循环完毕后，将中心节点与右指针所在位置的节点互换，构成新的中心节点，然后递归调用quicksort方法即可 代码： 123456789101112131415161718192021222324252627static void quick_sort(int[] a) &#123; if(a.length&gt;0) quick_sort(a, 0 , a.length-1);&#125;static void quick_sort(int[] a, int low, int high) &#123; if(low &gt; high) return; int i = low; int j = high; int key = a[low]; while(i &lt; j) &#123; while(i &lt; j &amp;&amp; a[j] &gt; key) j--; while(i &lt; j &amp;&amp; a[i] &lt;= key) i++; if(i &lt; j) &#123; int p = a[i]; a[i] = a[j]; a[j] = p; &#125; &#125; int p = a[i]; a[i] = a[low]; a[low] = p; quick_sort(a,low,i - 1 ); quick_sort(a,i + 1,high); &#125; 10.顺时针打印矩阵分析： 从外部向内部逐层遍历打印矩阵，最外面一圈打印完，里面仍然是一个矩阵统计矩阵的层数，每一层最多会占据两行或者两列，最少会占据一行或者一列元素，只有一层或者一列，也算一层，分层如下图： 123int m = matrix.length;int n = matrix[0].length;int count = (Math.min(m, n)+1)/2; 开始打印第 i 层的矩阵元素 如上图所示，再打印第i层的矩阵时，要经历4个循环： 12345678910111213141516171819202122232425262728public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(matrix == null || matrix.length == 0) return list; int m = matrix.length; int n = matrix[0].length; int i = 0; //统计矩阵从外向内的层数，如果矩阵非空，那么它的层数至少为1层 int count = (Math.min(m, n)+1)/2; //从外部向内部遍历，逐层打印数据 while(i &lt; count) &#123; for (int j = i; j &lt;= n-i-1; j++) &#123; list.add(matrix[i][j]); &#125; for (int j = i+1; j &lt;= m-i-1; j++) &#123; list.add(matrix[j][(n-1)-i]); &#125; for (int j = (n-1)-(i+1); j &gt;= i &amp;&amp; (m-1-i != i); j--) &#123; list.add(matrix[(m-1)-i][j]); &#125; for (int j = (m-1)-(i+1); j &gt;= i+1 &amp;&amp; (n-1-i) != i; j--) &#123; list.add(matrix[j][i]); &#125; i++; &#125; return list;&#125; 11.二叉树中和尾某一值的路径输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 分析： 回溯法的经典例题，首先定义递归，递归的三个条件 终止条件 ：target=0且为叶子节点 问题逻辑：每次更新list，如果target=0，则将list插入结果中，否则回溯 子问题：FindPath(root.left, target); FindPath(root.right, target); 是否回溯：是 然后每次操作之后回溯操作，也就是本题中的list.remove(list.size()-1) 代码： 123456789101112131415public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root == null) return listAll; list.add(root.val); target -= root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) listAll.add(new ArrayList&lt;Integer&gt;(list)); FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size()-1); return listAll; &#125;&#125; 12.合并两个排序的链表输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则 分析： 子问题： 如果list1小于list2的值，list1.next 为Merge（list1.next，list2)，返回list1 如果list1大于list2的值，list2.next为Merge（list1，list2.next），返回list2 问题逻辑：list1.next = Merge(list1.next, list2); 终止条件：一方链表到达结尾，返回未到达结尾的那个节点 是否回溯：否 代码： 12345678910111213141516171819public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null)&#123; return list2; &#125; if(list2 == null)&#123; return list1; &#125; if(list1.val &lt;= list2.val)&#123; list1.next = Merge(list1.next, list2); return list1; &#125;else&#123; list2.next = Merge(list1, list2.next); return list2; &#125; &#125;&#125; 13.二叉搜索树的后续遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 分析： 子问题 ：由于是后续遍历，因此最后一个节点肯定是根节点，我们从后往前，寻找到第一个小于根节点的节点，以此节点为界，将树分为左子树和右子树。 问题逻辑：我们已经把同级的左子树划分出去了，接下来只要知道同级的右子树所有节点都比界节点i大即可，右子树最大的节点为倒数第二个节点。 终止条件：当树只剩下两个节点的时候，不管最后有没有比根节点大的节点，start&gt;=end都会成立，所以结束条件为start&gt;=end 是否回溯：否 代码： 12345678910111213141516171819202122232425262728public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence.length == 0)&#123; return false; &#125; if(sequence.length == 1)&#123; return true; &#125; return judge(sequence,0,sequence.length-1); &#125; public boolean judge(int[] a,int start,int end)&#123; if(start &gt;= end)&#123; return true; &#125; int i = start; while(a[i] &lt; a[end])&#123; ++i; &#125; for(int j=i;j&lt;end;j++)&#123; if(a[j] &lt; a[end])&#123; return false; &#125; &#125; return judge(a,start,i-1) &amp;&amp; judge(a,i,end-1); &#125;&#125; 14.树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 分析： 子问题：首先找到第一个相等的节点，然后判断两树是否有子结构关系，若无，则继续寻找下一个相等的节点，若有，则返回true 问题逻辑：首先将树不断分为左右两树，如果有一树根节点和B匹配上，则判断B是否事此树的子结构 终止条件：从A，B子树根节点相等的时候开始比较，如果B遍历完，A没遍历完，则返回True，A，B同时遍历完，也返回True，否则返回false 是否回溯：否 12345678910111213141516171819202122232425public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean result = false; if(root1 != null &amp;&amp; root2 != null)&#123; if(root1.val == root2.val)&#123; result = isAMother(root1,root2); &#125; if(!result)&#123;result = HasSubtree(root1.left, root2)||HasSubtree(root1.right, root2);&#125; &#125; return result; &#125; public boolean isAMother(TreeNode root1,TreeNode root2)&#123; if(root1==null &amp;&amp; root2!=null)&#123; return false; &#125; if(root2==null)&#123; return true; &#125; if(root1.val!=root2.val) return false; return isAMother(root1.left,root2.left) &amp;&amp; isAMother(root1.right,root2.right); &#125; &#125; 15.二叉搜索树和双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 分析： 子问题：将二叉树分为左右两个树，中序遍历 问题逻辑：首先肯定会获取到最左边的节点，然后我们定义两个指针，首先两个指针都指向最左边的节点，然后依次往上传递 终止条件：遍历完整个树 是否回溯：否 代码： 1234567891011121314151617181920212223//直接用中序遍历public class Solution &#123; TreeNode head = null; TreeNode realHead = null; public TreeNode Convert(TreeNode pRootOfTree) &#123; ConvertSub(pRootOfTree); return realHead; &#125; private void ConvertSub(TreeNode pRootOfTree) &#123; if(pRootOfTree==null) return; ConvertSub(pRootOfTree.left); if (head == null) &#123; head = pRootOfTree; realHead = pRootOfTree; &#125; else &#123; head.right = pRootOfTree; pRootOfTree.left = head; head = pRootOfTree; &#125; ConvertSub(pRootOfTree.right); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>求职</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的next主题个性化配置教程]]></title>
    <url>%2Fhexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[看到有些next主题的网站很炫酷，那么是怎么配置的呢？接下来我会讲一讲如何实现一些炫酷的效果 主要有以下33种： 在右上角或者左上角实现fork me on github 添加RSS 添加动态背景 实现点击出现桃心效果 修改文章内链接文本样式 修改文章底部的那个带#号的标签 在每篇文章末尾统一添加“本文结束”标记 修改作者头像并旋转 博文压缩 修改代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 在网站底部加上访问量 添加热度 网站底部字数统计 添加 README.md 文件 设置网站的图标Favicon 实现统计功能 添加顶部加载条 在文章底部增加版权信息 添加网易云跟帖(跟帖关闭，已失效，改为来必力) 隐藏网页底部powered By Hexo / 强力驱动 修改网页底部的桃心 文章加密访问 添加jiathis分享 博文置顶 修改字体大小 修改打赏字体不闪动 侧边栏推荐阅读 自定义鼠标样式 为博客加上萌萌的宠物 DaoVoice 在线联系 点击爆炸效果 1. 在右上角或者左上角实现fork me on github实现效果图 具体实现方法 点击这里或者这里挑选自己喜欢的样式，并复制代码。 例如，我是复制如下代码：然后粘贴刚才复制的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址 2.添加RSS实现效果图 具体实现方法 切换到你的blog（我是取名blog，具体的看你们的取名是什么）的路径，例如我是在/Users/chenzekun/Code/Hexo/blog这个路径上，也就是在你的根目录下 然后安装 Hexo 插件：(这个插件会放在node_modules这个文件夹里) 1$ npm install --save hexo-generator-feed 接下来打开画红线的文件，如下图： 在里面的末尾添加：(请注意在冒号后面要加一个空格，不然会发生错误！) 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 然后打开next主题文件夹里面的_config.yml,在里面配置为如下样子：(就是在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格) 1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 配置完之后运行： 1$ hexo g 重新生成一次，你会在./public 文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 3. 添加动态背景实现效果图 具体实现方法 这个我之前有一篇文章有讲过了，详情点击我的博客 4. 实现点击出现桃心效果实现效果图 具体实现方法 在网址输入如下 1http://7u2ss1.com1.z0.glb.clouddn.com/love.js 然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout\_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 5. 修改文章内链接文本样式实现效果图 具体实现方法 修改文件 themes\next\source\css\_common\components\post\post.styl，在末尾添加如下css样式，： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中选择.post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 6. 修改文章底部的那个带#号的标签实现效果图 具体实现方法 修改模板/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 7. 在每篇文章末尾统一添加“本文结束”标记实现效果图 具体实现方法 在路径 \themes\next\layout\_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 接着打开\themes\next\layout\_macro\post.swig文件，在post-body 之后， post-footer 之前添加如下画红色部分代码（post-footer之前两个DIV）： 代码如下： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 然后打开主题配置文件（_config.yml),在末尾添加： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加如上效果图的样子。 8. 修改作者头像并旋转实现效果图 具体实现方法 打开\themes\next\source\css\_common\components\sidebar\sidebar-author.styl，在里面添加如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 9. 博文压缩在站点的根目录下执行以下命令： 12$ npm install gulp -g$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save 在如下图所示，新建 gulpfile.js ，并填入以下内容： 123456789101112131415161718192021222324252627282930313233var gulp = require(&apos;gulp&apos;);var minifycss = require(&apos;gulp-minify-css&apos;);var uglify = require(&apos;gulp-uglify&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;);var htmlclean = require(&apos;gulp-htmlclean&apos;);// 压缩 public 目录 cssgulp.task(&apos;minify-css&apos;, function() &#123; return gulp.src(&apos;./public/**/*.css&apos;) .pipe(minifycss()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 压缩 public 目录 htmlgulp.task(&apos;minify-html&apos;, function() &#123; return gulp.src(&apos;./public/**/*.html&apos;) .pipe(htmlclean()) .pipe(htmlmin(&#123; removeComments: true, minifyJS: true, minifyCSS: true, minifyURLs: true, &#125;)) .pipe(gulp.dest(&apos;./public&apos;))&#125;);// 压缩 public/js 目录 jsgulp.task(&apos;minify-js&apos;, function() &#123; return gulp.src(&apos;./public/**/*.js&apos;) .pipe(uglify()) .pipe(gulp.dest(&apos;./public&apos;));&#125;);// 执行 gulp 命令时执行的任务gulp.task(&apos;default&apos;, [ &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;]); 生成博文是执行 hexo g &amp;&amp; gulp 就会根据 gulpfile.js 中的配置，对 public 目录中的静态资源文件进行压缩。 10. 修改代码块自定义样式实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入：(颜色可以自己定义) 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 11. 侧边栏社交小图标设置实现效果图 具体实现方法 打开主题配置文件（_config.yml），搜索social_icons:,在图标库找自己喜欢的小图标，并将名字复制在如下位置，保存即可 12. 主页文章添加阴影效果实现效果图 具体实现方法 打开\themes\next\source\css\_custom\custom.styl,向里面加入： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 13. 在网站底部加上访问量实现效果图 具体实现方法打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上画红线这句话： 代码如下： 1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图：代码如下： 12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 添加之后再执行hexo d -g，然后再刷新页面就能看到效果 14. 添加热度实现效果图 具体实现方法 next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig,在画红线的区域添加℃： 然后打开，/themes/next/languages/zh-Hans.yml,将画红框的改为热度就可以了 15. 网站底部字数统计实现效果图 具体方法实现切换到根目录下，然后运行如下代码 1$ npm install hexo-wordcount --save 然后在/themes/next/layout/_partials/footer.swig文件尾部加上： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 16. 添加 README.md 文件每个项目下一般都有一个 README.md 文件，但是使用 hexo 部署到仓库后，项目下是没有 README.md 文件的。 在 Hexo 目录下的 source 根目录下添加一个 README.md 文件，修改站点配置文件 _config.yml，将 skip_render 参数的值设置为 1skip_render: README.md 保存退出即可。再次使用 hexo d 命令部署博客的时候就不会在渲染 README.md 这个文件了。 17. 设置网站的图标Favicon实现效果图 具体方法实现 在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为favicon.ico，然后把图标放在/themes/next/source/images里，并且修改主题配置文件： 12# Put your favicon.ico into `hexo-site/source/` directory.favicon: /favicon.ico 18. 实现统计功能实现效果图 具体实现方法 在根目录下安装 hexo-wordcount,运行： 1$ npm install hexo-wordcount --save 然后在主题的配置文件中，配置如下： 123456# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true 19. 添加顶部加载条实现效果图 具体实现方法 打开/themes/next/layout/_partials/head.swig文件，添加红框上的代码代码如下： 12&lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt;&lt;link href=&quot;//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css&quot; rel=&quot;stylesheet&quot;&gt; 但是，默认的是粉色的，要改变颜色可以在/themes/next/layout/_partials/head.swig文件中添加如下代码（接在刚才link的后面） 12345678910111213&lt;style&gt; .pace .pace-progress &#123; background: #1E92FB; /*进度条颜色*/ height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/ &#125; .pace .pace-activity &#123; border-top-color: #1E92FB; /*上边框颜色*/ border-left-color: #1E92FB; /*左边框颜色*/ &#125;&lt;/style&gt; 目前，博主的增加顶部加载条的pull request 已被Merge😀===&gt;详情现在升级最新版的next主题，升级后只需修改主题配置文件(_config.yml)将pace: false改为pace: true就行了，你还可以换不同样式的加载条，如下图： 20. 在文章底部增加版权信息实现效果图 在目录 next/layout/_macro/下添加 my-copyright.swig： 123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:mm&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:mm&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录next/source/css/_common/components/post/下添加my-post-copyright.styl： 123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改next/layout/_macro/post.swig，在代码 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;wechat-subscriber.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 之前添加增加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;my-copyright.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 如下： 修改next/source/css/_common/components/post/post.styl文件，在最后一行增加代码： 1@import &quot;my-post-copyright&quot; 保存重新生成即可。如果要在该博文下面增加版权信息的显示，需要在 Markdown 中增加copyright: true的设置，类似： 小技巧：如果你觉得每次都要输入copyright: true很麻烦的话,那么在/scaffolds/post.md文件中添加：这样每次hexo new &quot;你的内容&quot;之后，生成的md文件会自动把copyright:加到里面去(注意：如果解析出来之后，你的原始链接有问题：如：http://yoursite.com/前端小项目：使用canvas绘画哆啦A梦.html,那么在根目录下_config.yml中写成类似这样：）就行了。 21. 添加网易云跟帖(跟帖关闭，已失效，改为来必力)实现效果图 具体方法实现有两种实现方法：①更新next主题，因为最新版本的主题已经支持这种评论。直接在主题配置文件_config.yml 文件中添加如下配置: 1gentie_productKey: #your-gentie-product-key ②如果你不想更新的话，那么按下面步骤进行：首先，还是在主题配置文件_config.yml 文件中添加如下配置: 1gentie_productKey: #your-gentie-product-key 你的productKey就是下面画红线部分 然后在在layout/_scripts/third-party/comments/ 目录中添加 gentie.swig，文件内容如下： 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id %&#125; &#123;% if theme.gentie_productKey %&#125; &#123;% set gentie_productKey = theme.gentie_productKey %&#125; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: &quot;&quot;, productKey: &quot;&#123;&#123;gentie_productKey&#125;&#125;&quot;, target: &quot;cloud-tie-wrapper&quot; &#125;; &lt;/script&gt; &lt;script src=&quot;https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js&quot;&gt;&lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include &apos;./comments/gentie.swig&apos; %&#125; 最后，在 layout/_partials/comments.swig 文件中条件最后追加网易云跟帖插件引用的判断逻辑： 123&#123;% elseif theme.gentie_productKey %&#125; &lt;div id=&quot;cloud-tie-wrapper&quot; class=&quot;cloud-tie-wrapper&quot;&gt; &lt;/div&gt; 具体位置如下： 可能你hexo s时可能看不到，直接hexo d就可以看到了 近日，我朋友发来消息，说网易云跟帖要关了，我网上查了一下，果然如此 😭都是泪,上次用了多说，结果多说关了，接着是网易云跟帖😷，这次直接用国外的来必力，应该不会这么容易关吧😏 方法其实还是跟上面差不多的 首先在 _config.yml 文件中添加如下配置：(注意！如果主题是最新版的，直接写你的liver_uid就行了) 123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: your uid 其中，livere_uid就是画红线的部分 然后在 layout/_scripts/third-party/comments/ 目录中添加 livere.swig，文件内容如下： 1234567891011121314&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.livere_uid %&#125; &lt;script type=&quot;text/javascript&quot;&gt; (function(d, s) &#123; var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &apos;function&apos;) &#123; return; &#125; j = d.createElement(s); j.src = &apos;https://cdn-city.livere.com/js/embed.dist.js&apos;; j.async = true; e.parentNode.insertBefore(j, e); &#125;)(document, &apos;script&apos;); &lt;/script&gt; &#123;% endif %&#125;&#123;% endif %&#125; 然后在 layout/_scripts/third-party/comments.swig文件中追加： 1&#123;% include &apos;./comments/livere.swig&apos; %&#125; 最后，在 layout/_partials/comments.swig 文件中条件最后追加 LiveRe 插件是否引用的判断逻辑： 123&#123;% elseif theme.livere_uid %&#125; &lt;div id=&quot;lv-container&quot; data-id=&quot;city&quot; data-uid=&quot;&#123;&#123; theme.livere_uid &#125;&#125;&quot;&gt;&lt;/div&gt;&#123;% endif %&#125; 完 22. 隐藏网页底部powered By Hexo / 强力驱动打开themes/next/layout/_partials/footer.swig,使用””隐藏之间的代码即可，或者直接删除。位置如图： 23. 修改网页底部的桃心还是打开themes/next/layout/_partials/footer.swig，找到：，然后还是在图标库中找到你自己喜欢的图标，然后修改画红线的部分就可以了。 24. 文章加密访问实现效果图 具体实现方法 打开themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件,在以下位置插入这样一段代码： 代码如下： 1234567891011121314&lt;script&gt; (function () &#123; if (&apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123; if (prompt(&apos;请输入文章密码&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;) &#123; alert(&apos;密码错误！&apos;); if (history.length === 1) &#123; location.replace(&quot;http://xxxxxxx.xxx&quot;); // 这里替换成你的首页 &#125; else &#123; history.back(); &#125; &#125; &#125; &#125;)();&lt;/script&gt; 然后在文章上写成类似这样： 25. 添加jiathis分享 注意：JiaThis 不支持 https 在主题配置文件中，JiaThis为true，就行了，如下图 默认是这样子的：如果你想自定义话，打开themes/next/layout/_partials/share/jiathis.swig修改画红线部分就可以了 26. 博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加 top 值，数值越大文章越靠前，如 12345678---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 27. 修改字体大小打开\themes\next\source\css\ _variables\base.styl文件，将$font-size-base改成16px，如下所示： 1$font-size-base =16px 28. 修改打赏字体不闪动修改文件next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数wechat:hover和alipay:hover，如下： 123456789101112/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 29. 侧边栏推荐阅读今天有位网友问推荐阅读是怎么弄，其实挺简单的，打开主题配置文件修改成这样就行了(links里面写你想要的链接): 1234567891011# Blogrollslinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: 优设: http://www.uisdc.com/ 张鑫旭: http://www.zhangxinxu.com/ Web前端导航: http://www.alloyteam.com/nav/ 前端书籍资料: http://www.36zhen.com/t?id=3448 百度前端技术学院: http://ife.baidu.com/ google前端开发基础: http://wf.uisdc.com/cn/ 30. 自定义鼠标样式打开themes/next/source/css/_custom/custom.styl,在里面写下如下代码 1234567// 鼠标样式 * &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important &#125; :active &#123; cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important &#125; 其中 url 里面必须是 ico 图片，ico 图片可以上传到网上（我是使用七牛云图床），然后获取外链，复制到 url 里就行了 31.为博客加上萌萌的宠物实现效果图 具体实现方法在终端切换到你的博客的路径里，然后输入如下代码： 1npm install -save hexo-helper-live2d 然后打开Hexo/blog/themes/next/layout的_layout.swig,将下面代码放到&lt;/body&gt;之前： (注意，由于官方更新了包，所以画删除线的不用弄) 然后在在 hexo 的 _config.yml中添加参数：（具体配置可以看官方文档） 1234567891011121314live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true 然后hexo clean ，hexo g ，hexo d 就可以看到了。 注意！如果你在 hexo d 的时候出现我下面这个问题你可以这样，首先删除hexo 下面的.deploy_git文件夹，然后运行 1git config --global core.autocrlf false 重新 hexo clean,hexo g,hexo d就行了 32.DaoVoice 在线联系实现效果图 具体实现方法 首先在 daovoice 注册账号,邀请码是0f81ff2f，注册完成后会得到一个 app_id : 记下这个 app_id的值，然后打开/themes/next/layout/_partials/head.swig,写下如下代码： 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 接着打开主题配置文件，在最后写下如下代码： 1234# Online contact daovoice: truedaovoice_app_id: 这里填你的刚才获得的 app_id 重新 hexo g ，hexo s 就能看到效果了。 安装成功后可以在DaoVoice 控制台上的聊天设置里设置聊天窗口样式，附上我的设置 33.点击爆炸效果实现效果图 实现方法 跟那个红心是差不多的，首先在themes/next/source/js/src里面建一个叫fireworks.js的文件，代码如下： 1&quot;use strict&quot;;function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;vart=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;functioncreateParticule(e,t)&#123;var a=&#123;&#125;;returna.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;returna.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;functionrenderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(vara=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;returne.endPos.x&#125;,y:function(e)&#123;returne.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;vara;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;varctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;functionupdateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;vart=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;functioncreateParticule(e,t)&#123;var a=&#123;&#125;;returna.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;returna.x=e,a.y=t,a.color=&quot;#F00&quot;,a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;functionrenderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(vara=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;returne.endPos.x&#125;,y:function(e)&#123;returne.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;vara;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;varctx=canvasEl.getContext(&quot;2d&quot;),numberOfParticules=30,pointerX=0,pointerY=0,tap=&quot;mousedown&quot;,colors=[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+&quot;px&quot;,canvasEl.style.height=window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!==e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!==e.target.id&amp;&amp;&quot;A&quot;!==e.target.nodeName&amp;&amp;&quot;IMG&quot;!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;; 打开themes/next/layout/_layout.swig,在&lt;/body&gt;上面写下如下代码： 12345&#123;% if theme.fireworks %&#125; &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/fireworks.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 打开主题配置文件，在里面最后写下： 12# Fireworksfireworks: true 完😀 致谢 感谢大神们的文章，真的学到了许多，有些忘了记录下来，在这里由衷的感谢。虽然比较折腾，但是确实满满的成就感，Road endless its long and far, I will seek up and down！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</url>
    <content type="text"><![CDATA[二分查找多次刷题时遇到，虽然每次也能写对，但花了蛮多时间，没好好想过。而且网上的太多版本，并不是很简洁，而且边界条件变化情况太多，容易混淆，下面是自己对二分查找的一些思考和总结，尽量写得简单易懂。 小技巧： 优化二维数组查找时间复杂度：使用[n/column] [n%column]来表示行数和列数，避免双重循环 遍历两个数组：使用双指针，每次判断前进哪个指针 搜索问题中，如果有相同的两个元素，则必须要用O(n)的时间复杂度（例：全是2的数组） 三步翻转法：题目描述:给定一个字符串，要求把字符串前面的若干个字符移动到字符串的尾部，如把字符串“abcdef”前面的2个字符’a’和’b’移动到字符串的尾部，使得原字符串变成字符串“cdefab”。请写一个函数完成此功能，要求对长度为n的字符串操作的时间复杂度为 O(n)，空间复杂度为 O(1)。 三步反转法对于这个问题，换一个角度思考一下。 将一个字符串分成X和Y两个部分，在每部分字符串上定义反转操作，如X^T，即把X的所有字符反转（如，X=”abc”，那么X^T=”cba”），那么就得到下面的结论：(X^TY^T)^T=YX，显然就解决了字符串的反转问题。 例如，字符串 abcdef ，若要让def翻转到abc的前头，只要按照下述3个步骤操作即可： 首先将原字符串分为两个部分，即X:abc，Y:def；将X反转，X-&gt;X^T，即得：abc-&gt;cba；将Y反转，Y-&gt;Y^T，即得：def-&gt;fed。反转上述步骤得到的结果字符串X^TY^T，即反转字符串cbafed的两部分（cba和fed）给予反转，cbafed得到defabc，形式化表示为(X^TY^T)^T=YX，这就实现了整个反转。 代码： 1234567891011121314151617void ReverseString(char* s,int from,int to)&#123; while (from &lt; to) &#123; char t = s[from]; s[from++] = s[to]; s[to--] = t; &#125;&#125;void LeftRotateString(char* s,int n,int m)&#123; m %= n; //若要左移动大于n位，那么和%n 是等价的 ReverseString(s, 0, m - 1); //反转[0..m - 1]，套用到上面举的例子中，就是X-&gt;X^T，即 abc-&gt;cba ReverseString(s, m, n - 1); //反转[m..n - 1]，例如Y-&gt;Y^T，即 def-&gt;fed ReverseString(s, 0, n - 1); //反转[0..n - 1]，即如整个反转，(X^TY^T)^T=YX，即 cbafed-&gt;defabc。&#125; 基本二分查找：二分查找原始版–查找某个数的下标： 对于一个sorted array分以下几步： 输入数组为空或者NULL while(s+1&lt;e)，s为开始下标，e为结束下标减一 (nums.size()-1) 先考虑边界情况，再缩小搜索区间 这样可以把最后得到的元素缩减至两个，最后做判断 如果是判断最后一个O元素，则先判断nums[e]是不是等于target， 如果是判断第一个X元素，则先判断nums[s]是不是等于target 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: /** * @param nums: The integer array. * @param target: Target to find. * @return: The first position of target. Position starts from 0. */ int binarySearch(vector&lt;int&gt; &amp;nums, int target) &#123; // write your code here int s=0; int e=nums.size()-1; if(nums.size() == 0)&#123; return -1; &#125; while(s+1&lt;e)&#123; int mid = s+(e-s)/2; //防止越界 if(nums[mid] == target)&#123; e = mid; &#125; else if(nums[mid] &gt; target)&#123; e = mid; &#125; else&#123; s = mid; &#125; &#125; if(nums[s] == target)&#123; return s; &#125; if(nums[e] == target)&#123; return e; &#125; return -1; &#125; &#125;; 拓展题型：0.未定长度型，搜索特定值 描述：给定一个排序数组，未给定最大长度，搜索其中的一个值 分析：通过倍增法，不断的扩大区间，求出搜索范围，再进行二分 1.OOOXXX型，寻找分界点 https://www.lintcode.com/problem/first-bad-version/description 描述：代码库的版本号是从 1 到 n 的整数。某一天，有人提交了错误版本的代码，因此造成自身及之后版本的代码在单元测试中均出错。请找出第一个错误的版本号。 你可以通过 isBadVersion 的接口来判断版本号 version 是否在单元测试中出错，具体接口详情和调用方法请见代码的注释部分。 分析：转换成求最后一个O或者是第一个X，使用二分法查找 2.旋转数组型，寻找分界点 https://www.lintcode.com/problem/find-minimum-in-rotated-sorted-array/ 描述：假设一个排好序的数组在其某一未知点发生了旋转（比如0 1 2 4 5 6 7可能在第3和第4个元素间发生旋转变成4 5 6 7 0 1 2）。 你需要找到其中最小的元素。 你可以假设数组中不存在重复的元素。 分析：一开始想转换成求大于A的第一个点或者是小于B的最后一个点，使用二分法查找，后来发现，当数组处于特殊情况时，例如数组是从A到B递增时，不存在小于A的点，所以选择找&lt;=B的最后一个点。 3.搜索二维矩阵中的最小值 https://www.lintcode.com/problem/search-a-2d-matrix/description 描述：写出一个高效的算法来搜索 m × n矩阵中的值。 这个矩阵具有以下特性： 每行中的整数从左到右是排序的。 每行的第一个数大于上一行的最后一个整数。 分析：搜索二维数组的时候，可以计算出这个二维数组的总长度，然后用 [n/column] [n%column]来表示行数和列数，间接的减小时间复杂度。 4.搜索波峰 https://www.lintcode.com/problem/find-peak-element/description 描述：你给出一个整数数组(size为n)，其具有以下特点： 相邻位置的数字是不同的 A[0] &lt; A[1] 并且 A[n - 2] &gt; A[n - 1] 假定P是峰值的位置则满足A[P] &gt; A[P-1]且A[P] &gt; A[P+1]，返回数组中任意一个峰值的位置。 分析：搜索波峰时，比较a[n]和a[n+1]之间的大小关系，判断是在走上坡还是下坡还是在波峰，从而判断波峰是在左边还是右边，从而缩小范围 5.旋转数组型，寻找特定值 描述：假设有一个排序的按未知的旋转轴旋转的数组(比如，0 1 2 4 5 6 7 可能成为4 5 6 7 0 1 2)。给定一个目标值进行搜索，如果在数组中找到目标值返回数组中的索引位置，否则返回-1。 你可以假设数组中不存在重复的元素。 分析：先切一刀，找到mid，判断target是否在 s~m 区间内， 如果在，则设置e=mid，在此区间内使用二分法查找， 如果不在，由于剩下的还是一个Rotated array，我们可以定义s=mid，进行查找 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;public: /** * @param A: an integer rotated sorted array * @param target: an integer to be searched * @return: an integer */ int search(vector&lt;int&gt; &amp;A, int target) &#123; // write your code here int s=0; int e=A.size()-1; int mid; if(e==-1) &#123; return -1; &#125; while(s+1&lt;e)&#123; mid = s+(e-s)/2; if(A[mid]==target)&#123; return mid; &#125; if(A[s]&lt;A[mid])&#123; if(target&gt;=A[s]&amp;&amp;target&lt;=A[mid])&#123; e=mid; &#125;else&#123; s=mid; &#125; &#125; else&#123; if(target&gt;=A[mid]&amp;&amp;target&lt;=A[e])&#123; s=mid; &#125;else&#123; e=mid; &#125; &#125; &#125; if(A[s]==target) return s; if(A[e]==target) return e; return -1; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LintCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划小结]]></title>
    <url>%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%B0%8F%E7%BB%93_new.html</url>
    <content type="text"><![CDATA[动态规划的四个组成部分： 动态规划和递归效率的比较： 如图所示，递归会重复计算，效率极差： 例题：Unique path 1.初始化： 初始化数组大小： 从0开始，一般为坐标型，建立一个n大小的数组，从0开始遍历。 从1开始，一般为坐标型，建立一个n+1大小的数组，从1开始遍历 初始化起始位置： 如果是序列型，n代表前n项，循环则从1开始 如果是坐标型，n代表对应位置的坐标，循环由0开始。 初始化每个元素： 无法走到的地方最一开始都初始化为0。 求最值型动态规划：DP[0]一般初始化为0， 其他位置：求最小值时初始化为MAX，求最大值初始化为MIN等… 求有多少种方法型动态规划：DP[0]一般初始化为1 初始化初始值：最一开始的地方有一种走法，dp[0] [0]定义为1 2.状态转移：当行走过程中有障碍物的情况下，定义边界情况为第一行或者第一列为1是不成立的，因为障碍物的行走方式永远是0，所以这题我们还可以采用一种更通用的方法： 12345678910for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(i&gt;0)&#123; dp[i][j]+=dp[i-1][j]; &#125; if(j&gt;0)&#123; dp[i][j]+=dp[i][j-1]; &#125; &#125;&#125; 3.边界情况考虑：考虑到不可到达的时候初始化为多少，什么情况下发生状态转移（例如有三种钱币，f[j]=min{f[i-a[1]],f[i-a[2]]} 求最小值） 123if(j!=k &amp;&amp; dp[i-1][k]+costs[i-1][j]&lt;dp[i][j])&#123; dp[i][j]=dp[i-1][k]+costs[i-1][j];&#125; 4.返回值问题：需要注意的是最后return的是dp[n-1] [m-1]，因为这个坐标型动态规划坐标就代表实际的位置，而数组是从0开始的，所以index为数组长度-1 5.空间复杂度优化：如果这一项只和前几项有关，则可以用滚动数组优化空间复杂度，滚动数组大小不仅限于2，如图： Coin change Paint-House这里有n个房子在一列直线上，现在我们需要给房屋染色，分别有红色蓝色和绿色。每个房屋染不同的颜色费用也不同，你需要设计一种染色方案使得相邻的房屋颜色不同，并且费用最小，返回最小的费用。 费用通过一个nx3 的矩阵给出，比如cost[0][0]表示房屋0染红色的费用，cost[1][2]表示房屋1染绿色的费用。 1234567891011121314151617181920212223242526272829class Solution &#123;public: /** * @param costs: n x 3 cost matrix * @return: An integer, the minimum cost to paint all houses */ int minCost(vector&lt;vector&lt;int&gt;&gt; &amp;costs) &#123; // write your code here int n = costs.size(); int dp[n+1][3]; dp[0][0]=dp[0][1]=dp[0][2]=0; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;3;j++)&#123; dp[i][j]=9999999; for(int k=0;k&lt;3;k++)&#123; if(j!=k &amp;&amp; dp[i-1][k]+costs[i-1][j]&lt;dp[i][j])&#123; dp[i][j]=dp[i-1][k]+costs[i-1][j]; &#125; &#125; &#125; &#125; long long res=dp[n][0]; if(dp[n][1]&lt;res) res = dp[n][1]; if(dp[n][2]&lt;res) res = dp[n][2]; return res; &#125;&#125;;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git合并多个commit]]></title>
    <url>%2FGit%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AAcommit.html</url>
    <content type="text"><![CDATA[「Git」合并多个 Commit 在使用 Git 作为版本控制的时候，我们可能会由于各种各样的原因提交了许多临时的 commit，而这些 commit 拼接起来才是完整的任务。那么我们为了避免太多的 commit 而造成版本控制的混乱，通常我们推荐将这些 commit 合并成一个。 首先假设我们有3个 commit git-log-origin.png 我们需要将 2dfbc7e8 和 c4e858b5 合并成一个 commit，那么我们输入如下命令 git-rebase-i.png 其中，-i 的参数是不需要合并的 commit 的 hash 值，这里指的是第一条 commit， 接着我们就进入到 vi 的编辑模式 git-rebase-edit.png 可以看到其中分为两个部分，上方未注释的部分是填写要执行的指令，而下方注释的部分则是指令的提示说明。指令部分中由前方的命令名称、commit hash 和 commit message 组成。 当前我们只要知道 pick 和 squash 这两个命令即可。 pick 的意思是要会执行这个 commit squash 的意思是这个 commit 会被合并到前一个commit 我们将 c4e858b5 这个 commit 前方的命令改成 squash 或 s，然后输入:wq以保存并退出 git-rebase-squash.png 这是我们会看到 commit message 的编辑界面 git-rebase-commit-message.png 其中, 非注释部分就是两次的 commit message, 你要做的就是将这两个修改成新的 commit message。 git-rebase-commit-message-combination.png 输入wq保存并推出, 再次输入git log查看 commit 历史信息，你会发现这两个 commit 已经合并了。 git-rebase-log-new.png 注意事项：如果这个过程中有操作错误，可以使用 git rebase --abort来撤销修改，回到没有开始操作合并之前的状态。 转自简书：https://www.jianshu.com/p/964de879904a]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git如何回滚错误的提交]]></title>
    <url>%2FGit%E5%A6%82%E4%BD%95%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E6%8F%90%E4%BA%A4.html</url>
    <content type="text"><![CDATA[Git如何回滚一次错误的合并转自掘金：Git如何回滚一次错误的合并 原文发表在知乎专栏 前端杂货铺, 欢迎关注我的专栏，转载请注明出处 今天不说前端，来聊聊git吧。 发现现在的小孩，玩框架一套一套的，等到玩点实质的工程化的东西就不行了。 git 这么好的工具，培训班怎么可以忽视他的重要性呢？ 再来聊聊git的工作流程很多人对Git究竟是一个怎样的系统，还是一知半解。 在这里强烈建议大家先理解git的核心思想和工作原理，有过subversion或者perforce使用经验的人更是需要摒弃之前所见所学，重新接受这样一个新思想。 我们不再这里赘述其几本原理，我们来介绍一下其简单工作流程。 Git以一个自有的思维框架管理着三个不同的盒子Commit History、INDEX、Working Directory。 Commit History 历史记录，存储着所有提交的版本快照，并由当前分支引用的指针HEAD指向该分支最新一条提交。 INDEX 索引，也叫暂存区域。它是一个文件，保存着即将提交的文件列表快照。 Working Directory 工作目录，是从git仓库压缩数据当前版本中解包出来的文件列表。所以你在本地磁盘看到的你项目源码的文件列表，其实就是git开放给你的一个沙盒。在你将文件的修改天道到暂存区域并将快照记录到历史之前，你可以随意更改。 理解了这三者的含义后，我们试着来理解一下git的工作流程。 一切的开始，混沌之间，我们要干一件大事，在terminal里面敲打了几下键盘 wiki12git init 复制代码 混沌初开，幻化三界：HEAD、INDEX、Working Directory。这就是世界最开始的样子git仓库仿佛就是掌管三界之神。而Working Directory就是他分配给你生产和工作的地方，你可以在这里肆意的创造。而为了安全和管理的有序我们需要把我们的添加与修改的文件交给git仓库。Git首先会将修改的文件标记起来放入暂存区、然后git找到暂存区域的文件内容将其永久性的存储为快照到git仓库，此时HEAD的指针指向这个最新的快照。 如图，总结下三个步骤 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。git add 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录 git commit git 的基本工作流程就是在不断的重复这三个步骤,最终git仓库目录形成了一个快照堆栈，每产生一次新的版本，HEAD就会指向这个版本。 这里我们创建了下面这些文件： 123456├── README.md├── v1.js├── v2.js└── v3.js复制代码 形成了下图的提交历史 1234567893aa5dfb v3 (&lt;- HEAD) |5aab391 v2 |ff7b88e v1 |95d7816 init commit复制代码 下面我们来看看怎么利用checkout、reset、revert 来操作这个仓库目录 checkout 、reset 还是 revert ？checkout版本控制系统背后的思想就是「安全」地储存项目的拷贝，这样你永远不用担心什么时候不可复原地破坏了你的代码库。当你建立了项目历史之后，git checkout 是一种便捷的方式，来将保存的快照「解包」到你的工作目录上去。 git checkout 可以检出提交、也可以检出单个文件甚至还可以检出分支(此处省略)。 12git checkout 5aab391复制代码 检出v2,当前工作目录和5aab391完全一致，你可以查看这个版本的文件编辑、运行、测试都不会被保存到git仓库里面。你可以git checkout master 或者 git checkout -回到原来的工作状态上来。 12git checkout 5aab391 v1.js复制代码 以检出v2版本对于v1.js的改动，只针对v1.js这个文件检出到5aab391版本。所以 它会影响你当前的工作状态，它会把当前状态的v1.js文件内容覆盖为5aab391版本。所以除非你清楚你在做什么，最好不要轻易的做这个操作。但这个操作对于舍弃我当前的所有改动很有用：比如当前我在v1.js上面做了一些改动，但我又不想要这些改动了，而我又不想一个个去还原，那么我可以git checkout HEAD v1.js 或者 git checkout -- v1.js reset 重置和 git checkout 一样, git reset 有很多用法。 12git reset &lt;file&gt;复制代码 从暂存区移除特定文件，但不改变工作目录。它会取消这个文件的缓存，而不覆盖任何更改。 12git reset复制代码 重置暂存区，匹配最近的一次提交，但工作目录不变。它会取消所有文件的暂存，而不会覆盖任何修改，给你了一个重设暂存快照的机会。 12git reset --hard复制代码 加上--hard标记后会告诉git要重置缓存区和工作目录的更改，就是说：先将你的暂存区清除掉，然后将你所有未暂存的更改都清除掉，所以在使用前确定你想扔掉所有的本地工作。 12git reset &lt;commit&gt;复制代码 将当前分支的指针HEAD移到 ，将缓存区重设到这个提交，但不改变工作目录。所有 之后的更改会保留在工作目录中，这允许你用更干净、原子性的快照重新提交项目历史。 12git reset --hard &lt;commit&gt;复制代码 将当前分支的指针HEAD移到 ，将缓存区和工作目录都重设到这个提交。它不仅清除了未提交的更改，同时还清除了 之后的所有提交。 可以看出，git reset 通过取消缓存或者取消一系列提交的操作会摒弃一些你当前工作目录上的更改，这样的操作带有一定的危险性。下面我们开始介绍一种相对稳妥的方式 revert revert 撤销git revert被用来撤销一个已经提交的快照。但实现上和reset是完全不同的。通过搞清楚如何撤销这个提交引入的更改，然后在最后加上一个撤销了更改的 新 提交，而不是从项目历史中移除这个提交。 12git revert &lt;commit&gt;复制代码 生成一个撤消了 引入的修改的新提交，然后应用到当前分支。 例如： 1234567891011121381f734d commit after bug |3a395af bug |3aa5dfb v3 (&lt;- HEAD) |5aab391 v2 |ff7b88e v1 |95d7816 init commit复制代码 我们在3a395af 引入了一个bug，我们明确是由于3a395af造成的bug的时候，以其我们通过新的提交来fix这个bug，不如git revert, 让他来帮你剔除这个bug。 12git revert 3a395af复制代码 得到结果 123456789101112131415cfb71fc Revert &quot;bug&quot; |81f734d commit after bug |3a395af bug |3aa5dfb v3 (&lt;- HEAD) |5aab391 v2 |ff7b88e v1 |95d7816 init commit复制代码 这个时候bug的改动被撤销了，产生了一个新的commit，但是commit after bug没有被清初。 所以相较于reset ，revert不会改变项目历史，对那些已经发布到共享仓库的提交来说这是一个安全的操作。其次git revert可以将提交历史中的任何一个提交撤销、而reset会把历史上某个提交及之后所有的提交都移除掉，这太野蛮了。 另外revert的设计，还有一个考量，那就是撤销一个公共仓库的提交。至于为什么不能用reset，你们可以自己思考一下。 下面我们就用一个麻烦事（回滚一个错误的合并），来讲解这个操作。 合并操作相对于常规的commit，当使用git merge &lt;branch&gt;合并两个分支的时候，你会得到一个新的merge commit. 当我们git show &lt;commit&gt;的时候会出现类似信息： 12345commit 6dd0e2b9398ca8cd12bfd1faa1531d86dc41021aMerge: d24d3b4 11a7112Author: 前端杂货铺 ...............复制代码 Merge: d24d3b4 11a7112 这行表明了两个分支在合并时，所处的parent的版本线索。 比如在上述项目中我们开出了一个dev分支并做了一些操作，现在分支的样子变成了这样： 1234init -&gt; v1 -&gt; v2 -&gt; v3 (master) \ d1 -&gt; d2 (dev)复制代码 当我们在dev开发的差不多了 12345#git:(dev)git checkout master #git:(master)git merge dev复制代码 这个时候形成了一个Merge Commit faulty merge 1234init -&gt; v1 -&gt; v2 -&gt; v3 -- faulty merge (master) \ / d1 --&gt; d2 (dev)复制代码 此时faulty merge有两个parent 分别是v3 和 d2。 回滚错误的合并这个merge之后还继续在dev开发，另一波人也在从别的分支往master合并代码。变成这样： 123456init -&gt; v1 -&gt; v2 -&gt; v3 -- faulty merge -&gt; v4 -&gt; vc3 (master) \ \ / / \ d1 --&gt; d2 --&gt; d3 --&gt; d4 (dev)/ \ / c1 --&gt; c2 -------------------c3 (other)复制代码 这个时候你发现， 妈也上次那个merge 好像给共享分支master引入了一个bug。这个bug导致团队其他同学跑不通测试，或者这是一个线上的bug，如果不及时修复老板要骂街了。 这个时候第一想到的肯定是回滚代码，但怎么回滚呢。用reset?不现实，因为太流氓不说，还会把别人的代码也干掉，所以只能用revert。而revert它最初被设计出来就是干这个活的。 怎么操作呢？首先想到的是上面所说的 git revert &lt;commit&gt; ,但是貌似不太行。 1234git revert faulty mergeerror: Commit faulty merge is a merge but no -m option was given.fatal: revert failed复制代码 这是因为试图撤销两个分支的合并的时候Git不知道要保留哪一个分支上的修改。所以我们需要告诉git我们保留那个分支m 或者mainline. 12git revert -m 1 faulty merge复制代码 -m后面带的参数值 可以是1或者2，对应着parent的顺序.上面列子：1代表v3，2代表d2 所以该操作会保留master分支的修改，而撤销dev分支合并过来的修改。 提交历史变为 1234init -&gt; v1 -&gt; v2 -&gt; v3 -- faulty merge -&gt; v4 -&gt; vc3 -&gt; rev3 (master) \ / d1 --&gt; d2 --&gt; d3 --&gt; d4 (dev)复制代码 此处rev3是一个常规commit，其内容包含了之前在faulty merge撤销掉的dev合并过来的commit的【反操作】的合集。 到这个时候还没完，我们要记住，因为我们抛弃过之前dev合并过来的commit，下次dev再往master合并，之前抛弃过的其实是不包含在里面的。那怎么办呢？ 恢复之前的回滚很简单我们把之前master那个带有【反操作】的commit给撤销掉不就好了？ 1234git checkout mastergit revert rev3git merge dev复制代码 此时提交历史变成了 1234init -&gt; v1 -&gt; v2 -&gt; v3 -- faulty merge -&gt; v4 -&gt; vc3 -&gt; rev3 -&gt; rev3` -&gt; final merge (master) \ / / d1 --&gt; d2 --&gt; d3 --&gt; d4 --------------------------------(dev)复制代码 总结以上就是我想要讲的关于git回滚代码的一些操作，有不对的地方还望指正。另Git 是一门艺术，是一种非常精妙的设计，当你使用上手后，你会发现越来越多好玩的东西，并为设计git的人默默点个赞。也希望在前端领域不论是初学还是深凿者，在追逐流行框架的时候，都不要忘了学习这些基础的工具。 参考 《pro git》 重置揭秘 git-recipes]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01背包、完全背包、多重背包]]></title>
    <url>%2F01%E8%83%8C%E5%8C%85%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85.html</url>
    <content type="text"><![CDATA[前言今天花了一下午加一晚上的时间，在HDUOJ才ac了一道简单的多重背包题目2069，其实也是一道动态规划题目，看来要加紧动态规划的练习了，之前没做过多重背包的题目，导致我做题时复杂化了，虽然是假期但是也不能这么浪费时间，果断总结一下，这里参考了dd_engi大牛的《背包问题九讲》，原文链接：https://www.kancloud.cn/kancloud/pack/70125 01背包题目有N件物品和一个容量为V的背包。第i建物品的费用是c[i],价值是w[i]。求解将哪些物品装入背包可使价值总和最大 思路这是最基础的背包问题，特点是：每种物品只有一件，可以选择放或者不放 用子问题定义状态：即dp[i][j]表示前i件物品放入一个容量为j的背包可以获得的最大价值。则其状态转移方程为： dp[i][j] = max{dp[i - 1][j], dp[i - 1][j - c[i]] + w[i]} 这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来。这里详细解释一下： 将前i件物品放入容量为j的背包中这个子问题，若只考虑第i件物品的策略（放或者不放），那么就可以转换为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转换为前i-1件物品放入容量为j的背包中的最大价值，价值为dp[i - 1][j]如果放入第i件物品，那么问题就转换为前i-1件物品放入容量为j-c[i]的背包中，此时能获得的最大价值是dp[i-1][j-c[i]],再加上放入第i件物品获得的价值w[i] 优化空间复杂度先考虑一下上面的状态转移方程如何实现，肯定有一个主循环i = 1…N,每次算出来二维数组dp[i][0..V]的所有值。那么如果只用一个数组f[0…V],能不能保证第i次循环结束后f[v]就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V…0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下： for i in 0 … N for v = V … 0 f[v] = max{f[v], f[v-c[i]] + w[i]} 练习题目题目：http://acm.hdu.edu.cn/showproblem.php?pid=2602 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt; #define N 1010 int value[N], volume[N], dp[N]; // 0-1背包，优化空间void dpPackage(int n, int v)&#123; int i, j; memset(dp, 0, sizeof(dp)); for (i = 1; i &lt;= n; i ++) &#123; for (j = v; j &gt;= volume[i]; j --) &#123; dp[j] = dp[j] &gt; dp[j - volume[i]] + value[i] ? dp[j] : dp[j - volume[i]] + value[i]; &#125; &#125; printf("%d\n", dp[v]);&#125; int main(void)&#123; int i, t, n, v; scanf("%d", &amp;t); while (t --) &#123; // 接收参数 scanf("%d %d", &amp;n, &amp;v); for (i = 1; i &lt;= n; i ++) scanf("%d", value + i); for (i = 1; i &lt;= n; i ++) scanf("%d", volume + i); // 0-1背包 dpPackage(n, v); &#125; return 0;&#125; 完全背包问题题目有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价格是w[i].求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大 思路这个问题类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已非取或不取两种，而且右取0件、取1件、取2件…等很多种。如果仍然按照01背包的思路，令dp[i][v]表示前i种物品恰好放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程： 1dp[i][v] = max&#123;dp[i-1][v - k * c[i]] + k * w[i] | 0 &lt;= k * c[i]&lt;= v&#125; 转化为01背包求解最简单的想法是：考虑到第i种物品最多选V/c[i]件，于是可以把第i种物品转换为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。但是这样完全没有改进时间复杂度，但这毕竟给了我们将完全背包转换为01背包问题的思路：将一种物品拆成多件物品 O(VN)的算法这个算法使用一维数组，先看伪代码： for i = 1 … N for v = 0 … V f[v] = max{f[v], f[v-cost] + weight} 你会发现，这个伪代码与01背包的伪代码只有v的循环次序不同而已。为什么这样一改就行呢？首先，想想为什么01背包问题中要按照v=V…0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰好是每种物品可选无限件，所以在考虑“加选一件dii种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][c-v[i]],所以就可以并且必须采用v=0…V的顺序循环 练习题目题目链接：http://ac.jobdu.com/problem.php?pid=1454 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 完全背包问题 */ #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; #define INF 50000000 typedef struct coin &#123; int price, weight;&#125; coin; void dynamicPackage(coin *coins, int n, int v)&#123; if (v &lt; 0) &#123; printf("This is impossible.\n"); return; &#125; int i, j, *dp; // 动态分配内存 dp = (int *)malloc(sizeof(int) * (v + 1)); // 初始化 dp[0] = 0; for (i = 1; i &lt;= v; i ++) dp[i] = INF; // 完全背包问题 for (i = 1; i &lt;= n; i ++) &#123; for (j = coins[i].weight; j &lt;= v; j ++) &#123; dp[j] = (dp[j] &lt; dp[j - coins[i].weight] + coins[i].price) ? dp[j] : dp[j - coins[i].weight] + coins[i].price; &#125; &#125; if (dp[v] &gt;= INF) printf("This is impossible.\n"); else printf("The minimum amount of money in the piggy-bank is %d.\n", dp[v]); // 清理内存 free(dp); dp = NULL;&#125; int main(void)&#123; int t, e, f, n, i; coin *coins; scanf("%d", &amp;t); while (t --) &#123; scanf("%d %d", &amp;e, &amp;f); scanf("%d", &amp;n); // 接收货币 coins = (coin *)malloc(sizeof(coin) * (n + 1)); if (coins == NULL) exit(-1); for (i = 1; i &lt;= n; i ++) &#123; scanf("%d %d", &amp;coins[i].price, &amp;coins[i].weight); &#125; // 完全背包 dynamicPackage(coins, n, f - e); free(coins); coins = NULL; &#125; return 0;&#125; 多重背包问题题目有N种物品和一个容量为V的背包。第i种物品最多有n[i]件，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大 思路多重背包问题的思路跟完全背包的思路非常类似，只是k的取值是有限制的，因为每件物品的数量是有限制的，状态转移方程为： 1dpi = max&#123;dpi - 1] + w[i] | 0 &lt;=k &lt;= n[i]&#125; 练习题目题目：http://ac.jobdu.com/problem.php?pid=1455 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; typedef struct rice &#123; int price, weight, num;&#125; rice; void dynamic(rice *rices, int m, int n)&#123; int i, j, cur, k, **dp; // 动态申请二维数组 dp = (int **)malloc(sizeof(int *) * (m + 1)); for (i = 0; i &lt;= m; i ++) dp[i] = (int *)malloc(sizeof(int) * (n + 1)); // 初始化 for (i = 0; i &lt;= m; i ++) for (j = 0; j &lt;= n; j ++) dp[i][j] = 0; // 动态规划 for (i = 1; i &lt;= m; i ++) &#123; for (j = 1; j &lt;= n; j ++) &#123; for (k = 0; k &lt;= rices[i].num; k ++) &#123; if (j - k * rices[i].price &gt;= 0) &#123; cur = dp[i - 1][j - k * rices[i].price] + k * rices[i].weight; dp[i][j] = dp[i][j] &gt; cur ? dp[i][j] : cur; &#125; else &#123; break; &#125; &#125; &#125; &#125; printf("%d\n", dp[m][n]); for (i = 0; i &lt;= m; i ++) free(dp[i]);&#125; int main(void)&#123; int i, c, n, m; rice rices[2010]; scanf("%d", &amp;c); while (c --) &#123; scanf("%d %d", &amp;n, &amp;m); // 接收数据 for (i = 1; i &lt;= m; i ++) &#123; scanf("%d %d %d", &amp;rices[i].price, &amp;rices[i].weight, &amp;rices[i].num); &#125; // 多重背包问题 dynamic(rices, m, n); &#125; return 0;&#125; 后记主要还是为了巩固01背包问题并且多做点题目，所以记录了一下学习《背包九讲》的过程，大家真想搞清楚背包问题，建议还是参考原文链接：https://www.kancloud.cn/kancloud/pack/70125]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Algorithms week1 3Sum in quadratic time]]></title>
    <url>%2FCoursera%20Algorithms%20week1%203Sum%20in%20quadratic%20time.html</url>
    <content type="text"><![CDATA[本题为《算法4》作者 Robert Sedgewick 和 Kevin Wayne 在 Cursera 上开设的公开课的习题解答，本题出自以下地址中的课后题。题目链接：coursera 题目要求： Design an algorithm for the 3-SUM problem that takes time proportional to n2 in the worst case. You may assume that you can sort the n integers in time proportional to n2 or better. 分析： 《算法4》这本书提供的TwoSumFast解法为NlogN，ThreeSumFast解法为N2logN，根据课后练习，要实现3Sum复杂度为N2，建议先把2Sum复杂度实现为N。同时教材提示用排好序的数组可以实现复杂度N。我想了很久，没有发现排好序的数组对复杂度降至N有太大帮助，于是在网上搜索了下大家的做法。网上的大部分都是建议用set或map来做，我决定采用map试试，果然用map很方便。代码如下： 123456789101112131415161718192021222324 1 import java.util.Arrays; 2 import java.util.HashMap; 3 4 public class TwoSumLinear &#123; 5 public static int count(int[] a)&#123; 6 int cnt = 0; 7 int n = a.length; 8 HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); 9 for(int i =0; i&lt;n;i++)&#123;10 if(map.get(a[i]) == null) map.put(a[i], i);11 Integer negIndex = map.get(-a[i]);12 if(negIndex != null &amp;&amp; negIndex != i)&#123;13 System.out.println("a["+negIndex+"]="+(-a[i])+"和a["+i+"]="+a[i]);14 cnt++;15 &#125;16 &#125;17 return cnt;18 &#125;19 public static void main(String[] args)&#123;20 int[] a = &#123; 30, -40, -20, -10, 40, 0, 10, 5 &#125;;21 System.out.println(Arrays.toString(a));22 System.out.println(count(a));23 &#125;24 &#125; 3Sum的作业提示可以先将数组排序，基于这个思路，结合写过的2Sum线性实现方法，写出了复杂度为N2的3Sum，个人认为实现的方式已经很精简了。 123456789101112131415161718192021222324252627282930313233343536 1 import java.util.Arrays; 2 import java.util.HashMap; 3 4 public class ThreeSumQuadratic &#123; 5 public static int count(int[] a, int target) &#123; 6 Arrays.sort(a);// 数组从小到大排序，后面要使用有序数组的性质简化运算 7 System.out.println(Arrays.toString(a)); 8 System.out.println("target="+target); 9 int cnt = 0;10 int n = a.length;11 HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();12 for (int i = 0; i &lt; n; i++) &#123;13 map.put(a[i], i); //以数组value为key，index为map值14 &#125;15 for (int i = 0; i &lt; n - 1; i++) &#123;//i不会超过n-216 for (int j = i + 1; j &lt; n; j++) &#123;//j从i+1开始统计，不会超过n-117 int smallValue = a[i] + a[j]; //因为排好序了，所以最开始的a[i]+a[j]18 if (smallValue &gt; target) //当a[i]+a[j]&gt;target时没必要计算了，因为后续的查找就会重复19 break;20 int bigValue = target-smallValue; //计算出对应的数值较大的value21 Integer bigIndex = map.get(bigValue); //查找数值较大的value所在的位置22 if (bigIndex != null &amp;&amp; bigIndex &gt; i &amp;&amp; bigIndex &gt; j) &#123;23 System.out.println(24 "[" + i + "]=" + a[i] + ",[" + j + "]" + a[j] + ",[" + bigIndex + "]" + (bigValue));25 cnt++;26 &#125;27 &#125;28 &#125;29 return cnt;30 &#125;31 32 public static void main(String[] args) &#123;33 int[] a = &#123; 30, -40, -20, -10, 40, 0, 10, 5 &#125;; 34 System.out.println(count(a,0));35 &#125;36 &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图最大匹配与匈牙利算法]]></title>
    <url>%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[推荐阅读：二分图的最大匹配、完美匹配和匈牙利算法 匈牙利算法匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。 ——-等等，看得头大？那么请看下面的版本： 通过数代人的努力，你终于赶上了剩男剩女的大潮，假设你是一位光荣的新世纪媒人，在你的手上有N个剩男，M个剩女，每个人都可能对多名异性有好感（-_-||暂时不考虑特殊的性取向），如果一对男女互有好感，那么你就可以把这一对撮合在一起，现在让我们无视掉所有的单相思（好忧伤的感觉），你拥有的大概就是下面这样一张关系图，每一条连线都表示互有好感。 本着救人一命，胜造七级浮屠的原则，你想要尽可能地撮合更多的情侣，匈牙利算法的工作模式会教你这样做： =============================================================================== 一： 先试着给1号男生找妹子，发现第一个和他相连的1号女生还名花无主，got it，连上一条蓝线 =============================================================================== 二：接着给2号男生找妹子，发现第一个和他相连的2号女生名花无主，got it =============================================================================== 三：接下来是3号男生，很遗憾1号女生已经有主了，怎么办呢？ 我们试着给之前1号女生匹配的男生（也就是1号男生）另外分配一个妹子。 (黄色表示这条边被临时拆掉) 与1号男生相连的第二个女生是2号女生，但是2号女生也有主了，怎么办呢？我们再试着给2号女生的原配()重新找个妹子(注意这个步骤和上面是一样的，这是一个递归的过程) 此时发现2号男生还能找到3号女生，那么之前的问题迎刃而解了，回溯回去 2号男生可以找3号妹子~ 1号男生可以找2号妹子了~ 3号男生可以找1号妹子 所以第三步最后的结果就是： =============================================================================== 四： 接下来是4号男生，很遗憾，按照第三步的节奏我们没法给4号男生腾出来一个妹子，我们实在是无能为力了……香吉士同学走好。 =============================================================================== 这就是匈牙利算法的流程，其中找妹子是个递归的过程，最最关键的字就是“腾”字其原则大概是：有机会上，没机会创造机会也要上 【code】 12345678910111213141516bool find(int x)&#123; int i,j; for (j=1;j&lt;=m;j++)&#123; //扫描每个妹子 if (line[x][j]==true &amp;&amp; used[j]==false) //如果有暧昧并且还没有标记过(这里标记的意思是这次查找曾试图改变过该妹子的归属问题，但是没有成功，所以就不用瞎费工夫了） &#123; used[j]=1; if (girl[j]==0 || find(girl[j])) &#123; //名花无主或者能腾出个位置来，这里使用递归 girl[j]=x; return true; &#125; &#125; &#125; return false;&#125; 在主程序我们这样做：每一步相当于我们上面描述的一二三四中的一步 12345for (i=1;i&lt;=n;i++)&#123; memset(used,0,sizeof(used)); //这个在每一步中清空 if find(i) all+=1;&#125; 二分图的最大匹配、完美匹配和匈牙利算法这篇文章讲无权二分图（unweighted bipartite graph）的最大匹配（maximum matching）和完美匹配（perfect matching），以及用于求解匹配的匈牙利算法（Hungarian Algorithm）；不讲带权二分图的最佳匹配。 二分图：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 $U$ 和$V$ ，使得每一条边都分别连接$U$、$V$中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。 匹配：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。 我们定义匹配点、匹配边、未匹配点、非匹配边，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。 举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是完美匹配问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是最大匹配问题。 基本概念讲完了。求解最大匹配问题的一个算法是匈牙利算法，下面讲的概念都为这个算法服务。 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）： 增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。 我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。 匈牙利树一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树： 这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。 下面给出匈牙利算法的 DFS 和 BFS 版本的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 顶点、边的编号均从 0 开始// 邻接表储存struct Edge&#123; int from; int to; int weight; Edge(int f, int t, int w):from(f), to(t), weight(w) &#123;&#125;&#125;;vector&lt;int&gt; G[__maxNodes]; /* G[i] 存储顶点 i 出发的边的编号 */vector&lt;Edge&gt; edges;typedef vector&lt;int&gt;::iterator iterator_t;int num_nodes;int num_left;int num_right;int num_edges;int matching[__maxNodes]; /* 存储求解结果 */int check[__maxNodes];bool dfs(int u)&#123; for (iterator_t i = G[u].begin(); i != G[u].end(); ++i) &#123; // 对 u 的每个邻接点 int v = edges[*i].to; if (!check[v]) &#123; // 要求不在交替路中 check[v] = true; // 放入交替路 if (matching[v] == -1 || dfs(matching[v])) &#123; // 如果是未盖点，说明交替路为增广路，则交换路径，并返回成功 matching[v] = u; matching[u] = v; return true; &#125; &#125; &#125; return false; // 不存在增广路，返回失败&#125;int hungarian()&#123; int ans = 0; memset(matching, -1, sizeof(matching)); for (int u=0; u &lt; num_left; ++u) &#123; if (matching[u] == -1) &#123; memset(check, 0, sizeof(check)); if (dfs(u)) ++ans; &#125; &#125; return ans;&#125;queue&lt;int&gt; Q;int prev[__maxNodes];int Hungarian()&#123; int ans = 0; memset(matching, -1, sizeof(matching)); memset(check, -1, sizeof(check)); for (int i=0; i&lt;num_left; ++i) &#123; if (matching[i] == -1) &#123; while (!Q.empty()) Q.pop(); Q.push(i); prev[i] = -1; // 设 i 为路径起点 bool flag = false; // 尚未找到增广路 while (!Q.empty() &amp;&amp; !flag) &#123; int u = Q.front(); for (iterator_t ix = G[u].begin(); ix != G[u].end() &amp;&amp; !flag; ++ix) &#123; int v = edges[*ix].to; if (check[v] != i) &#123; check[v] = i; Q.push(matching[v]); if (matching[v] &gt;= 0) &#123; // 此点为匹配点 prev[matching[v]] = u; &#125; else &#123; // 找到未匹配点，交替路变为增广路 flag = true; int d=u, e=v; while (d != -1) &#123; int t = matching[d]; matching[d] = e; matching[e] = d; d = prev[d]; e = t; &#125; &#125; &#125; &#125; Q.pop(); &#125; if (matching[i] != -1) ++ans; &#125; &#125; return ans;&#125; 匈牙利算法的要点如下 从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。 如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。 如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。 由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 prev 数组。 性能比较 两个版本的时间复杂度均为$O\big(V \cdot E\big)$。DFS 的优点是思路清晰、代码量少，但是性能不如 BFS。我测试了两种算法的性能。对于稀疏图，BFS 版本明显快于 DFS 版本；而对于稠密图两者则不相上下。在完全随机数据 9000 个顶点 4,0000 条边时前者领先后者大约 97.6%，9000 个顶点 100,0000 条边时前者领先后者 8.6%, 而达到 500,0000 条边时 BFS 仅领先 0.85%。 补充定义和定理： 最大匹配数：最大匹配的匹配边的数目 最小点覆盖数：选取最少的点，使任意一条边至少有一个端点被选择 最大独立数：选取最多的点，使任意所选两点均不相连 最小路径覆盖数：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。 定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理） 定理2：最大匹配数 = 最大独立数 定理3：最小路径覆盖数 = 顶点数 - 最大匹配数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra-最短路径算法]]></title>
    <url>%2FDijkstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[推荐阅读，转自:【啊哈！算法】系列7：Dijkstra最短路算法 上周我们介绍了神奇的只有五行的Floyd最短路算法，它可以方便的求得任意两点的最短路径，这称为“多源最短路”。本周来来介绍指定一个点（源点）到其余各个顶点的最短路径，也叫做“单源最短路径”。例如求下图中的1号顶点到2、3、4、5、6号顶点的最短路径。 ​ 与Floyd-Warshall算法一样这里仍然使用二维数组e来存储顶点之间边的关系，初始值如下。 ​ 我们还需要用一个一维数组dis来存储1号顶点到其余各个顶点的初始路程，如下。 ​ 我们将此时dis数组中的值称为最短路的“估计值”。 ​ 既然是求1号顶点到其余各个顶点的最短路程，那就先找一个离1号顶点最近的顶点。通过数组dis可知当前离1号顶点最近是2号顶点。当选择了2号顶点后，dis[2]的值就已经从“估计值”变为了“确定值”，即1号顶点到2号顶点的最短路程就是当前dis[2]值。为什么呢？你想啊，目前离1号顶点最近的是2号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得1号顶点到2号顶点的路程进一步缩短了。因为1号顶点到其它顶点的路程肯定没有1号到2号顶点短，对吧O(∩_∩)O~ ​ 既然选了2号顶点，接下来再来看2号顶点有哪些出边呢。有2-&gt;3和2-&gt;4这两条边。先讨论通过2-&gt;3这条边能否让1号顶点到3号顶点的路程变短。也就是说现在来比较dis[3]和dis[2]+e[2] [3]的大小。其中dis[3]表示1号顶点到3号顶点的路程。dis[2]+e[2] [3]中dis[2]表示1号顶点到2号顶点的路程，e[2] [3]表示2-&gt;3这条边。所以dis[2]+e[2] [3]就表示从1号顶点先到2号顶点，再通过2-&gt;3这条边，到达3号顶点的路程。 ​ 我们发现dis[3]=12，dis[2]+e[2] [3]=1+9=10，dis[3]&gt;dis[2]+e[2] [3]，因此dis[3]要更新为10。这个过程有个专业术语叫做“松弛”。即1号顶点到3号顶点的路程即dis[3]，通过2-&gt;3这条边松弛成功。这便是Dijkstra算法的主要思想：通过“边”来松弛1号顶点到其余各个顶点的路程。 ​ 同理通过2-&gt;4（e[2] [4]），可以将dis[4]的值从∞松弛为4（dis[4]初始为∞，dis[2]+e[2] [4]=1+3=4，dis[4]&gt;dis[2]+e[2] [4]，因此dis[4]要更新为4）。 ​ 刚才我们对2号顶点所有的出边进行了松弛。松弛完毕之后dis数组为： ​ 接下来，继续在剩下的3、4、5和6号顶点中，选出离1号顶点最近的顶点。通过上面更新过dis数组，当前离1号顶点最近是4号顶点。此时，dis[4]的值已经从“估计值”变为了“确定值”。下面继续对4号顶点的所有出边（4-&gt;3，4-&gt;5和4-&gt;6）用刚才的方法进行松弛。松弛完毕之后dis数组为： ​ 继续在剩下的3、5和6号顶点中，选出离1号顶点最近的顶点，这次选择3号顶点。此时，dis[3]的值已经从“估计值”变为了“确定值”。对3号顶点的所有出边（3-&gt;5）进行松弛。松弛完毕之后dis数组为： ​ 继续在剩下的5和6号顶点中，选出离1号顶点最近的顶点，这次选择5号顶点。此时，dis[5]的值已经从“估计值”变为了“确定值”。对5号顶点的所有出边（5-&gt;4）进行松弛。松弛完毕之后dis数组为： ​ 最后对6号顶点所有点出边进行松弛。因为这个例子中6号顶点没有出边，因此不用处理。到此，dis数组中所有的值都已经从“估计值”变为了“确定值”。 ​ 最终dis数组如下，这便是1号顶点到其余各个顶点的最短路径。 ​ OK，现在来总结一下刚才的算法。算法的基本思想是：每次找到离源点（上面例子的源点就是1号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下： 将所有的顶点分为两部分：已知最短路程的顶点集合P和未知最短路径的顶点集合Q。最开始，已知最短路径的顶点集合P中只有源点一个顶点。我们这里用一个book[ i ]数组来记录哪些点在集合P中。例如对于某个顶点i，如果book[ i ]为1则表示这个顶点在集合P中，如果book[ i ]为0则表示这个顶点在集合Q中。 设置源点s到自己的最短路径为0即dis=0。若存在源点有能直接到达的顶点i，则把dis[ i ]设为e[s] [ i ]。同时把所有其它（源点不能直接到达的）顶点的最短路径为设为∞。 在集合Q的所有顶点中选择一个离源点s最近的顶点u（即dis[u]最小）加入到集合P。并考察所有以点u为起点的边，对每一条边进行松弛操作。例如存在一条从u到v的边，那么可以通过将边u-&gt;v添加到尾部来拓展一条从s到v的路径，这条路径的长度是dis[u]+e[u] [v]。如果这个值比目前已知的dis[v]的值要小，我们可以用新值来替代当前dis[v]中的值。 重复第3步，如果集合Q为空，算法结束。最终dis数组中的值就是源点到所有顶点的最短路径。 ​ 完整的Dijkstra算法代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;int main()&#123; int e[10][10],dis[10],book[10],i,j,n,m,t1,t2,t3,u,v,min; int inf=99999999; //用inf(infinity的缩写)存储一个我们认为的正无穷值 //读入n和m，n表示顶点个数，m表示边的条数 scanf("%d %d",&amp;n,&amp;m); //初始化 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(i==j) e[i][j]=0; else e[i][j]=inf; //读入边 for(i=1;i&lt;=m;i++) &#123; scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); e[t1][t2]=t3; &#125; //初始化dis数组，这里是1号顶点到其余各个顶点的初始路程 for(i=1;i&lt;=n;i++) dis[i]=e[1][i]; //book数组初始化 for(i=1;i&lt;=n;i++) book[i]=0; book[1]=1; //Dijkstra算法核心语句 for(i=1;i&lt;=n-1;i++) &#123; //找到离1号顶点最近的顶点 min=inf; for(j=1;j&lt;=n;j++) &#123; if(book[j]==0 &amp;&amp; dis[j]&lt;min) &#123; min=dis[j]; u=j; &#125; &#125; book[u]=1; for(v=1;v&lt;=n;v++) &#123; if(e[u][v]&lt;inf) &#123; if(dis[v]&gt;dis[u]+e[u][v]) dis[v]=dis[u]+e[u][v]; &#125; &#125; &#125; //输出最终的结果 for(i=1;i&lt;=n;i++) printf("%d ",dis[i]); getchar(); getchar(); return 0;&#125; ​ 可以输入以下数据进行验证。第一行两个整数n m。n表示顶点个数（顶点编号为1~n），m表示边的条数。接下来m行表示，每行有3个数x y z。表示顶点x到顶点y边的权值为z。 123456789106 91 2 11 3 122 3 92 4 33 5 54 3 44 5 134 6 155 6 4 ​ 运行结果是 10 1 8 4 13 17 通过上面的代码我们可以看出，这个算法的时间复杂度是O(N2)。其中每次找到离1号顶点最近的顶点的时间复杂度是O(N)，这里我们可以用“堆”（以后再说）来优化，使得这一部分的时间复杂度降低到O(logN)。另外对于边数M少于N2的稀疏图来说（我们把M远小于N2的图称为稀疏图，而M相对较大的图称为稠密图），我们可以用邻接表（这是个神马东西？不要着急，下周再仔细讲解）来代替邻接矩阵，使得整个时间复杂度优化到O( (M+N)logN )。请注意！在最坏的情况下M就是N2，这样的话MlogN要比N2还要大。但是大多数情况下并不会有那么多边，因此(M+N)logN要比N2小很多。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[贪心算法贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 一句话：不求最优，仅仅求可行解。 选择使用贪心算法 我们能够依据贪心法的2个重要的性质去证明：贪心选择性质和最优子结构性质。 1、贪心选择 什么叫贪心选择？从字义上就是贪心也就是目光短线。贪图眼前利益。在算法中就是仅仅依据当前已有的信息就做出选择，并且以后都不会改变这次选择。（这是和动态规划法的主要差别） 所以对于一个详细问题。要确定它是否具有贪心选择性质，必须证明每做一步贪心选择是否终于导致问题的总体最优解。 2、最优子结构 当一个问题的最优解包括其子问题的最优解时，称此问题具有最优子结构性质。 ​ 运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。动态规划主要运用于二维或三维问题，而贪心一般是一维问题 基本思路贪心算法的基本思路是从问题的某一个初始解触发一步一步地进行，根据抹个优化测度，每一步都要确保能获得局部最优解，每一步值考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连载一起不再是可行解时，就不把改数据添加到部分解中，知道把所有数据枚举玩，或者不能在添加算法停止。 过程 建立数学模型来描述问题； 把求解的问题分成若干个子问题； 对每一子问题求解，得到子问题的局部最优解； 把子问题的解局部最优解合成原来解问题的一个解。 算法特性 随着算法的进行，将积累起其它两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象。 有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优。 还有一个函数检查是否一个候选对象的集合是可行的，也即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性。 选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解。 最后，目标函数给出解的值。 为了解决问题，需要寻找一个构成解的候选对象集合，它可以优化目标函数，贪婪算法一步一步的进行。起初，算法选出的候选对象的集合为空。接下来的每一步中，根据选择函数，算法从剩余候选对象中选出最有希望构成解的对象。如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑；否则就加到集合里。每一次都扩充集合，并检查该集合是否构成解。如果贪婪算法正确工作，那么找到的第一个解通常是最优的。 一般求解过程 使用贪心法求解能够依据下面几个方面进行（终于也相应着每步代码的实现），以找零钱为例： 1、候选集合(C) 通过一个候选集合C作为问题的可能解。（终于解均取自于候选集合C） 比如。在找零钱问题中，各种面值的货币构成候选集合。 2、解集合(S) 每完毕一次贪心选择，将一个解放入S。终于获得一个完整解S 3、解决函数(solution) 检查解集合S是否构成问题的完整解。 比如，在找零钱问题中。解决函数是已付出的货币金额恰好等于应付款。 4、选择函数(select) 即贪心策略。这是贪心法的关键，选择出最有希望构成问题的解的对象。 （这个选择函数通常和目标函数有关） 比如，在找零钱问题中，贪心策略就是在候选集合中选择面值最大的货币。 5、可行函数(feasible) 检查解集合中增加一个候选对象是否可行。（增加下一个对象后是不是满足约束条件） 比如。在找零钱问题中，可行函数是每一步选择的货币和已付出的货币相加不超过应付款。 例子1.活动选择问题有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi 。一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天。该问题就是要安排这些活动使得尽量多的活动能不冲突的举行。 问题分析：活动安排问题要求安排一系列争用某一公共资源的活动。用贪心算法可提供一个简单、漂亮的方法，使尽可能多的活动能兼容的使用公共资源。设有n个活动的集合｛0，1，2，…，n-1｝，其中每个活动都要求使用同一资源，如会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间starti和一个结束时间endi，且starti&lt;endi。如选择了活动i，则它在半开时间区间[starti,endi）内占用资源。若区间[starti,endi)与区间[startj,endj)不相交，称活动i与活动j是相容的。也就是说，当startj≥endi或starti≥endj时，活动i与活动j相容。活动安排问题就是在所给的活动集合中选出最多的不相容活动。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。该问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。 算法设计：若被检查的活动i的开始时间starti小于最近选择的活动j的结束时间endj，则不选择活动i，否则选择活动i加入集合中。运用该算法解决活动安排问题的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int N; struct Act &#123; int start; int end; &#125;act[100010]; bool cmp(Act a,Act b) &#123; return a.end&lt;b.end; &#125; int greedy_activity_selector() &#123; int num=1,i=1; for(int j=2;j&lt;=N;j++) &#123; if(act[j].start&gt;=act[i].end) &#123; i=j; num++; &#125; &#125; return num; &#125; int main() &#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf("%lld %lld",&amp;act[i].start,&amp;act[i].end); &#125; act[0].start=-1; act[0].end=-1; sort(act+1,act+N+1,cmp); int res=greedy_activity_selector(); cout&lt;&lt;res&lt;&lt;endl; &#125; &#125; 2.钱币找零问题这个问题在我们的日常生活中就更加普遍了。假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将Value按照从小到大的顺序排好。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=7; int Count[N]=&#123;3,0,2,1,0,3,5&#125;;int Value[N]=&#123;1,2,5,10,20,50,100&#125;; int solve(int money) &#123; int num=0; for(int i=N-1;i&gt;=0;i--) &#123; int c=min(money/Value[i],Count[i]); money=money-c*Value[i]; num+=c; &#125; if(money&gt;0) num=-1; return num;&#125; int main() &#123; int money; cin&gt;&gt;money; int res=solve(money); if(res!=-1) cout&lt;&lt;res&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl;&#125; 3.背包问题有一个背包，背包容量是M=150kg。有7个物品，物品不可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。 问题分析目标函数： ∑pi最大，使得装入背包中的所有物品pi的价值加起来最大。 约束条件：装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150) 贪心策略： ⑴根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？ ⑵每次挑选所占重量最小的物品装入是否能得到最优解？ ⑶每次选取单位重量价值最大的物品，成为解本题的策略。 ⑴贪心策略：选取价值最大者。 W=30 物品：A B C 重量：28 12 12 价值：30 20 20 根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。 ⑵贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。 ⑶贪心策略：选取单位重量价值最大的物品。 反例： W=30 物品：A B C 重量：28 20 10 价值：28 20 10 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。 【注意：如果物品可以分割为任意大小，那么策略3可得最优解】 对于选取单位重量价值最大的物品这个策略，可以再加一条优化的规则：对于单位重量价值一样的，则优先选择重量小的！这样，上面的反例就解决了。 但是，如果题目是如下所示，这个策略就也不行了。 W=40 物品：A B C 重量：25 20 15 价值：25 20 15 算法设计： 计算出每个物品单位重量的价值 按单位价值从大到小将物品排序 根据背包当前所剩容量选取物品 如果背包的容量大于当前物品的重量，那么就将当前物品装进去。否则，那么就将当前物品舍去，然后跳出循环结束。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef struct&#123; int w; int v; double avg;&#125;P;bool cmp(P a,P b)&#123; return a.avg&gt;b.avg;&#125;int main()&#123; P *p; int n,i,m;//n 物品个数 m背包容量 while(cin&gt;&gt;n&gt;&gt;m)&#123; p=new P[n]; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;p[i].w&gt;&gt;p[i].v; p[i].avg=p[i].v/p[i].w*1.0; &#125; sort(p,p+n,cmp); int maxvalue=0; for(i=0;i&lt;n;i++)&#123; if(p[i].w&lt;=m)&#123; m-=p[i].w; maxvalue+=p[i].v; &#125;else&#123; break; &#125; &#125; cout&lt;&lt;maxvalue&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2000-2099 入门笔记]]></title>
    <url>%2FHDU%202000-2099%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[都说HDU 2000-2099 是acm入门必刷题，为了备战蓝桥杯，巩固知识，我做了一些小笔记与总结。 HDU 1002 A+B Problem two(大数问题)大数问题，通用的方法是使用string进行ascii码的加减 两个数字的ascii码相加减去 0 就是对应数字的ascii码 如果相加的数大于10,相加的ascii码减去10就是个位数 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string sum(string &amp;s1, string &amp;s2)&#123; if (s1 == "" &amp;&amp; s2 == "") return "0"; if (s1 == "") return s2; if (s2 == "") return s1; string max, min; int lens1 = s1.length(); int lens2 = s2.length(); if (lens1 &lt; lens2) &#123; max = s2; min = s1; &#125; else &#123; max = s1; min = s2; &#125; int maxlen = max.length(); int minlen = min.length(); int i, j; for (i = maxlen - 1, j = minlen - 1; j &gt;= 0; j--, i--) &#123; max[i] = max[i] + min[i] - '0'; //相加的ascii码-0就是对应数组的ascii码 &#125; for (int i = maxlen - 1; i &gt; 0; i--) &#123; if (max[i] &gt; '9') &#123; max[i] = max[i] - 10; //相加的ascii码-10就是个位数 max[i - 1] += 1; &#125; &#125; if (max[0] &gt; '9') &#123; max[0] -= 10; max = "1" + max; &#125; return max;&#125;int main()&#123; int num; cin &gt;&gt; num; int i = 1; int count = num; while (num) &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; cout &lt;&lt; s1 &lt;&lt; " + " &lt;&lt; s2 &lt;&lt; " = " &lt;&lt; sum(s1, s2) &lt;&lt; endl; if (i &lt; count) cout &lt;&lt; endl; num--; i++; &#125; return 0;&#125; HDU 2018 母牛的故事(递推)相似：HDU 2044~2050,HDU2041 Description 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？Input 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt; n&lt; 55)，n的含义如题目中描述。 n=0表示输入数据的结束，不做处理。Output 对于每个测试实例，输出在第n年的时候母牛的数量。 每个输出占一行。 分析:​ 以n=6为例，fn=9头牛可以分解为6+3，其中6是上一年（第5年）的牛，3是新生的牛（因为第3年有3头牛，这3头在第6年各生一头牛）。 我们可以得出这样一个公式：fn=fn-1+fn-3 再理解一下，fn-1是前一年的牛，第n年仍然在，fn-3是前三年那一年的牛，但换句话说也就是第n年具有生育能力的牛，也就是第n年能生下的小牛数。 代码: 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int f(int n);int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; cout&lt;&lt;f(n)&lt;&lt;endl; &#125; return 0;&#125; int f(int n)&#123; if(n&lt;4) return n; //第1，2，3年，各为1，2，3头 else return f(n-1)+f(n-3); //第n年为前一年的和前3年的相加&#125; HDU 2031 进制转换(模拟):Problem Description 输入一个十进制数N，将它转换成R进制数输出。 Input 输入数据包含多个测试实例，每个测试实例包含两个整数N(32位整数)和R（2&lt;=R&lt;=16, R&lt;&gt;10）。 Output 为每个测试实例输出转换后的数，每个输出占一行。如果R大于10，则对应的数字规则参考16进制（比如，10用A表示，等等）。 分析: 进制转换,也就是取余,以7的二进制表示: 7%2=1…7/2=3 3%2=1…3/2=1 1%2=1…1/2=0 取余的数字拼接为111,直到商为0为止,即是7的二进制表示 代码: 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int main()&#123; int n,r,i,x,flag; int a[1000]; while (scanf("%d %d",&amp;n,&amp;r)!=EOF) &#123; flag=0; if (n&lt;0) &#123; n=-n; flag=1; &#125; x=0; while (n) &#123; a[x]=n%r; n/=r; x++; &#125; while (x--) &#123; if (flag) &#123; printf("-"); flag=0; &#125; if (a[x]&lt;10) printf("%d",a[x]); else printf("%c",55+a[x]); &#125; printf("\n"); &#125; return 0;&#125; HDU 2048 神、上帝以及老天爷(错排问题)相似：HDU 2049 Description HDU 2006’10 ACM contest的颁奖晚会隆重开始了！为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的： 首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；然后，待所有字条加入完毕，每人从箱中取一个字条；最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！” 大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！ 我的神、上帝以及老天爷呀，怎么会这样呢？ 不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？ 不会算？难道你也想以悲剧结尾？！ Input 输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数n(1 &lt; n &lt; =20),表示参加抽奖的人数。 Output 对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。 分析: 典型的错排问题,具体思路如下: 当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推. 把第n个元素放在一个位置，比如位置k，一共有n-1种方法； 放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法； 综上得到 D(n) = (n-1) [D(n-2) + D(n-1)] 特殊地，D(1) = 0, D(2) = 1. 代码： 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n; int i,j,num; long long D[22],F[22]; D[1]=0;D[2]=1; for(i=3;i&lt;21;i++) D[i]=(i-1)*(D[i-1]+D[i-2]); for(i=20;i&gt;0;i--)&#123; F[i]=i; for(j=i-1;j&gt;1;j--) F[i]*=j; &#125; scanf("%d",&amp;num); while(num--)&#123; scanf("%d",&amp;n); printf("%.2lf%%\n",D[n]*100.0/F[n]); &#125; return 0;&#125; HDU 2053 Switch Game(开灯问题,唯一分解定理)Problem Description There are many lamps in a line. All of them are off at first. A series of operations are carried out on these lamps. On the i-th operation, the lamps whose numbers are the multiple of i change the condition ( on to off and off to on ). Input Each test case contains only a number n ( 0&lt; n&lt;= 10^5) in a line. Output Output the condition of the n-th lamp after infinity operations ( 0 - off, 1 - on ). 分析： 36的约数是 (1,36), (2,18), (3,12), (4,9), (6)，任何一个数都是由两个不同的数相乘得到的，但是如果一个数为平方数，那么这两个数就可以相等，例如36由两个6相乘得到，所以要判断灯的状态，只需要判断这个数是不是平方数即可 代码： 1234567891011121314#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; double x=sqrt(n*1.0); cout&lt;&lt;(x==int(x))&lt;&lt;endl; &#125; return 0;&#125; HDU 2057 A + B Again (16进制数相加)Problem Description There must be many A + B problems in our HDOJ , now a new one is coming.Give you two hexadecimal integers , your task is to calculate the sum of them,and print it in hexadecimal too.Easy ? AC it ! Input The input contains several test cases, please process to the end of the file.Each case consists of two hexadecimal integers A and B in a line seperated by a blank.The length of A and B is less than 15. Output For each test case,print the sum of A and B in hexadecimal in one line. 分析： 涉及到16进制内的加法，可以用%I64x直接来处理，要注意到16进制中负数是用补码来表示的。一个比较困惑的事实是，这道题再输出时，%64X中‘X’必须是大写，小写是过不了的。 注意：__int64 %I64X ,输出用大写 123456789101112131415#include "cstdio"int main()&#123; __int64 a,b,c; while(~scanf("%I64X%I64X",&amp;a,&amp;b)) &#123; c=a+b; if(c&gt;=0) printf("%I64X\n",c); else printf("-%I64X\n",-c); &#125; return 0;&#125; HDU 2062 Subset sequence（子序列）Problem Description Consider the aggregate An= { 1, 2, …, n }. For example, A1={1}, A3={1,2,3}. A subset sequence is defined as a array of a non-empty subset. Sort all the subset sequece of An in lexicography order. Your task is to find the m-th one. Input The input contains several test cases. Each test case consists of two numbers n and m ( 0&lt; n&lt;= 20, 0&lt; m&lt;= the total number of the subset sequence of An ). Output For each test case, you should output the m-th subset sequence of An in one line. 分析： 当n=2的时候 子序列从小到大 {1}, {1, 2}, {2}, {2, 1} 当n=3的时候 子序列从小到大 {1} {1, 2} {1, 2, 3} {1, 3} {1, 3, 2} {2}{2, 1}{2, 1, 3}{2, 3}{2, 3, 1} {3}{3, 1}{3, 1, 2}{3, 2}{3, 2, 1} 不难发现，An可以按首数字分成n组，而每组里除了第一项，剩下的就是An-1的子集合了。 ∴f(n) = n[f(n-1) + 1] f(1) = 1 我们拿测试数据3 10来做个示范，解释一下怎么求解。 因为n=3，所以开始数组里1、2、3三个数。 我们知道，n=2时，有4种排列，所以上面n=3可以分成三组，每组5个(加上空集)。 //空集就是说去掉该组第一个数字后为空集 因此第10个在第二组里。所以第一个是2，把2输出。原来的数组里删除2，变成1、3两个数。然后10 - (2 - 1) * 5 =5，即它在第2组的第5个。 //请自行推导所在位置 减去首个空集合，5 - 1 = 4 ≠ 0，表示2后面还有数字。 因为A1 = 1是，所以再第2组里又可以分成两组，每组2个(加上空集)。 所以，4在第2组，剩下的数组中，第二个元素是3，所以输出3。再把数组里的3删除，剩下1一个数。 然后4 - (2 - 1) * 2 = 2，既它是第2组的第2个。 减去首个空集，2 - 1 = 1 ≠ 0，表示2后面还有数字。 按上面的方法继续下去，直到n = 0 或 后面为空集为止。 最后输出数组里的第1个元素，就得到2 3 1，就是解了。从上面的计算可以看出来，本题目的关键是先求的An中每一组的个数g(n) 不难得出:g(n) = f(n) / n ∵f(n) = n[f(n-1) + 1] ∴g(n) = n[f(n-1) + 1] / n = f(n-1) + 1 ∵f(n-1) = (n-1) * g(n-1) ∴g(n) = (n-1) * g(n-1) + 1 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;cstring&gt;int main()&#123; int a; __int64 b; __int64 g[30]; g[1]=1; g[2]=2; for(int i=3;i&lt;22;i++) &#123; g[i]=g[i-1]*(i-1)+1;//求出g； &#125; int num[30]; while(scanf("%d%I64d",&amp;a,&amp;b)!=EOF) //b的数可能很大，所以用I64d，，用int运行错了 &#123; memset(num,0,sizeof(num));//清零 for(int i=1;i&lt;=a;i++) num[i]=i; //将要输出的数字保存在数组里 int am=a; while(a--)//总共有a个数（1---a）最多可能输出a个 &#123; int n=b%g[a+1]? b/g[a+1]+1: b/g[a+1]; //我们用b取余对应的g，，得到要输出的数在第几组 if(num[n]==0) break; if(am-1==a) printf("%d",num[n]); / /输出对应的组代表的数字 else printf(" %d",num[n]); for(int i=n;i&lt;=a;i++) num[i]=num[i+1]; //将刚输出的数字删掉，，留下剩下的数字，，没用的数字都变成0了 b=(b-g[a+1]*(n-1)-1); //把问题缩小到下一组，，， 求出在下一组的位置；循环；直到要输出的num为0，说明所有的数都输完了； &#125; printf("\n"); &#125; return 0;&#125; HDU 2064 汉诺塔Ⅲ（递归）Problem Description 约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？ Input 包含多组数据，每次输入一个N值(1&lt;=N=35)。 Output 对于每组数据，输出移动最小的次数。 分析： 建议阅读 如何理解汉诺塔的递归？ - 知乎 其实本题的复杂之处就是相当与比以往的汉诺塔多移动了一次柱子，原来，现在a4=a3+a3+a3+2(移动最大的圆盘要两次)，理解了便能很快求解 …HDU 2059 Seraph2012 (DP)HDU 2037 今年暑假不AC（贪心）推荐：贪心算法 Problem Description“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）Input输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。Output对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。 分析：最简单的贪心算法，因为一个节目对应一个开始时间和一个结束时间，所以，将这两个时间放到一个结构体中，然后对结束时间按照从小到大的顺序进行排序，如果结束的时间相同的话，就将开始的时间按照从大到小的顺序排序，然后开始比较，如果开始的时间比前一个结束的时间迟，就k++，最终k的值即为所求！ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std; struct Program&#123; int start,end;&#125;pro[10001]; int main()&#123; int n,sum,final; int i,j; Program temp; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; for(i=0;i&lt;n;++i) &#123; scanf("%d%d",&amp;pro[i].start,&amp;pro[i].end); &#125; for(i=0;i&lt;n-1;++i) for(j=i+1;j&lt;n;++j) if(pro[i].end&gt;pro[j].end) &#123; temp=pro[i]; pro[i]=pro[j]; pro[j]=temp; &#125; sum=1; final=pro[0].end; for(i=1;i&lt;n;++i) &#123; if(final&lt;=pro[i].start) &#123; ++sum; final=pro[i].end; &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125; HDU 2063 过山车 （二分图的最大匹配、完美匹配和匈牙利算法）Problem Description RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？ Input 输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=10001&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。 Output 对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。 分析： https://www.renfei.org/blog/bipartite-matching.html https://blog.csdn.net/dark_scope/article/details/8880547 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxn=505;int n,m;bool a[maxn][maxn];bool vis[maxn];int ok[maxn];//ok[x]=y;//第x个男生和第y个女生做partnerbool Find(int x)&#123; for(int i=1; i&lt;=n; i++)//男生 &#123; if(a[x][i]&amp;&amp;!vis[i]) &#123; vis[i]=true; //该男生没有被组合||该女生可以找其他人组合 if(!ok[i]||Find(ok[i])) &#123; ok[i]=x;//第i个男生和第x个女生做partner return true; &#125; &#125; &#125; return false;&#125;int main()&#123; int k; while(cin&gt;&gt;k,k) &#123; cin&gt;&gt;m&gt;&gt;n; memset(a,false,sizeof(a)); memset(ok,0,sizeof(ok)); int x,y; while(k--) &#123; cin&gt;&gt;x&gt;&gt;y; a[x][y]=true; &#125; int ans=0; for(int i=1; i&lt;=m; i++) //女生 &#123; memset(vis,false,sizeof(vis)); if(Find(i)) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; HDU 2066 一个人的旅行（最短路，多起点多终点，Dijkstra算法+spfa算法）Problem Description虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。 Input输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路)接着的第T+1行有S个数，表示和草儿家相连的城市；接着的第T+2行有D个数，表示草儿想去地方。 Output 输出草儿能去某个喜欢的城市的最短时间。 分析： http://blog.51cto.com/ahalei/1387799 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int a[1005][1005];int dis[1005];bool vis[1005];const int INF=0x3f3f3f3f;int n;void Dij()&#123; for(int i=0;i&lt;=n;i++) &#123; dis[i]=a[0][i]; vis[i]=false; &#125; vis[0]=true; dis[0]=0; for(int i=0;i&lt;=n;i++) &#123; int minn=INF; int p; for(int j=0;j&lt;=n;j++) &#123; if(!vis[j]&amp;&amp;dis[j]&lt;minn) &#123; minn=dis[p=j]; &#125; &#125; vis[p]=true; if(minn==INF) break; for(int j=0;j&lt;=n;j++) &#123; if(!vis[j]&amp;&amp;dis[j]&gt;dis[p]+a[p][j]) dis[j]=dis[p]+a[p][j]; &#125; &#125;&#125;int main()&#123; int t,s,d; int x,y,z; while(scanf("%d%d%d",&amp;t,&amp;s,&amp;d)!=EOF) &#123; n=0; memset(a,INF,sizeof(a)); while(t--) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); if(z&lt;a[x][y]) a[x][y]=a[y][x]=z; n=max(n,max(x,y)); &#125; while(s--) &#123; scanf("%d",&amp;x); a[0][x]=0; &#125; Dij(); int minn=INF; while(d--) &#123; scanf("%d",&amp;x); minn=min(minn,dis[x]); &#125; printf("%d\n",minn); &#125; return 0;&#125; HDU 2067 小兔的棋盘（卡塔兰数）Problem Description 小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。不过没过几天发现了棋盘的好玩之处。从起点(0，0)走到终点(n,n)的最短路径数是C(2n,n),现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧! Input 每次输入一个数n(1&lt;=n&lt;=35)，当n等于－1时结束输入。 Output 对于每个输入数据输出路径数，具体格式看Sample。 分析： https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0 遇到类似题型带公式即可 卡特兰数又称卡塔兰数，英文名Catalan number，是组合数学中一个常出现在各种计数问题中出现的数列。由以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)命名，其前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, … 令h(0)=1,h(1)=1，catalan数满足递推式[1]： h(n)= h(0)h(n-1)+h(1)h(n-2) + … + h(n-1)h(0) (n&gt;=2) 例如：h(2)=h(0)h(1)+h(1)h(0)=11+11=2 h(3)=h(0)h(2)+h(1)h(1)+h(2)h(0)=12+11+21=5 另类递推式[2]： h(n)=h(n-1)(4n-2)/(n+1); 代码： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; __int64 a[36]; a[1]=1; for(int i=2;i&lt;=35;i++) a[i]=a[i-1]*1.0/(i+1)*(4*i-2); //先除再乘，防止溢出。注意要乘1.0.。。。 int n,flag=0; while(scanf("%d",&amp;n)&amp;&amp;n&gt;0) &#123; printf("%d %d %I64d\n",++flag,n,2*a[n]); &#125; return 0;&#125; HDU2069 Coin Change(DP 背包)Problem Description Suppose there are 5 types of coins: 50-cent, 25-cent, 10-cent, 5-cent, and 1-cent. We want to make changes with these coins for a given amount of money. For example, if we have 11 cents, then we can make changes with one 10-cent coin and one 1-cent coin, or two 5-cent coins and one 1-cent coin, or one 5-cent coin and six 1-cent coins, or eleven 1-cent coins. So there are four ways of making changes for 11 cents with the above coins. Note that we count that there is one way of making change for zero cent. Write a program to find the total number of different ways of making changes for any amount of money in cents. Your program should be able to handle up to 100 coins. Input The input file contains any number of lines, each one consisting of a number ( ≤250 ) for the amount of money in cents. Output For each input line, output a line containing the number of different ways of making changes with the above 5 types of coins. 分析： 动态规划问题，同时也是01背包问题，需要写出状态转换方程然后求解 https://blog.csdn.net/wzy_1988/article/details/12260343 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;cstdlib&gt;#include&lt;cctype&gt;#include&lt;cmath&gt;#define LL long longusing namespace std;const int a[5]=&#123;1,5,10,25,50&#125;;LL dp[255][101];//dp[j][k]:用k个硬币组成j值的个数int main()&#123; int n; while(cin&gt;&gt;n)&#123; //cout&lt;&lt;res[n]&lt;&lt;endl; memset(dp,0,sizeof(dp)); dp[0][0]=1; for(int i=0;i&lt;5;i++)&#123; for(int k=1;k&lt;=100;k++)&#123;//k个硬币 for(int j=a[i];j&lt;=n;j++)&#123; dp[j][k]+=dp[j-a[i]][k-1]; &#125; &#125; &#125; int res=0; for(int i=0;i&lt;=100;i++)&#123; res+=dp[n][i]; &#125; cout&lt;&lt;res&lt;&lt;endl; &#125; return 0;&#125; 小技巧：输出控制：c++中用cout输出，要求保留两位小数，比如，输出100，则为100.00 1cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;456.777&lt;&lt;endl 标准开头：1while (scanf("%d %d",&amp;n,&amp;r)!=EOF) 16进制数相加：1scanf("%I64X%I64X",&amp;a,&amp;b)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>tests</tag>
      </tags>
  </entry>
</search>
