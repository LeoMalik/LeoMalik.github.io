<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[卡塔兰数]]></title>
    <url>%2F%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0.html</url>
    <content type="text"><![CDATA[卡塔兰数卡塔兰数是一种常在技术问题中出现的数列，一般做到类似以下模型的时候套用公式即可： 应用组合数学中有非常多的组合结构可以用卡塔兰数来计数。在Richard P. Stanley的Enumerative Combinatorics: Volume 2一书的习题中包括了66个相异的可由卡塔兰数表达的组合结构。以下用n=3和n=4举若干例： C**n表示长度2n的dyck word的个数。Dyck word是一个有n个X和n个Y组成的字串，且所有的前缀字串皆满足X的个数大于等于Y的个数。以下为长度为6的dyck words: XXXYYY XYXXYY XYXYXY XXYYXY XXYXYY 将上例的X换成左括号，Y换成右括号，C**n表示所有包含n组括号的合法运算式的个数： ((())) ()(()) ()()() (())() (()()) C**n表示有n个节点组成不同构二叉树的方案数。下图中，n等于3，圆形表示节点，月牙形表示什么都没有。 C**n表示有2n+1个节点组成不同构满二叉树（full binary tree）的方案数。下图中，n等于3，圆形表示内部节点，月牙形表示外部节点。本质同上。 证明： 令1表示进栈，0表示出栈，则可转化为求一个2n位、含n个1、n个0的二进制数，满足从左往右扫描到任意一位时，经过的0数不多于1数。显然含n个1、n个0的2n位二进制数共有{\displaystyle {2n \choose n}}个，下面考虑不满足要求的数目。 考虑一个含n个1、n个0的2n位二进制数，扫描到第2m+1位上时有m+1个0和m个1（容易证明一定存在这样的情况），则后面的0-1排列中必有n-m个1和n-m-1个0。将2m+2及其以后的部分0变成1、1变成0，则对应一个n+1个0和n-1个1的二进制数。反之亦然（相似的思路证明两者一一对应）。 从而{\displaystyle C_{n}={2n \choose n}-{2n \choose n+1}={\frac {1}{n+1}}{2n \choose n}}。证毕。 C**n表示所有在n × n格点中不越过对角线的单调路径的个数。一个单调路径从格点左下角出发，在格点右上角结束，每一步均为向上或向右。计算这种路径的个数等价于计算Dyck word的个数：X代表“向右”，Y代表“向上”。下图为n = 4的情况： C**n表示通过连结顶点而将n + 2边的凸多边形分成三角形的方法个数。下图中为n = 4的情况： C**n表示对{1, …, n}依序进出栈的置换个数。一个置换w是依序进出栈的当S(w) = (1, …, n),其中S（w）递归定义如下：令w = unv，其中n为w的最大元素，u和v为更短的数列；再令S(w) = S(u)S(v)n，其中S为所有含一个元素的数列的单位元。 C**n表示集合{1, …, n}的不交叉划分的个数.那么, C**n永远不大于第n项贝尔数. C**n也表示集合{1, …, 2n}的不交叉划分的个数，其中每个段落的长度为2。综合这两个结论，可以用数学归纳法证明：在 魏格纳半圆分布定律 中度数大于2的情形下，所有 自由的 累积量s 为零。 该定律在 自由概率论 和 随机矩阵 理论中非常重要。 C**n表示用n个长方形填充一个高度为n的阶梯状图形的方法个数。下图为n = 4的情况： C**n表示表为2×n的矩阵的标准杨氏矩阵的数量。 也就是说，它是数字 1, 2, …, 2n 被放置在一个2×n的矩形中并保证每行每列的数字升序排列的方案数。同样的，该式可由勾长公式的一个特殊情形推导得出。 C**n表示n个无标号物品的半序的个数。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图最大匹配与匈牙利算法]]></title>
    <url>%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[推荐阅读：二分图的最大匹配、完美匹配和匈牙利算法 匈牙利算法匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。 ——-等等，看得头大？那么请看下面的版本： 通过数代人的努力，你终于赶上了剩男剩女的大潮，假设你是一位光荣的新世纪媒人，在你的手上有N个剩男，M个剩女，每个人都可能对多名异性有好感（-_-||暂时不考虑特殊的性取向），如果一对男女互有好感，那么你就可以把这一对撮合在一起，现在让我们无视掉所有的单相思（好忧伤的感觉），你拥有的大概就是下面这样一张关系图，每一条连线都表示互有好感。 本着救人一命，胜造七级浮屠的原则，你想要尽可能地撮合更多的情侣，匈牙利算法的工作模式会教你这样做： =============================================================================== 一： 先试着给1号男生找妹子，发现第一个和他相连的1号女生还名花无主，got it，连上一条蓝线 =============================================================================== 二：接着给2号男生找妹子，发现第一个和他相连的2号女生名花无主，got it =============================================================================== 三：接下来是3号男生，很遗憾1号女生已经有主了，怎么办呢？ 我们试着给之前1号女生匹配的男生（也就是1号男生）另外分配一个妹子。 (黄色表示这条边被临时拆掉) 与1号男生相连的第二个女生是2号女生，但是2号女生也有主了，怎么办呢？我们再试着给2号女生的原配()重新找个妹子(注意这个步骤和上面是一样的，这是一个递归的过程) 此时发现2号男生还能找到3号女生，那么之前的问题迎刃而解了，回溯回去 2号男生可以找3号妹子~ 1号男生可以找2号妹子了~ 3号男生可以找1号妹子 所以第三步最后的结果就是： =============================================================================== 四： 接下来是4号男生，很遗憾，按照第三步的节奏我们没法给4号男生腾出来一个妹子，我们实在是无能为力了……香吉士同学走好。 =============================================================================== 这就是匈牙利算法的流程，其中找妹子是个递归的过程，最最关键的字就是“腾”字其原则大概是：有机会上，没机会创造机会也要上 【code】 12345678910111213141516bool find(int x)&#123; int i,j; for (j=1;j&lt;=m;j++)&#123; //扫描每个妹子 if (line[x][j]==true &amp;&amp; used[j]==false) //如果有暧昧并且还没有标记过(这里标记的意思是这次查找曾试图改变过该妹子的归属问题，但是没有成功，所以就不用瞎费工夫了） &#123; used[j]=1; if (girl[j]==0 || find(girl[j])) &#123; //名花无主或者能腾出个位置来，这里使用递归 girl[j]=x; return true; &#125; &#125; &#125; return false;&#125; 在主程序我们这样做：每一步相当于我们上面描述的一二三四中的一步 12345for (i=1;i&lt;=n;i++)&#123; memset(used,0,sizeof(used)); //这个在每一步中清空 if find(i) all+=1;&#125; 二分图的最大匹配、完美匹配和匈牙利算法这篇文章讲无权二分图（unweighted bipartite graph）的最大匹配（maximum matching）和完美匹配（perfect matching），以及用于求解匹配的匈牙利算法（Hungarian Algorithm）；不讲带权二分图的最佳匹配。 二分图：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集 $U$ 和$V$ ，使得每一条边都分别连接$U$、$V$中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。 匹配：在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配。 我们定义匹配点、匹配边、未匹配点、非匹配边，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。 最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。 完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。 举例来说：如下图所示，如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是完美匹配问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是最大匹配问题。 基本概念讲完了。求解最大匹配问题的一个算法是匈牙利算法，下面讲的概念都为这个算法服务。 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）： 增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。 我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。 匈牙利树一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。例如，由图 7，可以得到如图 8 的一棵 BFS 树： 这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。如果原图中根本不含 7 号节点，那么从 2 号节点出发就会得到一棵匈牙利树。这种情况如图 9 所示（顺便说一句，图 8 中根节点 2 到非匹配叶子节点 7 显然是一条增广路，沿这条增广路扩充后将得到一个完美匹配）。 下面给出匈牙利算法的 DFS 和 BFS 版本的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 顶点、边的编号均从 0 开始// 邻接表储存struct Edge&#123; int from; int to; int weight; Edge(int f, int t, int w):from(f), to(t), weight(w) &#123;&#125;&#125;;vector&lt;int&gt; G[__maxNodes]; /* G[i] 存储顶点 i 出发的边的编号 */vector&lt;Edge&gt; edges;typedef vector&lt;int&gt;::iterator iterator_t;int num_nodes;int num_left;int num_right;int num_edges;int matching[__maxNodes]; /* 存储求解结果 */int check[__maxNodes];bool dfs(int u)&#123; for (iterator_t i = G[u].begin(); i != G[u].end(); ++i) &#123; // 对 u 的每个邻接点 int v = edges[*i].to; if (!check[v]) &#123; // 要求不在交替路中 check[v] = true; // 放入交替路 if (matching[v] == -1 || dfs(matching[v])) &#123; // 如果是未盖点，说明交替路为增广路，则交换路径，并返回成功 matching[v] = u; matching[u] = v; return true; &#125; &#125; &#125; return false; // 不存在增广路，返回失败&#125;int hungarian()&#123; int ans = 0; memset(matching, -1, sizeof(matching)); for (int u=0; u &lt; num_left; ++u) &#123; if (matching[u] == -1) &#123; memset(check, 0, sizeof(check)); if (dfs(u)) ++ans; &#125; &#125; return ans;&#125;queue&lt;int&gt; Q;int prev[__maxNodes];int Hungarian()&#123; int ans = 0; memset(matching, -1, sizeof(matching)); memset(check, -1, sizeof(check)); for (int i=0; i&lt;num_left; ++i) &#123; if (matching[i] == -1) &#123; while (!Q.empty()) Q.pop(); Q.push(i); prev[i] = -1; // 设 i 为路径起点 bool flag = false; // 尚未找到增广路 while (!Q.empty() &amp;&amp; !flag) &#123; int u = Q.front(); for (iterator_t ix = G[u].begin(); ix != G[u].end() &amp;&amp; !flag; ++ix) &#123; int v = edges[*ix].to; if (check[v] != i) &#123; check[v] = i; Q.push(matching[v]); if (matching[v] &gt;= 0) &#123; // 此点为匹配点 prev[matching[v]] = u; &#125; else &#123; // 找到未匹配点，交替路变为增广路 flag = true; int d=u, e=v; while (d != -1) &#123; int t = matching[d]; matching[d] = e; matching[e] = d; d = prev[d]; e = t; &#125; &#125; &#125; &#125; Q.pop(); &#125; if (matching[i] != -1) ++ans; &#125; &#125; return ans;&#125; 匈牙利算法的要点如下 从左边第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路。 如果经过一个未匹配点，说明寻找成功。更新路径信息，匹配边数 +1，停止搜索。 如果一直没有找到增广路，则不再从这个点开始搜索。事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。 由于找到增广路之后需要沿着路径更新匹配，所以我们需要一个结构来记录路径上的点。DFS 版本通过函数调用隐式地使用一个栈，而 BFS 版本使用 prev 数组。 性能比较 两个版本的时间复杂度均为$O\big(V \cdot E\big)$。DFS 的优点是思路清晰、代码量少，但是性能不如 BFS。我测试了两种算法的性能。对于稀疏图，BFS 版本明显快于 DFS 版本；而对于稠密图两者则不相上下。在完全随机数据 9000 个顶点 4,0000 条边时前者领先后者大约 97.6%，9000 个顶点 100,0000 条边时前者领先后者 8.6%, 而达到 500,0000 条边时 BFS 仅领先 0.85%。 补充定义和定理： 最大匹配数：最大匹配的匹配边的数目 最小点覆盖数：选取最少的点，使任意一条边至少有一个端点被选择 最大独立数：选取最多的点，使任意所选两点均不相连 最小路径覆盖数：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。 定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理） 定理2：最大匹配数 = 最大独立数 定理3：最小路径覆盖数 = 顶点数 - 最大匹配数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra-最短路径算法]]></title>
    <url>%2FDijkstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[推荐阅读，转自:【啊哈！算法】系列7：Dijkstra最短路算法 上周我们介绍了神奇的只有五行的Floyd最短路算法，它可以方便的求得任意两点的最短路径，这称为“多源最短路”。本周来来介绍指定一个点（源点）到其余各个顶点的最短路径，也叫做“单源最短路径”。例如求下图中的1号顶点到2、3、4、5、6号顶点的最短路径。 ​ 与Floyd-Warshall算法一样这里仍然使用二维数组e来存储顶点之间边的关系，初始值如下。 ​ 我们还需要用一个一维数组dis来存储1号顶点到其余各个顶点的初始路程，如下。 ​ 我们将此时dis数组中的值称为最短路的“估计值”。 ​ 既然是求1号顶点到其余各个顶点的最短路程，那就先找一个离1号顶点最近的顶点。通过数组dis可知当前离1号顶点最近是2号顶点。当选择了2号顶点后，dis[2]的值就已经从“估计值”变为了“确定值”，即1号顶点到2号顶点的最短路程就是当前dis[2]值。为什么呢？你想啊，目前离1号顶点最近的是2号顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得1号顶点到2号顶点的路程进一步缩短了。因为1号顶点到其它顶点的路程肯定没有1号到2号顶点短，对吧O(∩_∩)O~ ​ 既然选了2号顶点，接下来再来看2号顶点有哪些出边呢。有2-&gt;3和2-&gt;4这两条边。先讨论通过2-&gt;3这条边能否让1号顶点到3号顶点的路程变短。也就是说现在来比较dis[3]和dis[2]+e[2] [3]的大小。其中dis[3]表示1号顶点到3号顶点的路程。dis[2]+e[2] [3]中dis[2]表示1号顶点到2号顶点的路程，e[2] [3]表示2-&gt;3这条边。所以dis[2]+e[2] [3]就表示从1号顶点先到2号顶点，再通过2-&gt;3这条边，到达3号顶点的路程。 ​ 我们发现dis[3]=12，dis[2]+e[2] [3]=1+9=10，dis[3]&gt;dis[2]+e[2] [3]，因此dis[3]要更新为10。这个过程有个专业术语叫做“松弛”。即1号顶点到3号顶点的路程即dis[3]，通过2-&gt;3这条边松弛成功。这便是Dijkstra算法的主要思想：通过“边”来松弛1号顶点到其余各个顶点的路程。 ​ 同理通过2-&gt;4（e[2] [4]），可以将dis[4]的值从∞松弛为4（dis[4]初始为∞，dis[2]+e[2] [4]=1+3=4，dis[4]&gt;dis[2]+e[2] [4]，因此dis[4]要更新为4）。 ​ 刚才我们对2号顶点所有的出边进行了松弛。松弛完毕之后dis数组为： ​ 接下来，继续在剩下的3、4、5和6号顶点中，选出离1号顶点最近的顶点。通过上面更新过dis数组，当前离1号顶点最近是4号顶点。此时，dis[4]的值已经从“估计值”变为了“确定值”。下面继续对4号顶点的所有出边（4-&gt;3，4-&gt;5和4-&gt;6）用刚才的方法进行松弛。松弛完毕之后dis数组为： ​ 继续在剩下的3、5和6号顶点中，选出离1号顶点最近的顶点，这次选择3号顶点。此时，dis[3]的值已经从“估计值”变为了“确定值”。对3号顶点的所有出边（3-&gt;5）进行松弛。松弛完毕之后dis数组为： ​ 继续在剩下的5和6号顶点中，选出离1号顶点最近的顶点，这次选择5号顶点。此时，dis[5]的值已经从“估计值”变为了“确定值”。对5号顶点的所有出边（5-&gt;4）进行松弛。松弛完毕之后dis数组为： ​ 最后对6号顶点所有点出边进行松弛。因为这个例子中6号顶点没有出边，因此不用处理。到此，dis数组中所有的值都已经从“估计值”变为了“确定值”。 ​ 最终dis数组如下，这便是1号顶点到其余各个顶点的最短路径。 ​ OK，现在来总结一下刚才的算法。算法的基本思想是：每次找到离源点（上面例子的源点就是1号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。基本步骤如下： 将所有的顶点分为两部分：已知最短路程的顶点集合P和未知最短路径的顶点集合Q。最开始，已知最短路径的顶点集合P中只有源点一个顶点。我们这里用一个book[ i ]数组来记录哪些点在集合P中。例如对于某个顶点i，如果book[ i ]为1则表示这个顶点在集合P中，如果book[ i ]为0则表示这个顶点在集合Q中。 设置源点s到自己的最短路径为0即dis=0。若存在源点有能直接到达的顶点i，则把dis[ i ]设为e[s] [ i ]。同时把所有其它（源点不能直接到达的）顶点的最短路径为设为∞。 在集合Q的所有顶点中选择一个离源点s最近的顶点u（即dis[u]最小）加入到集合P。并考察所有以点u为起点的边，对每一条边进行松弛操作。例如存在一条从u到v的边，那么可以通过将边u-&gt;v添加到尾部来拓展一条从s到v的路径，这条路径的长度是dis[u]+e[u] [v]。如果这个值比目前已知的dis[v]的值要小，我们可以用新值来替代当前dis[v]中的值。 重复第3步，如果集合Q为空，算法结束。最终dis数组中的值就是源点到所有顶点的最短路径。 ​ 完整的Dijkstra算法代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;int main()&#123; int e[10][10],dis[10],book[10],i,j,n,m,t1,t2,t3,u,v,min; int inf=99999999; //用inf(infinity的缩写)存储一个我们认为的正无穷值 //读入n和m，n表示顶点个数，m表示边的条数 scanf("%d %d",&amp;n,&amp;m); //初始化 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) if(i==j) e[i][j]=0; else e[i][j]=inf; //读入边 for(i=1;i&lt;=m;i++) &#123; scanf("%d %d %d",&amp;t1,&amp;t2,&amp;t3); e[t1][t2]=t3; &#125; //初始化dis数组，这里是1号顶点到其余各个顶点的初始路程 for(i=1;i&lt;=n;i++) dis[i]=e[1][i]; //book数组初始化 for(i=1;i&lt;=n;i++) book[i]=0; book[1]=1; //Dijkstra算法核心语句 for(i=1;i&lt;=n-1;i++) &#123; //找到离1号顶点最近的顶点 min=inf; for(j=1;j&lt;=n;j++) &#123; if(book[j]==0 &amp;&amp; dis[j]&lt;min) &#123; min=dis[j]; u=j; &#125; &#125; book[u]=1; for(v=1;v&lt;=n;v++) &#123; if(e[u][v]&lt;inf) &#123; if(dis[v]&gt;dis[u]+e[u][v]) dis[v]=dis[u]+e[u][v]; &#125; &#125; &#125; //输出最终的结果 for(i=1;i&lt;=n;i++) printf("%d ",dis[i]); getchar(); getchar(); return 0;&#125; ​ 可以输入以下数据进行验证。第一行两个整数n m。n表示顶点个数（顶点编号为1~n），m表示边的条数。接下来m行表示，每行有3个数x y z。表示顶点x到顶点y边的权值为z。 123456789106 91 2 11 3 122 3 92 4 33 5 54 3 44 5 134 6 155 6 4 ​ 运行结果是 10 1 8 4 13 17 通过上面的代码我们可以看出，这个算法的时间复杂度是O(N2)。其中每次找到离1号顶点最近的顶点的时间复杂度是O(N)，这里我们可以用“堆”（以后再说）来优化，使得这一部分的时间复杂度降低到O(logN)。另外对于边数M少于N2的稀疏图来说（我们把M远小于N2的图称为稀疏图，而M相对较大的图称为稠密图），我们可以用邻接表（这是个神马东西？不要着急，下周再仔细讲解）来代替邻接矩阵，使得整个时间复杂度优化到O( (M+N)logN )。请注意！在最坏的情况下M就是N2，这样的话MlogN要比N2还要大。但是大多数情况下并不会有那么多边，因此(M+N)logN要比N2小很多。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法]]></title>
    <url>%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[贪心算法贪心算法是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法的基本思路是从问题的某一个初始解出发一步一步地进行，根据某个优化测度，每一步都要确保能获得局部最优解。每一步只考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连在一起不再是可行解时，就不把该数据添加到部分解中，直到把所有数据枚举完，或者不能再添加算法停。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 一句话：不求最优，仅仅求可行解。 选择使用贪心算法 我们能够依据贪心法的2个重要的性质去证明：贪心选择性质和最优子结构性质。 1、贪心选择 什么叫贪心选择？从字义上就是贪心也就是目光短线。贪图眼前利益。在算法中就是仅仅依据当前已有的信息就做出选择，并且以后都不会改变这次选择。（这是和动态规划法的主要差别） 所以对于一个详细问题。要确定它是否具有贪心选择性质，必须证明每做一步贪心选择是否终于导致问题的总体最优解。 2、最优子结构 当一个问题的最优解包括其子问题的最优解时，称此问题具有最优子结构性质。 ​ 运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。动态规划主要运用于二维或三维问题，而贪心一般是一维问题 基本思路贪心算法的基本思路是从问题的某一个初始解触发一步一步地进行，根据抹个优化测度，每一步都要确保能获得局部最优解，每一步值考虑一个数据，他的选取应该满足局部优化的条件。若下一个数据和部分最优解连载一起不再是可行解时，就不把改数据添加到部分解中，知道把所有数据枚举玩，或者不能在添加算法停止。 过程 建立数学模型来描述问题； 把求解的问题分成若干个子问题； 对每一子问题求解，得到子问题的局部最优解； 把子问题的解局部最优解合成原来解问题的一个解。 算法特性 随着算法的进行，将积累起其它两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象。 有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优。 还有一个函数检查是否一个候选对象的集合是可行的，也即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性。 选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解。 最后，目标函数给出解的值。 为了解决问题，需要寻找一个构成解的候选对象集合，它可以优化目标函数，贪婪算法一步一步的进行。起初，算法选出的候选对象的集合为空。接下来的每一步中，根据选择函数，算法从剩余候选对象中选出最有希望构成解的对象。如果集合中加上该对象后不可行，那么该对象就被丢弃并不再考虑；否则就加到集合里。每一次都扩充集合，并检查该集合是否构成解。如果贪婪算法正确工作，那么找到的第一个解通常是最优的。 一般求解过程 使用贪心法求解能够依据下面几个方面进行（终于也相应着每步代码的实现），以找零钱为例： 1、候选集合(C) 通过一个候选集合C作为问题的可能解。（终于解均取自于候选集合C） 比如。在找零钱问题中，各种面值的货币构成候选集合。 2、解集合(S) 每完毕一次贪心选择，将一个解放入S。终于获得一个完整解S 3、解决函数(solution) 检查解集合S是否构成问题的完整解。 比如，在找零钱问题中。解决函数是已付出的货币金额恰好等于应付款。 4、选择函数(select) 即贪心策略。这是贪心法的关键，选择出最有希望构成问题的解的对象。 （这个选择函数通常和目标函数有关） 比如，在找零钱问题中，贪心策略就是在候选集合中选择面值最大的货币。 5、可行函数(feasible) 检查解集合中增加一个候选对象是否可行。（增加下一个对象后是不是满足约束条件） 比如。在找零钱问题中，可行函数是每一步选择的货币和已付出的货币相加不超过应付款。 例子1.活动选择问题有n个需要在同一天使用同一个教室的活动a1,a2,…,an，教室同一时刻只能由一个活动使用。每个活动ai都有一个开始时间si和结束时间fi 。一旦被选择后，活动ai就占据半开时间区间[si,fi)。如果[si,fi]和[sj,fj]互不重叠，ai和aj两个活动就可以被安排在这一天。该问题就是要安排这些活动使得尽量多的活动能不冲突的举行。 问题分析：活动安排问题要求安排一系列争用某一公共资源的活动。用贪心算法可提供一个简单、漂亮的方法，使尽可能多的活动能兼容的使用公共资源。设有n个活动的集合｛0，1，2，…，n-1｝，其中每个活动都要求使用同一资源，如会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间starti和一个结束时间endi，且starti&lt;endi。如选择了活动i，则它在半开时间区间[starti,endi）内占用资源。若区间[starti,endi)与区间[startj,endj)不相交，称活动i与活动j是相容的。也就是说，当startj≥endi或starti≥endj时，活动i与活动j相容。活动安排问题就是在所给的活动集合中选出最多的不相容活动。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合，是可以用贪心算法有效求解的很好例子。该问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。 算法设计：若被检查的活动i的开始时间starti小于最近选择的活动j的结束时间endj，则不选择活动i，否则选择活动i加入集合中。运用该算法解决活动安排问题的效率极高。当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用O(nlogn)的时间重排。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt; #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int N; struct Act &#123; int start; int end; &#125;act[100010]; bool cmp(Act a,Act b) &#123; return a.end&lt;b.end; &#125; int greedy_activity_selector() &#123; int num=1,i=1; for(int j=2;j&lt;=N;j++) &#123; if(act[j].start&gt;=act[i].end) &#123; i=j; num++; &#125; &#125; return num; &#125; int main() &#123; int t; scanf("%d",&amp;t); while(t--) &#123; scanf("%d",&amp;N); for(int i=1;i&lt;=N;i++) &#123; scanf("%lld %lld",&amp;act[i].start,&amp;act[i].end); &#125; act[0].start=-1; act[0].end=-1; sort(act+1,act+N+1,cmp); int res=greedy_activity_selector(); cout&lt;&lt;res&lt;&lt;endl; &#125; &#125; 2.钱币找零问题这个问题在我们的日常生活中就更加普遍了。假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？用贪心算法的思想，很显然，每一步尽可能用面值大的纸币即可。在日常生活中我们自然而然也是这么做的。在程序中已经事先将Value按照从小到大的顺序排好。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=7; int Count[N]=&#123;3,0,2,1,0,3,5&#125;;int Value[N]=&#123;1,2,5,10,20,50,100&#125;; int solve(int money) &#123; int num=0; for(int i=N-1;i&gt;=0;i--) &#123; int c=min(money/Value[i],Count[i]); money=money-c*Value[i]; num+=c; &#125; if(money&gt;0) num=-1; return num;&#125; int main() &#123; int money; cin&gt;&gt;money; int res=solve(money); if(res!=-1) cout&lt;&lt;res&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl;&#125; 3.背包问题有一个背包，背包容量是M=150kg。有7个物品，物品不可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。 问题分析目标函数： ∑pi最大，使得装入背包中的所有物品pi的价值加起来最大。 约束条件：装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150) 贪心策略： ⑴根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？ ⑵每次挑选所占重量最小的物品装入是否能得到最优解？ ⑶每次选取单位重量价值最大的物品，成为解本题的策略。 ⑴贪心策略：选取价值最大者。 W=30 物品：A B C 重量：28 12 12 价值：30 20 20 根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。 ⑵贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。 ⑶贪心策略：选取单位重量价值最大的物品。 反例： W=30 物品：A B C 重量：28 20 10 价值：28 20 10 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。 【注意：如果物品可以分割为任意大小，那么策略3可得最优解】 对于选取单位重量价值最大的物品这个策略，可以再加一条优化的规则：对于单位重量价值一样的，则优先选择重量小的！这样，上面的反例就解决了。 但是，如果题目是如下所示，这个策略就也不行了。 W=40 物品：A B C 重量：25 20 15 价值：25 20 15 算法设计： 计算出每个物品单位重量的价值 按单位价值从大到小将物品排序 根据背包当前所剩容量选取物品 如果背包的容量大于当前物品的重量，那么就将当前物品装进去。否则，那么就将当前物品舍去，然后跳出循环结束。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef struct&#123; int w; int v; double avg;&#125;P;bool cmp(P a,P b)&#123; return a.avg&gt;b.avg;&#125;int main()&#123; P *p; int n,i,m;//n 物品个数 m背包容量 while(cin&gt;&gt;n&gt;&gt;m)&#123; p=new P[n]; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;p[i].w&gt;&gt;p[i].v; p[i].avg=p[i].v/p[i].w*1.0; &#125; sort(p,p+n,cmp); int maxvalue=0; for(i=0;i&lt;n;i++)&#123; if(p[i].w&lt;=m)&#123; m-=p[i].w; maxvalue+=p[i].v; &#125;else&#123; break; &#125; &#125; cout&lt;&lt;maxvalue&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2000-2099 入门笔记]]></title>
    <url>%2FHDU%202000-2099%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[都说HDU 2000-2099 是acm入门必刷题，为了备战蓝桥杯，巩固知识，我做了一些小笔记与总结。 HDU 1002 A+B Problem two(大数问题)大数问题，通用的方法是使用string进行ascii码的加减 两个数字的ascii码相加减去 0 就是对应数字的ascii码 如果相加的数大于10,相加的ascii码减去10就是个位数 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string sum(string &amp;s1, string &amp;s2)&#123; if (s1 == "" &amp;&amp; s2 == "") return "0"; if (s1 == "") return s2; if (s2 == "") return s1; string max, min; int lens1 = s1.length(); int lens2 = s2.length(); if (lens1 &lt; lens2) &#123; max = s2; min = s1; &#125; else &#123; max = s1; min = s2; &#125; int maxlen = max.length(); int minlen = min.length(); int i, j; for (i = maxlen - 1, j = minlen - 1; j &gt;= 0; j--, i--) &#123; max[i] = max[i] + min[i] - '0'; //相加的ascii码-0就是对应数组的ascii码 &#125; for (int i = maxlen - 1; i &gt; 0; i--) &#123; if (max[i] &gt; '9') &#123; max[i] = max[i] - 10; //相加的ascii码-10就是个位数 max[i - 1] += 1; &#125; &#125; if (max[0] &gt; '9') &#123; max[0] -= 10; max = "1" + max; &#125; return max;&#125;int main()&#123; int num; cin &gt;&gt; num; int i = 1; int count = num; while (num) &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; cout &lt;&lt; "Case " &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; cout &lt;&lt; s1 &lt;&lt; " + " &lt;&lt; s2 &lt;&lt; " = " &lt;&lt; sum(s1, s2) &lt;&lt; endl; if (i &lt; count) cout &lt;&lt; endl; num--; i++; &#125; return 0;&#125; HDU 2018 母牛的故事(递推)相似：HDU 2044~2050,HDU2041 Description 有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？Input 输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt; n&lt; 55)，n的含义如题目中描述。 n=0表示输入数据的结束，不做处理。Output 对于每个测试实例，输出在第n年的时候母牛的数量。 每个输出占一行。 分析:​ 以n=6为例，fn=9头牛可以分解为6+3，其中6是上一年（第5年）的牛，3是新生的牛（因为第3年有3头牛，这3头在第6年各生一头牛）。 我们可以得出这样一个公式：fn=fn-1+fn-3 再理解一下，fn-1是前一年的牛，第n年仍然在，fn-3是前三年那一年的牛，但换句话说也就是第n年具有生育能力的牛，也就是第n年能生下的小牛数。 代码: 123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int f(int n);int main()&#123; int n; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; cout&lt;&lt;f(n)&lt;&lt;endl; &#125; return 0;&#125; int f(int n)&#123; if(n&lt;4) return n; //第1，2，3年，各为1，2，3头 else return f(n-1)+f(n-3); //第n年为前一年的和前3年的相加&#125; HDU 2031 进制转换(模拟):Problem Description 输入一个十进制数N，将它转换成R进制数输出。 Input 输入数据包含多个测试实例，每个测试实例包含两个整数N(32位整数)和R（2&lt;=R&lt;=16, R&lt;&gt;10）。 Output 为每个测试实例输出转换后的数，每个输出占一行。如果R大于10，则对应的数字规则参考16进制（比如，10用A表示，等等）。 分析: 进制转换,也就是取余,以7的二进制表示: 7%2=1…7/2=3 3%2=1…3/2=1 1%2=1…1/2=0 取余的数字拼接为111,直到商为0为止,即是7的二进制表示 代码: 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;int main()&#123; int n,r,i,x,flag; int a[1000]; while (scanf("%d %d",&amp;n,&amp;r)!=EOF) &#123; flag=0; if (n&lt;0) &#123; n=-n; flag=1; &#125; x=0; while (n) &#123; a[x]=n%r; n/=r; x++; &#125; while (x--) &#123; if (flag) &#123; printf("-"); flag=0; &#125; if (a[x]&lt;10) printf("%d",a[x]); else printf("%c",55+a[x]); &#125; printf("\n"); &#125; return 0;&#125; HDU 2048 神、上帝以及老天爷(错排问题)相似：HDU 2049 Description HDU 2006’10 ACM contest的颁奖晚会隆重开始了！为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的： 首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；然后，待所有字条加入完毕，每人从箱中取一个字条；最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！” 大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！ 我的神、上帝以及老天爷呀，怎么会这样呢？ 不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？ 不会算？难道你也想以悲剧结尾？！ Input 输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数n(1 &lt; n &lt; =20),表示参加抽奖的人数。 Output 对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。 分析: 典型的错排问题,具体思路如下: 当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推. 把第n个元素放在一个位置，比如位置k，一共有n-1种方法； 放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法； 综上得到 D(n) = (n-1) [D(n-2) + D(n-1)] 特殊地，D(1) = 0, D(2) = 1. 代码： 12345678910111213141516171819202122#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int n; int i,j,num; long long D[22],F[22]; D[1]=0;D[2]=1; for(i=3;i&lt;21;i++) D[i]=(i-1)*(D[i-1]+D[i-2]); for(i=20;i&gt;0;i--)&#123; F[i]=i; for(j=i-1;j&gt;1;j--) F[i]*=j; &#125; scanf("%d",&amp;num); while(num--)&#123; scanf("%d",&amp;n); printf("%.2lf%%\n",D[n]*100.0/F[n]); &#125; return 0;&#125; HDU 2053 Switch Game(开灯问题,唯一分解定理)Problem Description There are many lamps in a line. All of them are off at first. A series of operations are carried out on these lamps. On the i-th operation, the lamps whose numbers are the multiple of i change the condition ( on to off and off to on ). Input Each test case contains only a number n ( 0&lt; n&lt;= 10^5) in a line. Output Output the condition of the n-th lamp after infinity operations ( 0 - off, 1 - on ). 分析： 36的约数是 (1,36), (2,18), (3,12), (4,9), (6)，任何一个数都是由两个不同的数相乘得到的，但是如果一个数为平方数，那么这两个数就可以相等，例如36由两个6相乘得到，所以要判断灯的状态，只需要判断这个数是不是平方数即可 代码： 1234567891011121314#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n; while(cin&gt;&gt;n) &#123; double x=sqrt(n*1.0); cout&lt;&lt;(x==int(x))&lt;&lt;endl; &#125; return 0;&#125; HDU 2057 A + B Again (16进制数相加)Problem Description There must be many A + B problems in our HDOJ , now a new one is coming.Give you two hexadecimal integers , your task is to calculate the sum of them,and print it in hexadecimal too.Easy ? AC it ! Input The input contains several test cases, please process to the end of the file.Each case consists of two hexadecimal integers A and B in a line seperated by a blank.The length of A and B is less than 15. Output For each test case,print the sum of A and B in hexadecimal in one line. 分析： 涉及到16进制内的加法，可以用%I64x直接来处理，要注意到16进制中负数是用补码来表示的。一个比较困惑的事实是，这道题再输出时，%64X中‘X’必须是大写，小写是过不了的。 注意：__int64 %I64X ,输出用大写 123456789101112131415#include "cstdio"int main()&#123; __int64 a,b,c; while(~scanf("%I64X%I64X",&amp;a,&amp;b)) &#123; c=a+b; if(c&gt;=0) printf("%I64X\n",c); else printf("-%I64X\n",-c); &#125; return 0;&#125; HDU 2062 Subset sequence（子序列）Problem Description Consider the aggregate An= { 1, 2, …, n }. For example, A1={1}, A3={1,2,3}. A subset sequence is defined as a array of a non-empty subset. Sort all the subset sequece of An in lexicography order. Your task is to find the m-th one. Input The input contains several test cases. Each test case consists of two numbers n and m ( 0&lt; n&lt;= 20, 0&lt; m&lt;= the total number of the subset sequence of An ). Output For each test case, you should output the m-th subset sequence of An in one line. 分析： 当n=2的时候 子序列从小到大 {1}, {1, 2}, {2}, {2, 1} 当n=3的时候 子序列从小到大 {1} {1, 2} {1, 2, 3} {1, 3} {1, 3, 2} {2}{2, 1}{2, 1, 3}{2, 3}{2, 3, 1} {3}{3, 1}{3, 1, 2}{3, 2}{3, 2, 1} 不难发现，An可以按首数字分成n组，而每组里除了第一项，剩下的就是An-1的子集合了。 ∴f(n) = n[f(n-1) + 1] f(1) = 1 我们拿测试数据3 10来做个示范，解释一下怎么求解。 因为n=3，所以开始数组里1、2、3三个数。 我们知道，n=2时，有4种排列，所以上面n=3可以分成三组，每组5个(加上空集)。 //空集就是说去掉该组第一个数字后为空集 因此第10个在第二组里。所以第一个是2，把2输出。原来的数组里删除2，变成1、3两个数。然后10 - (2 - 1) * 5 =5，即它在第2组的第5个。 //请自行推导所在位置 减去首个空集合，5 - 1 = 4 ≠ 0，表示2后面还有数字。 因为A1 = 1是，所以再第2组里又可以分成两组，每组2个(加上空集)。 所以，4在第2组，剩下的数组中，第二个元素是3，所以输出3。再把数组里的3删除，剩下1一个数。 然后4 - (2 - 1) * 2 = 2，既它是第2组的第2个。 减去首个空集，2 - 1 = 1 ≠ 0，表示2后面还有数字。 按上面的方法继续下去，直到n = 0 或 后面为空集为止。 最后输出数组里的第1个元素，就得到2 3 1，就是解了。从上面的计算可以看出来，本题目的关键是先求的An中每一组的个数g(n) 不难得出:g(n) = f(n) / n ∵f(n) = n[f(n-1) + 1] ∴g(n) = n[f(n-1) + 1] / n = f(n-1) + 1 ∵f(n-1) = (n-1) * g(n-1) ∴g(n) = (n-1) * g(n-1) + 1 代码： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;cstring&gt;int main()&#123; int a; __int64 b; __int64 g[30]; g[1]=1; g[2]=2; for(int i=3;i&lt;22;i++) &#123; g[i]=g[i-1]*(i-1)+1;//求出g； &#125; int num[30]; while(scanf("%d%I64d",&amp;a,&amp;b)!=EOF) //b的数可能很大，所以用I64d，，用int运行错了 &#123; memset(num,0,sizeof(num));//清零 for(int i=1;i&lt;=a;i++) num[i]=i; //将要输出的数字保存在数组里 int am=a; while(a--)//总共有a个数（1---a）最多可能输出a个 &#123; int n=b%g[a+1]? b/g[a+1]+1: b/g[a+1]; //我们用b取余对应的g，，得到要输出的数在第几组 if(num[n]==0) break; if(am-1==a) printf("%d",num[n]); / /输出对应的组代表的数字 else printf(" %d",num[n]); for(int i=n;i&lt;=a;i++) num[i]=num[i+1]; //将刚输出的数字删掉，，留下剩下的数字，，没用的数字都变成0了 b=(b-g[a+1]*(n-1)-1); //把问题缩小到下一组，，， 求出在下一组的位置；循环；直到要输出的num为0，说明所有的数都输完了； &#125; printf("\n"); &#125; return 0;&#125; HDU 2064 汉诺塔Ⅲ（递归）Problem Description 约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？ Input 包含多组数据，每次输入一个N值(1&lt;=N=35)。 Output 对于每组数据，输出移动最小的次数。 分析： 建议阅读 如何理解汉诺塔的递归？ - 知乎 其实本题的复杂之处就是相当与比以往的汉诺塔多移动了一次柱子，原来，现在a4=a3+a3+a3+2(移动最大的圆盘要两次)，理解了便能很快求解 …HDU 2059 Seraph2012 (DP)HDU 2037 今年暑假不AC（贪心）推荐：贪心算法 Problem Description“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）Input输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。Output对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。 分析：最简单的贪心算法，因为一个节目对应一个开始时间和一个结束时间，所以，将这两个时间放到一个结构体中，然后对结束时间按照从小到大的顺序进行排序，如果结束的时间相同的话，就将开始的时间按照从大到小的顺序排序，然后开始比较，如果开始的时间比前一个结束的时间迟，就k++，最终k的值即为所求！ 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std; struct Program&#123; int start,end;&#125;pro[10001]; int main()&#123; int n,sum,final; int i,j; Program temp; while(scanf("%d",&amp;n) &amp;&amp; n) &#123; for(i=0;i&lt;n;++i) &#123; scanf("%d%d",&amp;pro[i].start,&amp;pro[i].end); &#125; for(i=0;i&lt;n-1;++i) for(j=i+1;j&lt;n;++j) if(pro[i].end&gt;pro[j].end) &#123; temp=pro[i]; pro[i]=pro[j]; pro[j]=temp; &#125; sum=1; final=pro[0].end; for(i=1;i&lt;n;++i) &#123; if(final&lt;=pro[i].start) &#123; ++sum; final=pro[i].end; &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125; HDU 2063 过山车 （二分图的最大匹配、完美匹配和匈牙利算法）Problem Description RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？ Input 输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。0&lt;K&lt;=10001&lt;=N 和M&lt;=500.接下来的K行，每行有两个数，分别表示女生Ai愿意和男生Bj做partner。最后一个0结束输入。 Output 对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。 分析： https://www.renfei.org/blog/bipartite-matching.html https://blog.csdn.net/dark_scope/article/details/8880547 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxn=505;int n,m;bool a[maxn][maxn];bool vis[maxn];int ok[maxn];//ok[x]=y;//第x个男生和第y个女生做partnerbool Find(int x)&#123; for(int i=1; i&lt;=n; i++)//男生 &#123; if(a[x][i]&amp;&amp;!vis[i]) &#123; vis[i]=true; //该男生没有被组合||该女生可以找其他人组合 if(!ok[i]||Find(ok[i])) &#123; ok[i]=x;//第i个男生和第x个女生做partner return true; &#125; &#125; &#125; return false;&#125;int main()&#123; int k; while(cin&gt;&gt;k,k) &#123; cin&gt;&gt;m&gt;&gt;n; memset(a,false,sizeof(a)); memset(ok,0,sizeof(ok)); int x,y; while(k--) &#123; cin&gt;&gt;x&gt;&gt;y; a[x][y]=true; &#125; int ans=0; for(int i=1; i&lt;=m; i++) //女生 &#123; memset(vis,false,sizeof(vis)); if(Find(i)) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; HDU 2066 一个人的旅行（最短路，多起点多终点，Dijkstra算法+spfa算法）Problem Description虽然草儿是个路痴（就是在杭电待了一年多，居然还会在校园里迷路的人，汗~),但是草儿仍然很喜欢旅行，因为在旅途中 会遇见很多人（白马王子，^0^），很多事，还能丰富自己的阅历，还可以看美丽的风景……草儿想去很多地方，她想要去东京铁塔看夜景，去威尼斯看电影，去阳明山上看海芋，去纽约纯粹看雪景，去巴黎喝咖啡写信，去北京探望孟姜女……眼看寒假就快到了，这么一大段时间，可不能浪费啊，一定要给自己好好的放个假，可是也不能荒废了训练啊，所以草儿决定在要在最短的时间去一个自己想去的地方！因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车（好可怜啊~）。 Input输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路)接着的第T+1行有S个数，表示和草儿家相连的城市；接着的第T+2行有D个数，表示草儿想去地方。 Output 输出草儿能去某个喜欢的城市的最短时间。 分析： http://blog.51cto.com/ahalei/1387799 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int a[1005][1005];int dis[1005];bool vis[1005];const int INF=0x3f3f3f3f;int n;void Dij()&#123; for(int i=0;i&lt;=n;i++) &#123; dis[i]=a[0][i]; vis[i]=false; &#125; vis[0]=true; dis[0]=0; for(int i=0;i&lt;=n;i++) &#123; int minn=INF; int p; for(int j=0;j&lt;=n;j++) &#123; if(!vis[j]&amp;&amp;dis[j]&lt;minn) &#123; minn=dis[p=j]; &#125; &#125; vis[p]=true; if(minn==INF) break; for(int j=0;j&lt;=n;j++) &#123; if(!vis[j]&amp;&amp;dis[j]&gt;dis[p]+a[p][j]) dis[j]=dis[p]+a[p][j]; &#125; &#125;&#125;int main()&#123; int t,s,d; int x,y,z; while(scanf("%d%d%d",&amp;t,&amp;s,&amp;d)!=EOF) &#123; n=0; memset(a,INF,sizeof(a)); while(t--) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); if(z&lt;a[x][y]) a[x][y]=a[y][x]=z; n=max(n,max(x,y)); &#125; while(s--) &#123; scanf("%d",&amp;x); a[0][x]=0; &#125; Dij(); int minn=INF; while(d--) &#123; scanf("%d",&amp;x); minn=min(minn,dis[x]); &#125; printf("%d\n",minn); &#125; return 0;&#125; HDU 2067 小兔的棋盘（卡塔兰数）Problem Description 小兔的叔叔从外面旅游回来给她带来了一个礼物，小兔高兴地跑回自己的房间，拆开一看是一个棋盘，小兔有所失望。不过没过几天发现了棋盘的好玩之处。从起点(0，0)走到终点(n,n)的最短路径数是C(2n,n),现在小兔又想如果不穿越对角线(但可接触对角线上的格点)，这样的路径数有多少?小兔想了很长时间都没想出来，现在想请你帮助小兔解决这个问题，对于你来说应该不难吧! Input 每次输入一个数n(1&lt;=n&lt;=35)，当n等于－1时结束输入。 Output 对于每个输入数据输出路径数，具体格式看Sample。 分析： https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0 遇到类似题型带公式即可 卡特兰数又称卡塔兰数，英文名Catalan number，是组合数学中一个常出现在各种计数问题中出现的数列。由以比利时的数学家欧仁·查理·卡塔兰 (1814–1894)命名，其前几项为 : 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, … 令h(0)=1,h(1)=1，catalan数满足递推式[1]： h(n)= h(0)h(n-1)+h(1)h(n-2) + … + h(n-1)h(0) (n&gt;=2) 例如：h(2)=h(0)h(1)+h(1)h(0)=11+11=2 h(3)=h(0)h(2)+h(1)h(1)+h(2)h(0)=12+11+21=5 另类递推式[2]： h(n)=h(n-1)(4n-2)/(n+1); 代码： 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; __int64 a[36]; a[1]=1; for(int i=2;i&lt;=35;i++) a[i]=a[i-1]*1.0/(i+1)*(4*i-2); //先除再乘，防止溢出。注意要乘1.0.。。。 int n,flag=0; while(scanf("%d",&amp;n)&amp;&amp;n&gt;0) &#123; printf("%d %d %I64d\n",++flag,n,2*a[n]); &#125; return 0;&#125; 小技巧：输出控制：c++中用cout输出，要求保留两位小数，比如，输出100，则为100.00 1cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;456.777&lt;&lt;endl 标准开头：1while (scanf("%d %d",&amp;n,&amp;r)!=EOF) 16进制数相加：1scanf("%I64X%I64X",&amp;a,&amp;b)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>tests</tag>
      </tags>
  </entry>
</search>
