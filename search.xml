<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>HDU 2000-2099入门笔记</title>
      <link href="/HDU-2000-2099%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.html"/>
      <url>/HDU-2000-2099%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0.html</url>
      
        <content type="html"><![CDATA[<p>都说HDU 2000-2099 是acm入门必刷题，为了备战蓝桥杯，巩固知识，我做了一些小笔记与总结。</p><a id="more"></a><p>HDU 1002 A+B Problem two(大数问题)</p><p>大数问题，通用的方法是使用string进行ascii码的加减</p><ul><li>两个数字的ascii码相加减去 0 就是对应数字的ascii码</li><li>如果相加的数大于10,相加的ascii码减去10就是个位数</li></ul><p>代码如下:</p><pre><code>#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string sum(string &amp;s1, string &amp;s2){    if (s1 == &quot;&quot; &amp;&amp; s2 == &quot;&quot;)        return &quot;0&quot;;    if (s1 == &quot;&quot;)        return s2;    if (s2 == &quot;&quot;)        return s1;    string max, min;    int lens1 = s1.length();    int lens2 = s2.length();    if (lens1 &lt; lens2)    {        max = s2;        min = s1;    }    else    {        max = s1;        min = s2;    }    int maxlen = max.length();    int minlen = min.length();    int i, j;    for (i = maxlen - 1, j = minlen - 1; j &gt;= 0; j--, i--)    {        max[i] = max[i] + min[i] - &apos;0&apos;; //相加的ascii码-0就是对应数组的ascii码    }    for (int i = maxlen - 1; i &gt; 0; i--)    {        if (max[i] &gt; &apos;9&apos;)        {            max[i] = max[i] - 10; //相加的ascii码-10就是个位数            max[i - 1] += 1;        }    }    if (max[0] &gt; &apos;9&apos;)    {        max[0] -= 10;        max = &quot;1&quot; + max;    }    return max;}int main(){    int num;    cin &gt;&gt; num;    int i = 1;    int count = num;    while (num)    {        string s1, s2;        cin &gt;&gt; s1 &gt;&gt; s2;        cout &lt;&lt; &quot;Case &quot; &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; endl;        cout &lt;&lt; s1 &lt;&lt; &quot; + &quot; &lt;&lt; s2 &lt;&lt; &quot; = &quot; &lt;&lt; sum(s1, s2) &lt;&lt; endl;        if (i &lt; count)            cout &lt;&lt; endl;        num--;        i++;    }    return 0;}</code></pre><p>HDU 2018 母牛的故事(递推)</p><p>相似：HDU 2044~2050,HDU2041</p><p>Description<br>　　有一头母牛，它每年年初生一头小母牛。每头小母牛从第四个年头开始，每年年初也生一头小母牛。请编程实现在第n年的时候，共有多少头母牛？<br>Input<br>　　输入数据由多个测试实例组成，每个测试实例占一行，包括一个整数n(0&lt; n&lt; 55)，n的含义如题目中描述。<br>　　n=0表示输入数据的结束，不做处理。<br>Output<br>　　对于每个测试实例，输出在第n年的时候母牛的数量。<br>　　每个输出占一行。</p><p>分析:    </p><pre><code>以n=6为例，fn=9头牛可以分解为6+3，其中6是上一年（第5年）的牛，3是新生的牛（因为第3年有3头牛，这3头在第6年各生一头牛）。</code></pre><p>　　我们可以得出这样一个公式：fn=fn-1+fn-3<br>　　再理解一下，fn-1是前一年的牛，第n年仍然在，fn-3是前三年那一年的牛，但换句话说也就是第n年具有生育能力的牛，也就是第n年能生下的小牛数。</p><p>代码:</p><pre><code>#include &lt;iostream&gt;using namespace std;int f(int n);int main(){    int n;    while(cin&gt;&gt;n&amp;&amp;n!=0)    {        cout&lt;&lt;f(n)&lt;&lt;endl;    }    return 0;}int f(int n){    if(n&lt;4)        return n; //第1，2，3年，各为1，2，3头    else        return f(n-1)+f(n-3);  //第n年为前一年的和前3年的相加}</code></pre><p>HDU 2031 进制转换(模拟):</p><p>Problem Description</p><p>输入一个十进制数N，将它转换成R进制数输出。</p><p>Input</p><p>输入数据包含多个测试实例，每个测试实例包含两个整数N(32位整数)和R（2&lt;=R&lt;=16, R&lt;&gt;10）。 </p><p>Output</p><p>为每个测试实例输出转换后的数，每个输出占一行。如果R大于10，则对应的数字规则参考16进制（比如，10用A表示，等等）。</p><p>分析:</p><p> 进制转换,也就是取余,以7的二进制表示:</p><ol><li>7%2=1…7/2=3</li><li>3%2=1…3/2=1</li><li>1%2=1…1/2=0</li></ol><p>取余的数字拼接为111,直到商为0为止,即是7的二进制表示</p><p>代码:</p><pre><code>#include &lt;stdio.h&gt;int main(){    int n,r,i,x,flag;    int a[1000];    while (scanf(&quot;%d %d&quot;,&amp;n,&amp;r)!=EOF)    {        flag=0;        if (n&lt;0)        {            n=-n;            flag=1;        }        x=0;        while (n)        {            a[x]=n%r;            n/=r;            x++;        }        while (x--)        {            if (flag)            {                printf(&quot;-&quot;);                flag=0;            }            if (a[x]&lt;10)                printf(&quot;%d&quot;,a[x]);            else printf(&quot;%c&quot;,55+a[x]);        }        printf(&quot;\n&quot;);    }    return 0;}</code></pre><p>HDU 2048 神、上帝以及老天爷(错排问题)</p><p>相似：HDU 2049</p><p>Description</p><p>HDU 2006’10 ACM contest的颁奖晚会隆重开始了！<br>为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的：</p><p>首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；<br>然后，待所有字条加入完毕，每人从箱中取一个字条；<br>最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”</p><p>大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！</p><p>我的神、上帝以及老天爷呀，怎么会这样呢？</p><p>不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？</p><p>不会算？难道你也想以悲剧结尾？！</p><p>Input</p><p>输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数n(1 &lt; n &lt; =20),表示参加抽奖的人数。</p><p>Output</p><p>对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。</p><p>分析:</p><p>典型的错排问题,具体思路如下:</p><p>当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推. </p><ol><li>把第n个元素放在一个位置，比如位置k，一共有n-1种方法； </li><li>放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法；<br>综上得到 D(n) = (n-1) [D(n-2) + D(n-1)]<br>特殊地，D(1) = 0, D(2) = 1.</li></ol><p>代码：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){    int n;    int i,j,num;    long long D[22],F[22];    D[1]=0;D[2]=1;    for(i=3;i&lt;21;i++)        D[i]=(i-1)*(D[i-1]+D[i-2]);    for(i=20;i&gt;0;i--){        F[i]=i;        for(j=i-1;j&gt;1;j--)            F[i]*=j;    }    scanf(&quot;%d&quot;,&amp;num);    while(num--){        scanf(&quot;%d&quot;,&amp;n);        printf(&quot;%.2lf%%\n&quot;,D[n]*100.0/F[n]);    }    return 0;}</code></pre><p>HDU 2053 Switch Game(开灯问题,唯一分解定理)</p><p>Problem Description</p><p>There are many lamps in a line. All of them are off at first. A series of operations are carried out on these lamps. On the i-th operation, the lamps whose numbers are the multiple of i change the condition ( on to off and off to on ).</p><p>Input</p><p>Each test case contains only a number n ( 0&lt; n&lt;= 10^5) in a line.</p><p>Output</p><p>Output the condition of the n-th lamp after infinity operations ( 0 - off, 1 - on ).</p><p>分析：</p><p>36的约数是 (1,36), (2,18), (3,12), (4,9), (6)，任何一个数都是由两个不同的数相乘得到的，但是如果一个数为平方数，那么这两个数就可以相等，例如36由两个6相乘得到，所以要判断灯的状态，只需要判断这个数是不是平方数即可</p><p>代码：</p><pre><code>#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main(){    int n;    while(cin&gt;&gt;n)    {        double x=sqrt(n*1.0);        cout&lt;&lt;(x==int(x))&lt;&lt;endl;    }    return 0;}</code></pre><p>HDU 2057 A + B Again (16进制数相加)</p><p>Problem Description</p><p>There must be many A + B problems in our HDOJ , now a new one is coming.<br>Give you two hexadecimal integers , your task is to calculate the sum of them,and print it in hexadecimal too.<br>Easy ? AC it !</p><p>Input</p><p>The input contains several test cases, please process to the end of the file.<br>Each case consists of two hexadecimal integers A and B in a line seperated by a blank.<br>The length of A and B is less than 15.</p><p>Output</p><p>For each test case,print the sum of A and B in hexadecimal in one line.</p><p>分析：</p><p>涉及到16进制内的加法，可以用%I64x直接来处理，要注意到16进制中负数是用补码来表示的。一个比较困惑的事实是，这道题再输出时，%64X中‘X’必须是大写，小写是过不了的。</p><p>注意：__int64 %I64X ,输出用大写</p><pre><code>#include &quot;cstdio&quot;int main(){    __int64 a,b,c;    while(~scanf(&quot;%I64X%I64X&quot;,&amp;a,&amp;b))    {        c=a+b;        if(c&gt;=0)            printf(&quot;%I64X\n&quot;,c);        else            printf(&quot;-%I64X\n&quot;,-c);    }    return 0;}</code></pre><p>HDU 2062 Subset sequence（子序列）</p><p>Problem Description</p><p>Consider the aggregate An= { 1, 2, …, n }. For example, A1={1}, A3={1,2,3}. A subset sequence is defined as a array of a non-empty subset. Sort all the subset sequece of An in lexicography order. Your task is to find the m-th one.</p><p>Input</p><p>The input contains several test cases. Each test case consists of two numbers n and m ( 0&lt; n&lt;= 20, 0&lt; m&lt;= the total number of the subset sequence of An ).</p><p>Output</p><p>For each test case, you should output the m-th subset sequence of An in one line.</p><p>分析：</p><p>当n=2的时候</p><p>子序列从小到大</p><p>{1},</p><p>{1, 2},</p><p>{2},</p><p>{2, 1}</p><p>当n=3的时候</p><p>子序列从小到大</p><p>{1}</p><p>{1, 2}</p><p>{1, 2, 3}</p><p>{1, 3}</p><p>{1, 3, 2}</p><p>{2}<br>{2, 1}<br>{2, 1, 3}<br>{2, 3}<br>{2, 3, 1}</p><p>{3}<br>{3, 1}<br>{3, 1, 2}<br>{3, 2}<br>{3, 2, 1}</p><p>不难发现，An可以按首数字分成n组，而每组里除了第一项，剩下的就是An-1的子集合了。</p><p>∴f(n) = n[f(n-1) + 1]</p><p>f(1) = 1</p><p>我们拿测试数据3 10来做个示范，解释一下怎么求解。</p><p>因为n=3，所以开始数组里1、2、3三个数。</p><p>我们知道，n=2时，有4种排列，所以上面n=3可以分成三组，每组5个(加上空集)。</p><p>//空集就是说去掉该组第一个数字后为空集</p><p>因此第10个在第二组里。所以第一个是2，把2输出。原来的数组里删除2，变成1、3两个数。然后10 - (2 - 1) * 5 =5，即它在第2组的第5个。</p><p>//请自行推导所在位置</p><p>减去首个空集合，5 - 1 = 4 ≠ 0，表示2后面还有数字。</p><p>因为A1 = 1是，所以再第2组里又可以分成两组，每组2个(加上空集)。</p><p>所以，4在第2组，剩下的数组中，第二个元素是3，所以输出3。再把数组里的3删除，剩下1一个数。</p><p>然后4 - (2 - 1) * 2 = 2，既它是第2组的第2个。</p><p>减去首个空集，2 - 1 = 1 ≠ 0，表示2后面还有数字。</p><p>按上面的方法继续下去，直到n = 0 或 后面为空集为止。</p><p>最后输出数组里的第1个元素，就得到2 3 1，就是解了。从上面的计算可以看出来，本题目的关键是先求的An中每一组的个数g(n)</p><p>不难得出:g(n) = f(n) / n</p><p>∵f(n) = n[f(n-1) + 1]</p><p>∴g(n) = n[f(n-1) + 1] / n = f(n-1) + 1</p><p>∵f(n-1) = (n-1) * g(n-1)</p><p>∴g(n) = (n-1) * g(n-1) + 1</p><p>代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;cstring&gt;int main(){    int a;    __int64 b;    __int64 g[30];    g[1]=1;    g[2]=2;    for(int i=3;i&lt;22;i++)    {        g[i]=g[i-1]*(i-1)+1;//求出g；    }    int num[30];    while(scanf(&quot;%d%I64d&quot;,&amp;a,&amp;b)!=EOF)  //b的数可能很大，所以用I64d，，用int运行错了    {        memset(num,0,sizeof(num));//清零        for(int i=1;i&lt;=a;i++)            num[i]=i;        //将要输出的数字保存在数组里        int am=a;        while(a--)//总共有a个数（1---a）最多可能输出a个        {            int n=b%g[a+1]? b/g[a+1]+1: b/g[a+1];       //我们用b取余对应的g，，得到要输出的数在第几组            if(num[n]==0)                break;            if(am-1==a)            printf(&quot;%d&quot;,num[n]);       /  /输出对应的组代表的数字            else            printf(&quot; %d&quot;,num[n]);            for(int i=n;i&lt;=a;i++)                num[i]=num[i+1];            //将刚输出的数字删掉，，留下剩下的数字，，没用的数字都变成0了            b=(b-g[a+1]*(n-1)-1);   //把问题缩小到下一组，，， 求出在下一组的位置；循环；直到要输出的num为0，说明所有的数都输完了；        }        printf(&quot;\n&quot;);    }    return 0;}</code></pre><p>HDU 2064 汉诺塔Ⅲ（递归）</p><p>Problem Description</p><p>约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。<br>现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。<br>Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？</p><p>Input</p><p>包含多组数据，每次输入一个N值(1&lt;=N=35)。</p><p>Output</p><p>对于每组数据，输出移动最小的次数。</p><p>分析：</p><p>建议阅读 如何理解汉诺塔的递归？ - 知乎</p><p>其实本题的复杂之处就是相当与比以往的汉诺塔多移动了一次柱子，原来，现在a4=a3+a3+a3+2(移动最大的圆盘要两次)，理解了便能很快求解</p><p>待补充：</p><p>HDU 2059  Seraph2012 (DP)</p><p>HDU 2037 今年暑假不AC（贪心）</p><p>HDU 2063 过山车 （二分图的最大匹配、完美匹配和匈牙利算法）</p><p><a href="https://www.renfei.org/blog/bipartite-matching.html" rel="external nofollow noopener noreferrer" target="_blank">https://www.renfei.org/blog/bipartite-matching.html</a></p><p>小技巧：</p><p>输出控制：</p><p>c++中用cout输出，要求保留两位小数，比如，输出100，则为100.00</p><pre><code>cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(2)&lt;&lt;456.777&lt;&lt;endl</code></pre><p>标准开头：</p><pre><code>while (scanf(&quot;%d %d&quot;,&amp;n,&amp;r)!=EOF)</code></pre><p>16进制数相加：</p><pre><code>scanf(&quot;%I64X%I64X&quot;,&amp;a,&amp;b)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/test.html"/>
      <url>/test.html</url>
      
        <content type="html"><![CDATA[<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><a id="more"></a><p><img src="https://ws1.sinaimg.cn/mw690/c364e082gy1fykjjog3jcj20xg0gpacc.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tests </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world.html"/>
      <url>/hello-world.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" rel="external nofollow noopener noreferrer" target="_blank">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" rel="external nofollow noopener noreferrer" target="_blank">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" rel="external nofollow noopener noreferrer" target="_blank">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" rel="external nofollow noopener noreferrer" target="_blank">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" rel="external nofollow noopener noreferrer" target="_blank">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" rel="external nofollow noopener noreferrer" target="_blank">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" rel="external nofollow noopener noreferrer" target="_blank">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> tests </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
